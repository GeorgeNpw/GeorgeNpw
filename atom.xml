<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeorgeN的博客</title>
  
  <subtitle>宁静致远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-05T12:54:13.258Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>npw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8的集合3：HashMap的实现原理</title>
    <link href="http://yoursite.com/2019/05/05/Java8%E7%9A%84%E9%9B%86%E5%90%883%EF%BC%9AHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/05/Java8的集合3：HashMap的实现原理/</id>
    <published>2019-05-05T12:47:29.000Z</published>
    <updated>2019-05-05T12:54:13.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一上来，先来看看源码中的这一段注释，我们可以从中提取到一些关键信息：<br>Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.<br>翻译一下大概就是在说，这个哈希表是基于Map接口的实现的，它允许null值和null键，它不是线程同步的，同时也不保证有序。<br>This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the “capacity” of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it’s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.<br>再来看看这一段，讲的是Map的这种实现方式为get（取）和put（存）带来了比较好的性能。但是如果涉及到大量的<strong>遍历操作</strong>的话，就尽量不要把capacity设置得太高（或load factor设置得太低），否则会严重降低遍历的效率。<br>影响HashMap性能的两个重要参数：“<strong>initial capacity</strong>”（初始化容量）和”<strong>load factor</strong>“（负载因子）。简单来说，容量就是哈希表桶的个数，负载因子就是键值对个数与哈希表长度的一个比值，当比值超过负载因子之后，HashMap就会进行rehash操作来进行扩容。<br>HashMap 的大致结构如下，其中哈希表是一个<strong>数组</strong>，我们经常把数组中的每一个节点称为一个桶，哈希表中的每个节点都用来存储一个键值对。在插入元素时，如果发生冲突（即多个键值对映射到同一个桶上）的话，就会通过<strong>链表</strong>的形式来解决冲突。因为一个桶上可能存在多个键值对，所以在查找的时候，会先通过key的哈希值先定位到桶，再遍历桶上的所有键值对，找出key相等的键值对，从而来获取value。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//默认的初始容量为16</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</span><br><span class="line">//最大的容量上限为2^30</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">//默认的负载因子为0.75</span><br><span class="line">static final <span class="built_in">float</span> DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">//变成树型结构的临界值为8</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">//恢复链式结构的临界值为6</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">//哈希表</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">//哈希表中键值对的个数</span><br><span class="line">transient int size;</span><br><span class="line">//哈希表被修改的次数</span><br><span class="line">transient int modCount;</span><br><span class="line">//它是通过capacity*load factor计算出来的，当size到达这个值时，就会进行扩容操作</span><br><span class="line">int threshold;</span><br><span class="line">//负载因子</span><br><span class="line">final <span class="built_in">float</span> loadFactor;</span><br><span class="line">//当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采取扩容来尝试减少冲突</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure><p>下面是 Node 类的定义，它是 HashMap 中的一个静态内部类，哈希表中的每一个节点都是 Node 类型。我们可以看到，Node 类中有 4 个属性，其中除了 key 和 value 之外，还有 hash 和 next 两个属性。hash 是用来存储 key 的哈希值的，next 是在构建链表时用来指向后继节点的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int <span class="built_in">hash</span>;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>实现步骤大致如下： </p><ol><li>通过hash值获取该key映射到的桶。</li><li>桶上的key就是要查找的key，则直接命中。 </li><li>桶上的key不是要查找的key，则查看后续节点：<br> （1）如果后续节点是树节点，通过调用树的方法查找该key。<br> （2）如果后续节点是链式节点，则通过循环遍历链查找该key。<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2>put方法比较复杂，实现步骤大致如下： </li><li>先通过hash值计算出key映射到哪个桶。</li><li>如果桶上没有碰撞冲突，则直接插入。 </li><li>如果出现碰撞冲突了，则需要处理冲突：<br> （1）如果该桶使用红黑树处理冲突，则调用红黑树的方法插入。<br> （2）否则采用传统的链式方法插入。如果链的长度到达临界值，则把链转变为红黑树。. .</li><li>如果桶中存在重复的键，则为该键替换新值。 </li><li>如果size大于阈值，则进行扩容。<h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2>理解了put方法之后，remove已经没什么难度了，所以重复的内容就不再做详细介绍了。<h2 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h2>在get方法和put方法中都需要先计算key映射到哪个桶上，然后才进行之后的操作，计算的主要代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - 1) &amp; hash</span><br></pre></td></tr></table></figure></li></ol><p>上面代码中的n指的是哈希表的大小，hash指的是key的哈希值，hash是通过下面这个方法计算出来的，采用了二次哈希的方式，其中key的hashCode方法是一个native方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int <span class="built_in">hash</span>(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    <span class="built_in">return</span> (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个hash方法先通过key的hashCode方法获取一个哈希值，再拿这个哈希值与它的<strong>高16位</strong>的哈希值做一个异或操作来得到最后的哈希值。</p><p>为啥要这样做呢？注释中是这样解释的：如果当n很小，假设为64的话，那么n-1即为63（0x111111），这样的值跟hashCode()直接做与操作，实际上只使用了哈希值的后6位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p><p>正是因为与的这个操作，决定了HashMap的大小只能是2的幂次方，想一想，如果不是2的幂次方，会发生什么事情？即使你在创建HashMap的时候指定了初始大小，HashMap在构建的时候也会调用下面这个方法来调整大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的作用看起来可能不是很直观，它的实际作用就是把cap变成第一个大于等于2的幂次方的数。例如，16还是16，13就会调整为16，17就会调整为32。</p><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算（n-1）&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。</p><p>例如，原来的容量为32，那么应该拿hash跟31（0x11111）做与操作；在扩容扩到了64的容量之后，应该拿hash跟63（0x111111）做与操作。新容量跟原来相比只是多了一个bit位，假设原来的位置在23，那么当新增的那个bit位的计算结果为0时，那么该节点还是在23；相反，计算结果为1时，则该节点会被分配到23+31的桶上。</p><p>正是因为这样巧妙的rehash方式，保证了rehash之后每个桶上的节点数必定小于等于原来桶上的节点数，即保证了rehash之后不会出现更严重的冲突。</p><p>在这里有一个需要注意的地方，有些文章指出当哈希表的<strong>桶占用</strong>超过阈值时就进行扩容，这是不对的；实际上是当哈希表中的<strong>键值对个数</strong>超过阈值时，才进行扩容的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>通过红黑树的方式来处理哈希冲突是我第一次看见！学过哈希，学过红黑树，就是从来没想到两个可以结合到一起这么用！</p></li><li><p>按照原来的拉链法来解决冲突，如果一个桶上的冲突很严重的话，是会导致哈希表的效率降低至O（n），而通过红黑树的方式，可以把效率改进至O（logn）。相比链式结构的节点，树型结构的节点会占用比较多的空间，所以这是一种以空间换时间的改进方式。</p></li></ul>]]></content>
    
    <summary type="html">
    
      HashMap是基于Map接口的实现的，它允许null值和null键，它不是线程同步的，同时也不保证有序。HashMap在进行扩容时，每次扩容都是翻倍。HashMap通过红黑树的方式来处理哈希冲突，可以把效率改进至O（logn）。相比链式结构的节点，树型结构的节点会占用比较多的空间，所以这是一种以空间换时间的改进方式。
    
    </summary>
    
      <category term="JAVA集合" scheme="http://yoursite.com/categories/JAVA%E9%9B%86%E5%90%88/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Java8的集合2：HashSet的实现原理</title>
    <link href="http://yoursite.com/2019/05/05/Java8%E7%9A%84%E9%9B%86%E5%90%882%EF%BC%9AHashSet%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/05/Java8的集合2：HashSet的实现原理/</id>
    <published>2019-05-05T12:47:02.000Z</published>
    <updated>2019-05-05T12:50:29.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HashSet是Set接口的典型实现，HashSet按照Hash算法来存储集合中的元素。存在以下特点：</p><ul><li>不能保证元素的顺序，元素是无序的</li><li>HashSet不是同步的，需要外部保持线程之间的同步问题</li><li>集合元素值允许为null<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">    java.util.AbstractCollection&lt;E&gt; </span><br><span class="line">        java.util.AbstractSet&lt;E&gt; </span><br><span class="line">            java.util.HashSet&lt;E&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="继承关系，实现接口"><a href="#继承关系，实现接口" class="headerlink" title="继承关系，实现接口"></a>继承关系，实现接口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serializable, Cloneable, Iterable&lt;E&gt;, Collection&lt;E&gt;, Set&lt;E&gt;</span><br></pre></td></tr></table></figure><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private transient HashMap&lt;E,Object&gt; map;  //map集合，HashSet存放元素的容器</span><br><span class="line">private static final Object PRESENT = new Object(); //map，中键对应的value值</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//无参构造方法，完成map的创建</span><br><span class="line">public <span class="function"><span class="title">HashSet</span></span>() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">//指定集合转化为HashSet, 完成map的创建</span><br><span class="line">public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line">//指定初始化大小，和负载因子</span><br><span class="line">public HashSet(int initialCapacity, <span class="built_in">float</span> loadFactor) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line">//指定初始化大小</span><br><span class="line">public HashSet(int initialCapacity) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">//指定初始化大小和负载因子，dummy 无实际意义</span><br><span class="line">HashSet(int initialCapacity, <span class="built_in">float</span> loadFactor, boolean dummy) &#123;</span><br><span class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造函数，不难发现，<strong>HashSet的底层是采用HashMap实现的。</strong></p><h2 id="add-方法"><a href="#add-方法" class="headerlink" title="add()方法"></a>add()方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    <span class="built_in">return</span> map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PRESENT为HashSet类中定义的一个常量，并无实际的意义，HashSet的add()方法调用HashMap的put()方法实现，如果键已经存在，HashMap.put()放回的是旧值，添加失败；如果添加成功，map.put()方法返回的值为null ，HashSet.add()方法返回true。</li><li><p>要添加的元素为map中的key 。</p><h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    <span class="built_in">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除方法，调用map.remove()方法实现，若map.remove()能找到指定的key,则返回key对应的value。</p></li><li>对于Hashset而言，它所有的key对应的值都是PRESENT。<h1 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">    extends AbstractSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    static final long serialVersionUID = -5024744406713321676L; //序列化版本号</span><br><span class="line"></span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;  //HashMap变量，用于存放HashSet的值</span><br><span class="line"></span><br><span class="line">    private static final Object PRESENT = new Object(); //map中的值</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public <span class="function"><span class="title">HashSet</span></span>() &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造方法，将指定的集合转化为HashSet</span><br><span class="line">    public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造方法，指定初始化的大小和负载因子</span><br><span class="line">    public HashSet(int initialCapacity, <span class="built_in">float</span> loadFactor) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    //指定初始化大小</span><br><span class="line">    public HashSet(int initialCapacity) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造方法，采用default修饰，只能是同一个包下的成员访问。包不相同无法访问</span><br><span class="line">    HashSet(int initialCapacity, <span class="built_in">float</span> loadFactor, boolean dummy) &#123;</span><br><span class="line">        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //HashSet的遍历操作</span><br><span class="line">    //通过这个方法可以发现，HashSet调用了HashMap存放，因为HashSet并不是键值对存储，所以它只是把它的值做了Map中的键，在遍历HashSet的集合元素时，实际上是遍历的Map中Key的集合。</span><br><span class="line">    public Iterator&lt;E&gt; <span class="function"><span class="title">iterator</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回集合中元素的容量</span><br><span class="line">    public int <span class="function"><span class="title">size</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是否为空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否包含指定的元素</span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        <span class="built_in">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加元素，添加的元素作为了Map中的key,value使用了一个常量表示</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        <span class="built_in">return</span> map.put(e, PRESENT)==null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除元素</span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        <span class="built_in">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清空集合</span><br><span class="line">    public void <span class="function"><span class="title">clear</span></span>() &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //克隆方法</span><br><span class="line">    public Object <span class="function"><span class="title">clone</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();</span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">            <span class="built_in">return</span> newSet;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写入输出流操作。</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws java.io.IOException &#123;</span><br><span class="line">        // Write out any hidden serialization magic</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        // Write out HashMap capacity and load factor</span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        // Write out size</span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        // Write out all elements <span class="keyword">in</span> the proper order.</span><br><span class="line">        <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //从输入流中读取对象</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        // Read <span class="keyword">in</span> any hidden serialization magic</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        // Read <span class="keyword">in</span> HashMap capacity and load factor and create backing HashMap</span><br><span class="line">        int capacity = s.readInt();</span><br><span class="line">        <span class="built_in">float</span> loadFactor = s.readFloat();</span><br><span class="line">        map = (((HashSet)this) instanceof LinkedHashSet ?</span><br><span class="line">               new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               new HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">        // Read <span class="keyword">in</span> size</span><br><span class="line">        int size = s.readInt();</span><br><span class="line"></span><br><span class="line">        // Read <span class="keyword">in</span> all elements <span class="keyword">in</span> the proper order.</span><br><span class="line">        <span class="keyword">for</span> (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            E e = (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>静下心来仔细研究了一下，发现hashset是通过将相应的内容存储在了一个hashmap里的key中，然后再去读取的。<br>为了保证hashset里面的数据唯一性，这里将hashset存放的元素作为了hashmap里面唯一的key变量，value部分用一个PRESENT对象来存储，也就是源码里面的这一句内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Object PRESENT = new Object();</span><br></pre></td></tr></table></figure></li><li><p>HashSet的底层通过HashMap实现的，而HashMap在1.7之前使用的是数组+链表实现，在1.8+使用的数组+链表+红黑树实现。其实也可以这样理解，HashSet的底层实现和HashMap使用的是相同的方式，因为Map是无序的，因此HashSet也无法保证顺序。HashSet的方法也是借助HashMap的方法来实现的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      HashSet是Set接口的典型实现，HashSet按照Hash算法来存储集合中的元素，底层通过HashMap实现。
    
    </summary>
    
      <category term="JAVA集合" scheme="http://yoursite.com/categories/JAVA%E9%9B%86%E5%90%88/"/>
    
    
      <category term="HashSet" scheme="http://yoursite.com/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>Java8的集合1：ArrayList的实现原理</title>
    <link href="http://yoursite.com/2019/04/28/Java8%E7%9A%84%E9%9B%86%E5%90%881%EF%BC%9AArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/28/Java8的集合1：ArrayList的实现原理/</id>
    <published>2019-04-28T04:58:36.000Z</published>
    <updated>2019-04-28T05:01:08.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p>一上来，先来看看源码中的这一段注释，我们可以从中提取到一些关键信息：<br>Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)<br>从这段注释中，我们可以得知ArrayList是一个动态数组，实现了List接口以及list相关的所有方法，它允许所有元素的插入，包括null。另外，ArrayList和Vector除了线程不同步之外，大致相等。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//默认容量的大小</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">//空数组常量</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//默认的空数组常量</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//存放元素的数组，从这可以发现ArrayList的底层实现就是一个Object数组</span><br><span class="line">transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">//数组中包含的元素个数</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">//数组的最大上限</span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br></pre></td></tr></table></figure><p>ArrayList的属性非常少，就只有这些。其中最重要的莫过于<strong>elementData</strong>了，ArrayList所有的方法都是建立在elementData之上。接下来，我们就来看一下一些主要的方法。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        throw new IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="function"><span class="title">ArrayList</span></span>() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中我们可以看见，<strong>默认情况下，elementData是一个大小为0的空数组</strong>，当我们指定了初始大小的时候，elementData的初始大小就变成了我们所指定的初始大小了。</p><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="built_in">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line">private void rangeCheck(int index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    <span class="built_in">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为ArrayList是采用<strong>数组结构</strong>来存储的，所以它的get方法非常简单，先是<strong>判断一下有没有越界</strong>，之后就可以直接通过数组下标来获取元素了，所以get的时间复杂度是<strong>O(1)</strong></p><h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1); // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + 1); // Increments modCount!!</span><br><span class="line">    //调用一个native的复制方法，把index位置开始的元素都往后挪一位</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; 0)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList的add方法也很好理解，在插入元素之前，它会先检查是否需要扩容，然后再把元素添加到数组中最后一个元素的后面。在ensureCapacityInternal方法中，我们可以看见，如果当elementData为空数组时，它会使用默认的大小去扩容。所以说，通过无参构造方法来创建ArrayList时，它的大小其实是为0的，只有在使用到的时候，才会通过<strong>grow方法去创建一个大小为10的数组</strong>。</p><p><strong>第一个add方法的复杂度为O(1)</strong>，虽然有时候会涉及到扩容的操作，但是扩容的次数是非常少的，所以这一部分的时间可以忽略不计。如果<strong>使用的是带指定下标的add方法，则复杂度为O(n)</strong>，因为涉及到对数组中元素的移动，这一操作是非常耗时的。</p><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E <span class="built_in">set</span>(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="built_in">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set方法的作用是把下标为index的元素替换成element，跟get非常类似，所以就不在赘述了，时间复杂度度为O(1)。</p><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; 0)</span><br><span class="line">    System.arraycopy(elementData, index+1, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to <span class="built_in">let</span> GC <span class="keyword">do</span> its work</span><br><span class="line">    <span class="built_in">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove方法与add带指定下标的方法非常类似，也是调用系统的arraycopy方法来移动元素，时间复杂度为O(n)。</p><h2 id="grow方法"><a href="#grow方法" class="headerlink" title="grow方法"></a>grow方法</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; 0)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grow方法是在数组进行扩容的时候用到的，从中我们可以看见，<strong>ArrayList每次扩容都是扩1.5倍</strong>，然后<strong>调用Arrays类的copyOf方法，把元素重新拷贝到一个新的数组中去</strong>。</p><h2 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int <span class="function"><span class="title">size</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size方法非常简单，它是直接返回size的值，也就是返回数组中元素的个数，时间复杂度为O(1)。这里要注意一下，返回的并不是数组的实际大小。</p><h2 id="indexOf方法和lastIndexOf"><a href="#indexOf方法和lastIndexOf" class="headerlink" title="indexOf方法和lastIndexOf"></a>indexOf方法和lastIndexOf</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == null) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; size; i++)</span><br><span class="line">        <span class="keyword">if</span> (elementData[i]==null)</span><br><span class="line">        <span class="built_in">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="built_in">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == null) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==null)</span><br><span class="line">                <span class="built_in">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                        <span class="built_in">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexOf方法的作用是返回第一个等于给定元素的值的下标。它是通过遍历比较数组中每个元素的值来查找的，所以它的时间复杂度是O(n)。 lastIndexOf的原理跟indexOf一样，而它仅仅是从后往前找起罢了。</p><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>Vector的很多方法都跟ArrayList一样，只是多加了个synchronized来保证线程安全。所以只把Vector与ArrayList的不同点提一下就可以了。</p><ol><li>Vector比ArrayList多了一个属性：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected int capacityIncrement;</span><br></pre></td></tr></table></figure></li></ol><p>这个属性是在扩容的时候用到的，它表示每次扩容只扩capacityIncrement个空间就足够了。该属性可以通过构造方法给它赋值。先来看一下构造方法：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Vector(int initialCapacity, int capacityIncrement) &#123;</span><br><span class="line">    super();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+initialCapacity);</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">        this.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line">public Vector(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, 0);</span><br><span class="line">&#125;</span><br><span class="line">public <span class="function"><span class="title">Vector</span></span>() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从构造方法中，我们可以看出Vector的默认大小也是10，而且它在初始化的时候就已经创建了数组了，这点跟ArrayList不一样。</p><ol start="2"><li>再来看一下grow方法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从grow方法中我们可以发现，newCapacity默认情况下是两倍的oldCapacity，而当指定了capacityIncrement的值之后，newCapacity变成了oldCapacity+capacityIncrement。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>ArrayList创建时的大小为0；当加入第一个元素时，进行第一次扩容时，默认容量大小为10。</li><li><strong>ArrayList每次扩容都以当前数组大小的1.5倍去扩容。</strong></li><li>Vector创建时的默认大小为10。</li><li><strong>Vector每次扩容都以当前数组大小的2倍去扩容。当指定了capacityIncrement之后，每次扩容仅在原先基础上增加capacityIncrement个单位空间。</strong></li><li>ArrayList和Vector的add、get、size方法的复杂度都为O(1)，remove方法的复杂度为O(n)。</li><li><font color="#DC143C"><strong>ArrayList是非线程安全的，Vector是线程安全的。</strong></font> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述：&quot;&gt;&lt;a href=&quot;#概述：&quot; class=&quot;headerlink&quot; title=&quot;概述：&quot;&gt;&lt;/a&gt;概述：&lt;/h1&gt;&lt;p&gt;一上来，先来看看源码中的这一段注释，我们可以从中提取到一些关键信息：&lt;br&gt;Resizable-array implementati
      
    
    </summary>
    
      <category term="JAVA集合" scheme="http://yoursite.com/categories/JAVA%E9%9B%86%E5%90%88/"/>
    
    
      <category term="ArrayList" scheme="http://yoursite.com/tags/ArrayList/"/>
    
      <category term="Vector" scheme="http://yoursite.com/tags/Vector/"/>
    
  </entry>
  
  <entry>
    <title>Java：CAS</title>
    <link href="http://yoursite.com/2019/04/26/Java%EF%BC%9ACAS/"/>
    <id>http://yoursite.com/2019/04/26/Java：CAS/</id>
    <published>2019-04-26T12:46:06.000Z</published>
    <updated>2019-04-26T12:49:44.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h1><hr><p>什么是悲观锁、乐观锁？在java语言里，总有一些名词看语义跟本不明白是啥玩意儿，也就总有部分面试官拿着这样的词来忽悠面试者，以此来找优越感，其实理解清楚了，这些词也就唬不住人了。</p><ul><li>synchronized 是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。</li><li>CAS 操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</li><li>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1></li></ul><hr><ul><li>在进入正题之前，我们先理解下下面的代码:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static int count = 0;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       <span class="keyword">for</span> (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">           new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       Thread.sleep(10);</span><br><span class="line">                   &#125; catch (Exception e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">                   //每个线程让count自增100次</span><br><span class="line">                   <span class="keyword">for</span> (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                       count++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">       try&#123;</span><br><span class="line">           Thread.sleep(2000);</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>请问cout的输出值是否为200？答案是否定的，因为这个程序是线程不安全的，所以造成的结果count值可能小于200。</p><p>那么如何改造成线程安全的呢，其实我们可以使用上Synchronized同步锁,我们只需要在count++的位置添加同步锁，代码如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static int count = 0;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //每个线程让count自增100次</span><br><span class="line">                    <span class="keyword">for</span> (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                        synchronized (ThreadCas.class)&#123;</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>加了同步锁之后，count自增的操作变成了原子性操作，所以最终的输出一定是count=200，代码实现了线程安全。</p><p>但是Synchronized虽然确保了线程的安全，但是在性能上却不是最优的，Synchronized关键字会让没有得到锁资源的线程进入<font color="#DC143C">BLOCKED</font>状态，而后在争夺到锁资源后恢复为<font color="#DC143C">RUNNABLE</font>状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。</p><p>因此，在JAVA中改用原子类操作加以改进。所谓原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如AtomicBoolean，AtomicInteger，AtomicLong。它们分别用于Boolean，Integer，Long类型的原子性操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">        new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(10);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                //每个线程让count自增100次</span><br><span class="line">                <span class="keyword">for</span> (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用AtomicInteger之后，最终的输出结果同样可以保证是200。并且在某些情况下，代码的性能会比Synchronized更好。而Atomic操作的底层实现正是利用的CAS机制。</p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><hr><ul><li>想要理解CAS，首先先要了解下JMM。</li><li>JMM：Java内存模型，是一种抽象的概念，可以理解为一组规范。</li><li>JMM的特性：可见性，原子性，有序性。</li><li>JMM关于同步的规定：</li></ul><ol><li>线程解锁前必须将共享变量的值刷新回主内存。</li><li>线程加锁前必须读主内存的最新值到自己的工作内存中。</li><li>加锁解锁是同一把锁。</li><li>线程间的通信（传值）必须通过主内存。</li></ol><h1 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h1><hr><ul><li>在计算机科学中，<strong>比较并交换</strong>（Conmpare And Swap）是用于实现多线程同步的<strong>原子指令</strong>。 它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果该值在同一时间被另一个线程更新，则写入将失败。 操作结果必须说明是否进行替换; 这可以通过一个简单的布尔响应（这个变体通常称为比较和设置），或通过返回从内存位置读取的值来完成（摘自维基本科）。</li><li>CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</li></ul><p>使用 compareAndSet方法将内存中的值<strong>5</strong>进行修改，第一次修改成功，内存中的值被改为<strong>2019</strong>，第二次进行比较时，由于内存中的值已经被修改，所以操作失败。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(5);</span><br><span class="line">        //main <span class="keyword">do</span> something</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(5,2019)+<span class="string">"\t current data: "</span>+atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(5,1024)+<span class="string">"\t current data: "</span>+atomicInteger.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h1><hr><ol><li>CPU开销较大：<br>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li><li>不能保证代码块的原子性<br>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。<ol start="3"><li>可能会出现ABA问题。</li></ol></li></ol><h1 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h1><hr><ul><li>什么是ABA问题？<br>简单来说一句话：狸猫换太子。<br>举个例子：如线程1从内存X中取出A，这时候另一个线程2也从内存X中取出A，并且线程2进行了一些操作将内存X中的值变成了B，然后线程2又将内存X中的数据变成A，这时候线程1进行CAS操作发现内存X中仍然是A，然后线程1操作成功。虽然线程1的CAS操作成功，但是整个过程就是有问题的。比如链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。</li><li>如何解决：<br>JAVA中提供了<strong>AtomicStampedReference</strong>来处理会发生ABA问题的场景，主要是在对象中额外再增加一个标记来标识对象是否有过变更（类似于GitHub的版本号）。</li></ul><p>测试代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static AtomicReference&lt;Integer&gt; atomicReference = new AtomicReference&lt;&gt;(100);</span><br><span class="line">static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(100,1);</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(<span class="string">"=============以下是ABA问题的产生============="</span>);</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        atomicReference.compareAndSet(100,101);</span><br><span class="line">        atomicReference.compareAndSet(101,100);</span><br><span class="line">    &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //暂停1S线程2，保证线程1完成ABA操作</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(100,2019)+<span class="string">"\t"</span>+atomicReference.get());</span><br><span class="line">    &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"=============以下是ABA问题的解决============="</span>);</span><br><span class="line"></span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        int stamp = atomicStampedReference.getStamp();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t第一次版本号： "</span>+stamp);</span><br><span class="line">        try &#123;</span><br><span class="line">            //暂停1S线程3</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicStampedReference.compareAndSet(100,101,</span><br><span class="line">                atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1));</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t第二次版本号： "</span>+atomicStampedReference.getStamp());</span><br><span class="line">        System.out.println(atomicStampedReference.compareAndSet(101,100,</span><br><span class="line">                atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1));</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t第三次版本号： "</span>+atomicStampedReference.getStamp());</span><br><span class="line">    &#125;,<span class="string">"t3"</span>).start();</span><br><span class="line"></span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        int stamp = atomicStampedReference.getStamp();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t第一次版本号： "</span>+stamp);</span><br><span class="line">        try &#123;</span><br><span class="line">            //暂停3S线程4，保证线程3完成ABA操作</span><br><span class="line">            TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        boolean result =  atomicStampedReference.compareAndSet(100,2019,stamp,stamp+1);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t修改成功否： "</span>+result+<span class="string">"\t 当前最新实际版本号： "</span>+atomicStampedReference.getStamp());</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t当前实际最新值： "</span>+atomicStampedReference.getReference());</span><br><span class="line">    &#125;,<span class="string">"t4"</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">=============以下是ABA问题的产生=============</span><br><span class="line">true    2019</span><br><span class="line">=============以下是ABA问题的解决=============</span><br><span class="line">t3  第一次版本号： 1</span><br><span class="line">t4  第一次版本号： 1</span><br><span class="line">true</span><br><span class="line">t3  第二次版本号： 2</span><br><span class="line">true</span><br><span class="line">t3  第三次版本号： 3</span><br><span class="line">t4  修改成功否： false     当前最新实际版本号： 3</span><br><span class="line">t4  当前实际最新值： 100</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      本文讲解CAS机制，主要是因为最近准备面试题，发现这个问题在面试中出现的频率非常的高，因此把自己学习过程中的一些理解记录下来，希望能对大家也有帮助。
    
    </summary>
    
      <category term="JAVA_CAS" scheme="http://yoursite.com/categories/JAVA-CAS/"/>
    
    
      <category term="JAVA_CAS" scheme="http://yoursite.com/tags/JAVA-CAS/"/>
    
      <category term="ABA问题" scheme="http://yoursite.com/tags/ABA%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Github+Hexo搭建个人博客</title>
    <link href="http://yoursite.com/2019/04/25/Github-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/04/25/Github-Hexo搭建个人博客/</id>
    <published>2019-04-25T14:45:23.000Z</published>
    <updated>2019-04-25T14:59:51.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><ol><li>安装 Node</li><li>安装 Git</li><li>注册 GitHub</li><li>安装 Hexo</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h1 id="搭建本地个人博客"><a href="#搭建本地个人博客" class="headerlink" title="搭建本地个人博客"></a>搭建本地个人博客</h1><hr><h2 id="初始化-hexo"><a href="#初始化-hexo" class="headerlink" title="初始化 hexo"></a>初始化 hexo</h2><ul><li><p>新建一个空白文件夹（下文提到的“项目根目录”是指你新建的文件夹的位置）用于存放 hexo 资源。在空白文件夹里面打开 Git Bash ，输入下列命令行进行初始化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo init</span><br></pre></td></tr></table></figure><h2 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo g</span><br></pre></td></tr></table></figure><h2 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo s</span><br></pre></td></tr></table></figure></li><li><p>关闭本地服务器在 Git Bash 界面按 Ctrl+C， 在浏览器输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 查看<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2f6zotc21j30m80fhqa3.jpg"></p><h1 id="美化个人博客"><a href="#美化个人博客" class="headerlink" title="美化个人博客"></a>美化个人博客</h1></li></ul><hr><h2 id="博客主题设置"><a href="#博客主题设置" class="headerlink" title="博客主题设置"></a>博客主题设置</h2><h3 id="克隆主题"><a href="#克隆主题" class="headerlink" title="克隆主题"></a>克隆主题</h3><ul><li>在项目根目录下的 <strong>themes</strong> 文件中，打开 <strong>Git Bash</strong> ，用命令行克隆下新的主题。我这里用的 <strong>Next</strong> 主题，需要其他主题的自己百度找。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next.git</span><br></pre></td></tr></table></figure><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><ul><li>用文本的方式打开项目根目录下的 <font color="#DC143C">_config.yml</font> 配置文件，找到 <strong>theme</strong> 把原来默认的 <strong><del>landscape</del> </strong> 主题名字，改成刚刚克隆的主题名字。</li></ul><h3 id="测试主题"><a href="#测试主题" class="headerlink" title="测试主题"></a>测试主题</h3><ul><li><p>重新回到项目根目录下，打开 Git Bath ，用命令行启动服务器。在浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2f72ii44vj30m80cg41j.jpg" alt=""></p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3></li><li><p><strong>方法一：</strong>在项目根目录下，打开 <strong>Git Bash</strong> ，执行新建命令，然后 hexo 会自动在指定目录下生成对应文件，如下图所示。然后找到新建好的文件，打开即可进行编辑。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo new <span class="string">"此处输入文章名字"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法二：</strong>可以直接把已经准备的 md 格式的文章复制到 项目名称  <font color="#DC143C">/source/_posts</font> 目录下，然后打开文件，在文件头加入 front-matter 部分，title 表示文章标题，date 表示发布时间。如图所示，图片上用到的其他参数，后面会介绍到。</p></li><li><font color="#DC143C"><strong>重要的事情说三遍！！！</strong></font></li><li>front-matte 书写的时候要注意，冒号后面要跟一个空格号</li><li>front-matte 书写的时候要注意，冒号后面要跟一个空格号</li><li><p>front-matte 书写的时候要注意，冒号后面要跟一个空格号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 ---</span><br><span class="line">2 title: a</span><br><span class="line">3 date: 2019-04-25 21:27:13</span><br><span class="line">4 ---</span><br></pre></td></tr></table></figure></li><li><p>准备好 md 格式文件后，使用下面命令生成网站静态文件到默认设置的 public 文件夹，然后再启动本地服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo g</span><br></pre></td></tr></table></figure></li></ul><h2 id="主题风格设置"><a href="#主题风格设置" class="headerlink" title="主题风格设置"></a>主题风格设置</h2><ul><li>打开主题文件夹下的  <font color="#DC143C">_config.yml</font> 配置文件（注意：这里要区别，不是項目根目录，主题文件夹的路径为：<font color="#DC143C">新建空白文件夹名称/themes/主题文件夹名称</font>）。通过查找功能找到 Schemes 模块，修改为 Gemini 风格。如果喜欢其他风格可以自己修改。</li><li>刷新页面可以看到新风格的界面如下图所示:<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2f7f8og8pj30m80avtc0.jpg" alt=""><h2 id="博客左侧栏设置"><a href="#博客左侧栏设置" class="headerlink" title="博客左侧栏设置"></a>博客左侧栏设置</h2></li><li>在上面的网站界面，可以发现网站的文字是英文，只要修改一下语言模式即可。打开根目录文件夹下的  <font color="#DC143C">_config.yml</font>配置文件。找到 language，设置为 <strong>zh-CN</strong>。标题等其他参数的设置如下。可以对照效果图的具体位置，根据自己的实际需求进行修改。（注意：修改了项目根目录下的  <font color="#DC143C">_config.yml</font>配置文件，需要重启部署项目后才能生效）<h2 id="分类设置"><a href="#分类设置" class="headerlink" title="分类设置"></a>分类设置</h2><h3 id="添加分类列表"><a href="#添加分类列表" class="headerlink" title="添加分类列表"></a>添加分类列表</h3></li><li><p>在项目根目录下，执行下面的命令行，新建分类页面，然后会在项目根目录下的 <strong>source</strong> 文件夹中新建一个 <strong>categories</strong> 文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo new page categories</span><br></pre></td></tr></table></figure></li><li><p>打开 <strong>categories</strong> 文件夹中的 <strong>index.md</strong> 文件，添加 type 字段，设置为 “<strong>categories</strong>”。如下图所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 ---</span><br><span class="line">2 title: categories</span><br><span class="line">3 date: 2019-04-25 22:17:14</span><br><span class="line">4 <span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">5 ---</span><br></pre></td></tr></table></figure></li><li><p>接着到主题文件夹下的<font color="#DC143C">_config.yml</font> 配置文件下，找到 <strong>menu</strong> 模块，把 <strong>categories</strong> 的注释给去掉。</p></li><li>刷新页面（如果刷新没效果，可以重启服务），可以在页面左侧栏上看到多了一个“分类”列表。<h3 id="如何将文章添加到对应分类？"><a href="#如何将文章添加到对应分类？" class="headerlink" title="如何将文章添加到对应分类？"></a>如何将文章添加到对应分类？</h3></li><li>文章发布前，在<font color="#DC143C"> front-matter</font> 部分，多写一个 <strong>categories</strong> 字段，然后参数写上类别的名称，保存后重启服务，在网页上点击“分类”，可以看到分类下已经生成了刚刚设置的类别，并把刚刚发布的文章归类在此类别下。如下图所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 ---</span><br><span class="line">2 title: <span class="string">"文章的标题"</span></span><br><span class="line">3 date: 2019-04-25 22:17:14</span><br><span class="line">4 categories: <span class="string">"文章的分类"</span></span><br><span class="line">5 ---</span><br></pre></td></tr></table></figure></li></ul><h2 id="标签设置"><a href="#标签设置" class="headerlink" title="标签设置"></a>标签设置</h2><ul><li>方法跟分类设置一样，所以不再赘述介绍</li><li>但是需要补充一点， <font color="#DC143C"> front-matter</font> 中字段有多个参数的时候，可以使用如下图的写法。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 ---</span><br><span class="line">2 title: <span class="string">"文章的标题"</span></span><br><span class="line">3 date: 2019-04-25 22:17:14</span><br><span class="line">4 categories: <span class="string">"文章的分类"</span></span><br><span class="line">5 tags: </span><br><span class="line">6   -<span class="string">"标签1"</span></span><br><span class="line">7   -<span class="string">"标签2"</span></span><br><span class="line">8   -<span class="string">"标签3"</span></span><br><span class="line">9 description: <span class="string">"描述"</span></span><br><span class="line">10 photos: </span><br><span class="line">11   -<span class="string">"链接"</span></span><br><span class="line">12 ---</span><br></pre></td></tr></table></figure></li></ul><h2 id="博客添加站内搜索"><a href="#博客添加站内搜索" class="headerlink" title="博客添加站内搜索"></a>博客添加站内搜索</h2><ul><li>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。下面介绍 <strong>Local Search</strong> 的安装吧。注意：安装的时候要是项目根目录下安装。</li><li><p>安装 hexo-generator-search</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></li><li><p>安装 hexo-generator-searchdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录下的 <font color="#DC143C">_config.yml </font>配置文件的文末添加下面这段代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 search:</span><br><span class="line">2   path: search.xml</span><br><span class="line">3   field: post</span><br><span class="line">4   format: html</span><br><span class="line">5   <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure></li><li><p>编辑主题文件夹的 <font color="#DC143C">_config.yml </font> 配置文件，设置<font color="#DC143C"> Local searchenable </font>为 <strong>ture</strong>。</p></li><li>重启服务<h2 id="博客头像设置"><a href="#博客头像设置" class="headerlink" title="博客头像设置"></a>博客头像设置</h2><h3 id="添加博客头像"><a href="#添加博客头像" class="headerlink" title="添加博客头像"></a>添加博客头像</h3></li><li>打开主题文件夹下的 <font color="#DC143C">_config.yml </font> 配置文件，通过查找功能找到 <strong>avatar</strong>，然后把一个在线的头像图片地址（百度图片中直接复制链接即可），作为 <strong>url</strong> 的参数。</li><li>然后刷新页面，可以看到网站上已经显示了相应的头像了。<h2 id="右上角-fork-me-设置"><a href="#右上角-fork-me-设置" class="headerlink" title="右上角 fork me 设置"></a>右上角 fork me 设置</h2></li><li>在 <a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners</a> 上选择你喜欢的挂饰，复制方框内的代码。</li><li>打开主题文件夹下的 <strong>layout</strong> 文件夹，用记事本的方式打开 <strong>_layout.swig</strong>，把刚刚复制的代码放到下面，并把 href 的参数，修改为自己的 github 链接（放自己要跳转的网址即可）。</li><li>重启服务器，查看效果<h2 id="网页背景设置"><a href="#网页背景设置" class="headerlink" title="网页背景设置"></a>网页背景设置</h2><h3 id="动态背景设置"><a href="#动态背景设置" class="headerlink" title="动态背景设置"></a>动态背景设置</h3></li><li>打开主题文件夹下的 <strong>layout</strong> 文件夹，用文本的方式打开 <strong>_layout.swig</strong> 文件，在文末加上如下的代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;!-- 动态背景 --&gt;</span><br><span class="line">2 &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="背景图片设置"><a href="#背景图片设置" class="headerlink" title="背景图片设置"></a>背景图片设置</h3><ul><li>打开主题文件夹下的 <strong>source</strong> 文件夹，进入 <strong>css/_custom</strong> 文件下，用文本形式打开 <strong>custom.styl</strong> 文件，然后添加下面这段代码。代码中 <strong>url</strong> 的地址是指到： <font color="#DC143C">主题文件夹/source/images/</font> 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 body&#123;</span><br><span class="line">2    background:url(/images/bg.jpg);</span><br><span class="line">3    background-size:cover;</span><br><span class="line">4    background-repeat:no-repeat;</span><br><span class="line">5    background-attachment:fixed;</span><br><span class="line">6    background-position:center;</span><br><span class="line">7    // 设置主题部分的透明度，具体看图</span><br><span class="line">8    opacity: 0.8;</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="首页文章预览设置"><a href="#首页文章预览设置" class="headerlink" title="首页文章预览设置"></a>首页文章预览设置</h2><ul><li>默认情况下，文章在首页是全文显示的，这样肯定是不方便读者浏览。所以需要实现预览模式。</li><li><strong>方法一：</strong>使用 <strong>&lt; !–more–&gt;</strong> 手动切断<br>这种方法可以根据文章的内容，自己在合适的位置添加 &lt; !–more–&gt; 标签，使用灵活，也是Hexo推荐的方法。</li><li><strong>方法二：</strong>添加 <strong>description</strong><br>在文章的<font color="#DC143C"> front-matter </font>中添加 <strong>description</strong> 和 <strong>photos</strong> 字段，如3.5图所示。如果不需要显示图片的话，可以把 photos 去掉。<br>ps：不知道 <font color="#DC143C"> front-matter </font> 是什么的话，跳转到第二章的第4点的发布文章看下。</li><li><strong>方法三</strong>：自动形成摘要<br>在主题文件下的<font color="#DC143C">_config.yml </font> 配置文件中添加默认截取的长度为 150 字符，可以根据需要自行设定。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 auto_excerpt:</span><br><span class="line">2   <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">3   length: 150</span><br></pre></td></tr></table></figure></li></ul><h2 id="RSS-设置"><a href="#RSS-设置" class="headerlink" title="RSS 设置"></a>RSS 设置</h2><ul><li><p>安装 hexo 插件，需要在 hexo 项目根目录下进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure></li><li><p>安装完成后在项目根目录下的 <font color="#DC143C">_config.yml </font> 配置文件的文末添加下面这段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 <span class="comment"># Extentions</span></span><br><span class="line">2 <span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line">3 plugins: hexo-generator-feed</span><br></pre></td></tr></table></figure></li><li><p>在主题文件夹下的 <font color="#DC143C">_config.yml </font>  配置文件中，找到 <strong>rss</strong> ，在后面加上 <strong>/atom.xml</strong>。</p></li><li>重启服务，刷新页面<h2 id="社交小图标设置"><a href="#社交小图标设置" class="headerlink" title="社交小图标设置"></a>社交小图标设置</h2></li><li>在主题文件夹下的<font color="#DC143C">_config.yml </font>配置文件中，搜索 <strong>Social</strong>，然后提示自己增加自己需要的小图标并设置对应连接。</li><li>图标可以到 <a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">Font Awesome Icon</a> 网站查找。<h2 id="友情链接设置"><a href="#友情链接设置" class="headerlink" title="友情链接设置"></a>友情链接设置</h2></li><li>在主题文件夹下的 <font color="#DC143C">_config.yml </font>配置文件中，搜索 links_title，然后根据自己的需求自己吸修改。<h2 id="博客置顶设置"><a href="#博客置顶设置" class="headerlink" title="博客置顶设置"></a>博客置顶设置</h2></li><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 npm uninstall hexo-generator-index --save</span><br><span class="line">2 npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure></li><li><p>然后在需要置顶的文章的 <strong>Front-matter</strong> 中加上 <strong>top</strong> 即可，数值越大表示等级越高，越靠前显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 ---</span><br><span class="line">2 title: <span class="string">"文章的标题"</span></span><br><span class="line">3 date: 2019-04-25 22:17:14</span><br><span class="line">4 top: 100</span><br><span class="line">5 ---</span><br></pre></td></tr></table></figure></li><li><p>在主题文件夹中打开<font color="#DC143C"> layout/_macro/post.swig</font> 文件，定位到 <strong>post-header</strong> ，把下面的代码添加进去即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &#123;% <span class="keyword">if</span> post.top %&#125;</span><br><span class="line">2  &lt;i class=<span class="string">"fa fa-thumb-tack"</span>&gt;&lt;/i&gt;</span><br><span class="line">3   &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">4 &#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="对接Github的远程仓库"><a href="#对接Github的远程仓库" class="headerlink" title="对接Github的远程仓库"></a>对接Github的远程仓库</h1><hr><ul><li>在Github创建一个公有仓库，并把公有仓库的链接保存下来。<br>注意：仓库名字必须是：username.github.io，其中username是你的用户名。</li><li>打开项目根目录下的 <font color="#DC143C">_config.yml </font> 配置文件，修改 <strong>deploy</strong> 的值。<strong>tpye</strong> 设置为 <strong>git</strong>，<strong>repo</strong> 则设置为刚刚新建的远程仓库链接。</li><li><font color="#DC143C">注意：冒号后面需要再加一个空格，不然会出现格式错误。</font> </li><li><p>安装hexo-deployer-gi</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>一键部署到远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 hexo g</span><br><span class="line">2 hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>回到刚刚新建的远程仓库，刷新页面，可以发现本地博客的相关文件已经全部部署到远程仓库上了。</p><h1 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h1></li></ul><hr><ul><li><p>常见命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure></li><li><p>缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>组合命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="本文参考链接"><a href="#本文参考链接" class="headerlink" title="本文参考链接"></a>本文参考链接</h1><hr><p><a href="https://www.jianshu.com/p/13f5e4d7099d" target="_blank" rel="noopener">https://www.jianshu.com/p/13f5e4d7099d</a></p><p><a href="http://theme-next.iissnan.com/theme-settings.html#rss" target="_blank" rel="noopener">http://theme-next.iissnan.com/theme-settings.html#rss</a></p><p><a href="https://www.jianshu.com/p/9f0e90cc32c2" target="_blank" rel="noopener">https://www.jianshu.com/p/9f0e90cc32c2</a></p><p><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">https://www.simon96.online/2018/10/12/hexo-tutorial/</a></p><p><a href="http://zwd596257180.gitee.io/blog/2019/04/15/hexo_manong_bog/" target="_blank" rel="noopener">http://zwd596257180.gitee.io/blog/2019/04/15/hexo_manong_bog/</a></p><p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p>]]></content>
    
    <summary type="html">
    
      如果你也想要跟我一样自己撘一个个人博客系统，但又不知道怎么做，那么恭喜你！看完这篇文章，你也可以像我一样搭建一个属于自己的博客了！Come on！
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="博客搭建" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/10/10/hello-world/"/>
    <id>http://yoursite.com/2018/10/10/hello-world/</id>
    <published>2018-10-10T03:09:27.515Z</published>
    <updated>2019-04-25T14:46:02.454Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
