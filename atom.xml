<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeorgeN的博客</title>
  
  <subtitle>宁静致远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-22T11:09:59.610Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>npw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>消息中间件（二）MQ使用场景</title>
    <link href="http://yoursite.com/2019/05/22/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89MQ%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2019/05/22/消息中间件（二）MQ使用场景/</id>
    <published>2019-05-22T11:05:55.000Z</published>
    <updated>2019-05-22T11:09:59.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、消息队列概述"><a href="#一、消息队列概述" class="headerlink" title="一、消息队列概述"></a>一、消息队列概述</h2><p>消息队列中间件是分布式系统中重要的组件，主要解决<strong>应用解耦</strong>，<strong>异步消息</strong>，<strong>流量削锋</strong>等问题，实现高性能，高可用，可伸缩和最终一致性架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ</p><h2 id="二、消息队列应用场景"><a href="#二、消息队列应用场景" class="headerlink" title="二、消息队列应用场景"></a>二、消息队列应用场景</h2><p>以下介绍消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋，日志处理和消息通讯五个场景。</p><h3 id="2-1异步处理"><a href="#2-1异步处理" class="headerlink" title="2.1异步处理"></a>2.1异步处理</h3><p>场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式</p><p>a、串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a4yfuhc7j30ef03o3yf.jpg" alt=""><br>b、并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a4zgpr1ej30b305wq2x.jpg" alt=""><br>假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。<br>因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）</p><p>小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？</p><p>答案：引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a50rebq1j30fu059mx7.jpg" alt=""><br>按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了两倍。</p><h3 id="2-2应用解耦"><a href="#2-2应用解耦" class="headerlink" title="2.2应用解耦"></a>2.2应用解耦</h3><p>场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a52tmjlcj307y031a9w.jpg" alt=""><br>传统模式的缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合。</p><p>如何解决以上问题呢？引入应用消息队列后的方案，如下图：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a53olzr4j309m04za9y.jpg" alt=""><br><strong>订单系统</strong>：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功</p><p><strong>库存系统</strong>：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作<br>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦</p><h3 id="2-3流量削锋"><a href="#2-3流量削锋" class="headerlink" title="2.3流量削锋"></a>2.3流量削锋</h3><p>流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。</p><p><strong>应用场景</strong>：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。 既可以<strong>控制活动的人数</strong>，又可以<strong>缓解短时间内高流量压垮应用</strong>。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a56diqs2j30c4035glj.jpg" alt=""><br>用户的请求，服务器接收后，首先写入消息队列。<strong>假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面</strong>。</p><p>秒杀业务根据消息队列中的请求信息，再做后续处理。</p><h3 id="2-4日志处理"><a href="#2-4日志处理" class="headerlink" title="2.4日志处理"></a>2.4日志处理</h3><p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a57pr1l3j30co031dfq.jpg" alt=""><br>日志采集客户端，负责日志数据采集，定时写受写入Kafka队列</p><p>Kafka消息队列，负责日志数据的接收，存储和转发</p><p>日志处理应用：订阅并消费kafka队列中的日志数据 </p><h3 id="2-5消息通讯"><a href="#2-5消息通讯" class="headerlink" title="2.5消息通讯"></a>2.5消息通讯</h3><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</p><p>点对点通讯：客户端A和客户端B使用同一队列，进行消息通讯。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a59zqqpnj30ba0310sl.jpg" alt=""><br>聊天室通讯：客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a5aii01qj30ba039mx1.jpg" alt=""><br>以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。</p><h2 id="三、消息中间件示例"><a href="#三、消息中间件示例" class="headerlink" title="三、消息中间件示例"></a>三、消息中间件示例</h2><h3 id="3-1电商系统"><a href="#3-1电商系统" class="headerlink" title="3.1电商系统"></a>3.1电商系统</h3><p><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a5c0646cj30b704sta2.jpg" alt=""><br>消息队列采用高可用，可持久化的消息中间件。比如Active MQ，Rabbit MQ，Rocket Mq。</p><p>（1）应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性）<br>（2）扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。<br>（3）消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。</p><h3 id="3-2日志收集系统"><a href="#3-2日志收集系统" class="headerlink" title="3.2日志收集系统"></a>3.2日志收集系统</h3><p><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a5dr4nyij30f505kq52.jpg" alt=""><br>分为Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分组成。</p><ul><li>Zookeeper注册中心，提出负载均衡和地址查找服务</li><li>日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列</li><li>Kafka集群：接收，路由，存储，转发等消息处理</li><li>Storm集群：与OtherApp处于同一级别，采用拉的方式消费队列中的数据</li></ul>]]></content>
    
    <summary type="html">
    
      消息中间件MQ的几种常见使用场景
    
    </summary>
    
      <category term="MQ" scheme="http://yoursite.com/categories/MQ/"/>
    
    
      <category term="MQ" scheme="http://yoursite.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件（一）MQ详解及四大MQ比较</title>
    <link href="http://yoursite.com/2019/05/22/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89MQ%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%9B%9B%E5%A4%A7MQ%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2019/05/22/消息中间件（一）MQ详解及四大MQ比较/</id>
    <published>2019-05-22T11:05:33.000Z</published>
    <updated>2019-05-22T11:09:09.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、消息中间件相关知识"><a href="#一、消息中间件相关知识" class="headerlink" title="一、消息中间件相关知识"></a>一、消息中间件相关知识</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的<strong>ActiveMQ</strong>、<strong>RabbitMQ</strong>，炙手可热的<strong>Kafka</strong>，阿里巴巴自主开发RocketMQ等。</p><h3 id="2、消息中间件的组成"><a href="#2、消息中间件的组成" class="headerlink" title="2、消息中间件的组成"></a>2、消息中间件的组成</h3><h4 id="2-1-Broker"><a href="#2-1-Broker" class="headerlink" title="2.1 Broker"></a>2.1 Broker</h4><p>消息服务器，作为server提供消息核心服务</p><h4 id="2-2-Producer"><a href="#2-2-Producer" class="headerlink" title="2.2 Producer"></a>2.2 Producer</h4><p>消息生产者，业务的发起方，负责生产消息传输给broker，</p><h4 id="2-3-Consumer"><a href="#2-3-Consumer" class="headerlink" title="2.3 Consumer"></a>2.3 Consumer</h4><p>消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</p><h4 id="2-4-Topic"><a href="#2-4-Topic" class="headerlink" title="2.4 Topic"></a>2.4 Topic</h4><p>主题，<strong>发布订阅模式</strong>下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的<strong>广播</strong></p><h4 id="2-5-Queue"><a href="#2-5-Queue" class="headerlink" title="2.5 Queue"></a>2.5 Queue</h4><p>队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</p><h4 id="2-6-Message"><a href="#2-6-Message" class="headerlink" title="2.6 Message"></a>2.6 Message</h4><p>消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</p><h3 id="3、消息中间件模式分类"><a href="#3、消息中间件模式分类" class="headerlink" title="3、消息中间件模式分类"></a>3、消息中间件模式分类</h3><h4 id="3-1-点对点"><a href="#3-1-点对点" class="headerlink" title="3.1 点对点"></a>3.1 点对点</h4><p>PTP点对点：使用<strong>queue</strong>作为通信载体<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a44tfdaij30ps0fraev.jpg" alt=""><br>说明：<br>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。<br>消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p><h4 id="3-2-发布-订阅"><a href="#3-2-发布-订阅" class="headerlink" title="3.2 发布/订阅"></a>3.2 发布/订阅</h4><p>Pub/Sub发布订阅（广播）：使用<strong>topic</strong>作为通信载体<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a467j43dj30qa0gmtf8.jpg" alt=""><br>说明：<br>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。</p><p>queue与topic的不同之处：</p><ul><li><p>queue 实现了负载均衡，将producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者。 </p></li><li><p>topic 实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到一个消息的拷贝。</p></li></ul><h3 id="4、消息中间件的优势"><a href="#4、消息中间件的优势" class="headerlink" title="4、消息中间件的优势"></a>4、消息中间件的优势</h3><h4 id="4-1-系统解耦"><a href="#4-1-系统解耦" class="headerlink" title="4.1 系统解耦"></a>4.1 系统解耦</h4><p>交互系统之间没有直接的调用关系，只是通过消息传输，故系统侵入性不强，耦合度低。</p><h4 id="4-2-提高系统响应时间"><a href="#4-2-提高系统响应时间" class="headerlink" title="4.2 提高系统响应时间"></a>4.2 提高系统响应时间</h4><p>例如原来的一套逻辑，完成支付可能涉及先修改订单状态、计算会员积分、通知物流配送几个逻辑才能完成；通过MQ架构设计，就可将紧急重要（需要立刻响应）的业务放到该调用方法中，响应要求不高的使用消息队列，放到MQ队列中，供消费者处理。</p><h4 id="4-3-为大数据处理架构提供服务"><a href="#4-3-为大数据处理架构提供服务" class="headerlink" title="4.3 为大数据处理架构提供服务"></a>4.3 为大数据处理架构提供服务</h4><p>通过消息作为整合，大数据的背景下，消息队列还与实时处理架构整合，为数据处理提供性能支持。</p><h4 id="4-4-Java消息服务——JMS"><a href="#4-4-Java消息服务——JMS" class="headerlink" title="4.4 Java消息服务——JMS"></a>4.4 Java消息服务——JMS</h4><p>Java消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 </p><p>JMS中的P2P和Pub/Sub消息模式：点对点（point to point， queue）与发布订阅（publish/subscribe，topic）最初是由JMS定义的。这两种模式主要区别或解决的问题就是发送到队列的消息能否重复消费(多订阅)。</p><h3 id="5、消息中间件的应用场景"><a href="#5、消息中间件的应用场景" class="headerlink" title="5、消息中间件的应用场景"></a>5、消息中间件的应用场景</h3><h4 id="5-1-异步通信"><a href="#5-1-异步通信" class="headerlink" title="5.1 异步通信"></a>5.1 异步通信</h4><p>有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h4 id="5-2-解耦"><a href="#5-2-解耦" class="headerlink" title="5.2 解耦"></a>5.2 解耦</h4><p>降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><h4 id="5-3-冗余"><a href="#5-3-冗余" class="headerlink" title="5.3 冗余"></a>5.3 冗余</h4><p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p><h4 id="5-4-扩展性"><a href="#5-4-扩展性" class="headerlink" title="5.4 扩展性"></a>5.4 扩展性</h4><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容。</p><h4 id="5-5-过载保护"><a href="#5-5-过载保护" class="headerlink" title="5.5 过载保护"></a>5.5 过载保护</h4><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p><h4 id="5-6-可恢复性"><a href="#5-6-可恢复性" class="headerlink" title="5.6 可恢复性"></a>5.6 可恢复性</h4><p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p><h4 id="5-7-顺序保证"><a href="#5-7-顺序保证" class="headerlink" title="5.7 顺序保证"></a>5.7 顺序保证</h4><p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。</p><h4 id="5-8-缓冲"><a href="#5-8-缓冲" class="headerlink" title="5.8 缓冲"></a>5.8 缓冲</h4><p>在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。</p><h4 id="5-9-数据流处理"><a href="#5-9-数据流处理" class="headerlink" title="5.9 数据流处理"></a>5.9 数据流处理</h4><p>分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择。</p><h3 id="6、常见消息中间件MQ介绍"><a href="#6、常见消息中间件MQ介绍" class="headerlink" title="6、常见消息中间件MQ介绍"></a>6、常见消息中间件MQ介绍</h3><h4 id="6-1-RocketMQ"><a href="#6-1-RocketMQ" class="headerlink" title="6.1 RocketMQ"></a>6.1 RocketMQ</h4><p>阿里系下开源的一款分布式、队列模型的消息中间件，原名Metaq，3.0版本名称改为RocketMQ，是阿里参照kafka设计思想使用java实现的一套mq。同时将阿里系内部多款mq产品（Notify、metaq）进行整合，只维护核心功能，去除了所有其他运行时依赖，保证核心功能最简化，在此基础上配合阿里上述其他开源产品实现不同场景下mq的架构，目前主要<strong>多用于订单交易系统</strong>。</p><p>具有以下特点：</p><ul><li>能够保证严格的消息顺序</li><li>提供针对消息的过滤功能</li><li>提供丰富的消息拉取模式</li><li>高效的订阅者水平扩展能力</li><li>实时的消息订阅机制</li><li>亿级消息堆积能力</li></ul><p>官方提供了一些不同于kafka的对比差异：<br><a href="https://rocketmq.apache.org/docs/motivation/" target="_blank" rel="noopener">https://rocketmq.apache.org/docs/motivation/</a></p><h4 id="6-2-RabbitMQ"><a href="#6-2-RabbitMQ" class="headerlink" title="6.2 RabbitMQ"></a>6.2 RabbitMQ</h4><p>使用Erlang编写的一个开源的消息队列，本身支持很多的协议，也正是如此，使得它变的非常重量级。更适合于企业级的开发。同时实现了Broker架构，核心思想是<strong>生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队</strong>。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。</p><h4 id="6-3-ActiveMQ"><a href="#6-3-ActiveMQ" class="headerlink" title="6.3 ActiveMQ"></a>6.3 ActiveMQ</h4><p>Apache下的一个子项目。使用Java完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，少量代码就可以高效地实现高级应用场景。可插拔的传输协议支持，比如：in-VM, TCP, SSL, NIO, UDP, multicast, JGroups and JXTA transports。RabbitMQ、ZeroMQ、ActiveMQ均支持常用的多种语言客户端 C++、Java、.Net,、Python、 Php、 Ruby等。</p><h4 id="6-4-Redis"><a href="#6-4-Redis" class="headerlink" title="6.4 Redis"></a>6.4 Redis</h4><p>使用C语言开发的一个<strong>Key-Value的NoSQL数据库</strong>，开发维护很活跃，虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：<strong>入队时，当数据比较小时Redis的性能要高于RabbitMQ</strong>，而如果数据大小超过了10K，Redis则慢的无法忍受；<strong>出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</strong></p><h4 id="7-5-Kafka"><a href="#7-5-Kafka" class="headerlink" title="7.5 Kafka"></a>7.5 Kafka</h4><p>Apache下的一个子项目，使用scala实现的一个高性能分布式<strong>Publish/Subscribe消息队列系统</strong>，具有以下特性：</p><ul><li>快速持久化：通过磁盘顺序读写与零拷贝机制，可以在O(1)的系统开销下进行消息持久化；</li><li>高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；</li><li>高堆积：支持topic下消费者较长时间离线，消息堆积量大；</li><li>完全的分布式系统：Broker、Producer、Consumer都原生自动支持分布式，依赖zookeeper自动实现复杂均衡；</li><li>支持Hadoop数据并行加载：对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案<h4 id="7-6-ZeroMQ"><a href="#7-6-ZeroMQ" class="headerlink" title="7.6 ZeroMQ"></a>7.6 ZeroMQ</h4>号称最快的消息队列系统，专门为高吞吐量/低延迟的场景开发，在<strong>金融界的应用中经常使用</strong>，偏重于实时数据通信场景。ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，开发成本高。因此ZeroMQ具有一个独特的非中间件的模式，更像一个socket library，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序本身就是使用ZeroMQ API完成逻辑服务的角色。但是ZeroMQ仅提供非持久性的队列，如果down机，数据将会丢失。如：Twitter的Storm中使用ZeroMQ作为数据流的传输。</li></ul><h2 id="二、主要消息中间件的比较"><a href="#二、主要消息中间件的比较" class="headerlink" title="二、主要消息中间件的比较"></a>二、主要消息中间件的比较</h2><p><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a4plh04xj30py0nq42h.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      消息中间件MQ详解及四大MQ比较
    
    </summary>
    
      <category term="MQ" scheme="http://yoursite.com/categories/MQ/"/>
    
    
      <category term="MQ" scheme="http://yoursite.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收器</title>
    <link href="http://yoursite.com/2019/05/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2019/05/22/JVM垃圾回收器/</id>
    <published>2019-05-22T11:04:45.000Z</published>
    <updated>2019-05-22T11:07:53.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h2><p>Java虚拟机规范并没有规定垃圾收集器应该如何实现，用户可以根据系统特点对各个区域所使用的收集器进行组合使用。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a1qruuapj30fh09hq2v.jpg" alt=""><br>上图展示了7种不同分代的收集器，如果两两之间存在连线，说明可以组合使用。</p><h2 id="1、Serial收集器（串行GC）"><a href="#1、Serial收集器（串行GC）" class="headerlink" title="1、Serial收集器（串行GC）"></a>1、Serial收集器（串行GC）</h2><p>Serial 是一个采用单个线程并基于复制算法工作在新生代的收集器，进行垃圾收集时，必须暂停其他所有的工作线程。对于单CPU环境来说，Serial由于没有线程交互的开销，可以很高效的进行垃圾收集动作，是Client模式下新生代默认的收集器。</p><h2 id="2、ParNew收集器（并行GC）"><a href="#2、ParNew收集器（并行GC）" class="headerlink" title="2、ParNew收集器（并行GC）"></a>2、ParNew收集器（并行GC）</h2><p>ParNew其实是serial的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial一样。</p><h2 id="3、Parallel-Scavenge收集器（并行回收GC）"><a href="#3、Parallel-Scavenge收集器（并行回收GC）" class="headerlink" title="3、Parallel Scavenge收集器（并行回收GC）"></a>3、Parallel Scavenge收集器（并行回收GC）</h2><p>Parallel Scavenge是一个采用多线程基于复制算法并工作在新生代的收集器，其关注点在于达到一个可控的吞吐量，经常被称为“吞吐量优先”的收集器。</p><p>吞吐量 = 用户代码运行时间 /（用户代码运行时间 + 垃圾收集时间）</p><p>Parallel Scavenge提供了两个参数用于精确控制吞吐量：<br>1、-XX：MaxGCPauseMillis 设置垃圾收集的最大停顿时间<br>2、-XX：GCTimeRatio 设置吞吐量大小</p><h2 id="4、Serial-Old收集器-MSC（串行GC）"><a href="#4、Serial-Old收集器-MSC（串行GC）" class="headerlink" title="4、Serial Old收集器 MSC（串行GC）"></a>4、Serial Old收集器 MSC（串行GC）</h2><p>Serial Old 是一个采用单线程基于标记-整理算法并工作在老年代的收集器，是<strong>Client模式</strong>下老年代默认的收集器。</p><h2 id="5、Parallel-Old收集器（并行GC）"><a href="#5、Parallel-Old收集器（并行GC）" class="headerlink" title="5、Parallel Old收集器（并行GC）"></a>5、Parallel Old收集器（并行GC）</h2><p>Parallel Old是一个采用多线程基于标记-整理算法并工作在老年代的收集器。在注重吞吐量以及CPU资源敏感的场合，可以优先考虑<strong>Parallel Scavenge和Parallel Old</strong>的收集器组合。</p><h2 id="6、CMS收集器（并发GC）"><a href="#6、CMS收集器（并发GC）" class="headerlink" title="6、CMS收集器（并发GC）"></a>6、CMS收集器（并发GC）</h2><p>CMS(Concurrent Mark Sweep)是一种以获取最短回收停顿时间为目标的收集器，工作在老年代，基于“<strong>标记-清除</strong>”算法实现，整个过程分为以下4步：</p><p>1、<strong>初始标记</strong>：这个过程只是标记以下GC Roots能够直接关联的对象，但是仍然会Stop The World；<br>2、<strong>并发标记</strong>：进行GC Roots Tracing的过程，可以和用户线程一起工作。<br>3、<strong>重新标记</strong>：用于修正并发标记期间由于用户程序继续运行而导致标记产生变动的那部分记录，这个过程会暂停所有线程，但其停顿时间远比并发标记的时间短；<br>4、<strong>并发清理</strong>：可以和用户线程一起工作。</p><p>CMS收集器的缺点：</p><p>1、对CPU资源比较敏感，在并发阶段，虽然不会导致用户线程停顿，但是会占用一部分线程资源，降低系统的总吞吐量。<br>2、无法处理浮动垃圾，在并发清理阶段，用户线程的运行依然会产生新的垃圾对象，这部分垃圾只能在下一次GC时收集。<br>3、CMS是基于标记-清除算法实现的，意味着收集结束后会造成大量的<strong>内存碎片</strong>，可能导致出现老年代剩余空间很大，却无法找到足够大的连续空间分配当前对象，不得不提前触发一次Full GC。</p><p>JDK1.5实现中，当老年代空间使用率达到68%时，就会触发CMS收集器，如果应用中老年代增长不是太快，可以通过-XX:CMSInitiatingOccupancyFraction参数提高触发百分比，从而降低内存回收次数提高系统性能。</p><p>JDK1.6实现中，触发CMS收集器的阈值已经提升到92%，要是CMS运行期间预留的内存无法满足用户线程需要，会出现一次”Concurrent Mode Failure”失败，这是虚拟机会启动Serial Old收集器对老年代进行垃圾收集，当然，这样应用的停顿时间就更长了，所以这个阈值也不能设置的太高，如果导致了”Concurrent Mode Failure”失败，反而会降低性能，至于如何设置这个阈值，还得长时间的对老年代空间的使用情况进行监控。</p><h2 id="7、G1收集器"><a href="#7、G1收集器" class="headerlink" title="7、G1收集器"></a>7、G1收集器</h2><p>G1（Garbage First）是JDK1.7提供的一个工作在新生代和老年代的收集器，基于“标记-整理”算法实现，在收集结束后可以<strong>避免内存碎片</strong>问题。</p><p>G1优点：<br>1、并行与并发：充分利用多CPU来缩短Stop The World的停顿时间；<br>2、分代收集：不需要其他收集配合就可以管理整个Java堆，采用不同的方式处理新建的对象、已经存活一段时间和经历过多次GC的对象获取更好的收集效果;<br>3、<strong>空间整合</strong>：与CMS的”标记-清除”算法不同，G1在运行期间不会产生内存空间碎片，有利于应用的长时间运行，且分配大对象时，不会导致由于无法申请到足够大的连续内存而提前触发一次Full GC;<br>4、<strong>停顿预测</strong>：G1中可以建立可预测的停顿时间模型，能让使用者明确指定在M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><p>使用G1收集器时，Java堆的内存布局与其他收集器有很大区别，整个Java堆会被划分为<strong>多个大小相等的独立区域Region</strong>，新生代和老年代不再是物理隔离了，都是一部分Region（不需要连续）的集合。G1会跟踪各个Region的垃圾收集情况（回收空间大小和回收消耗的时间），维护一个优先列表，根据允许的收集时间，优先回收价值最大的Region，避免在整个Java堆上进行全区域的垃圾回收，确保了G1收集器可以在有限的时间内尽可能收集更多的垃圾。</p><p>不过问题来了：使用G1收集器，一个对象分配在某个Region中，可以和Java堆上任意的对象有引用关系，那么如何判定一个对象是否存活，是否需要扫描整个Java堆？其实这个问题在之前收集器中也存在，如果回收新生代的对象时，不得不同时扫描老年代的话，会大大降低Minor GC的效率。</p><p>针对这种情况，虚拟机提供了一个解决方案：G1收集器中Region之间的对象引用关系和其他收集器中新生代与老年代之间的对象引用关系被保存在Remenbered Set数据结构中，用来避免全堆扫描。G1中每个Region都有一个对应的Remenbered Set，当虚拟机发现程序对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于相同的Region中，如果不是，则通过CardTable把相关引用信息记录到被引用对象所属Region的Remenbered Set中。</p>]]></content>
    
    <summary type="html">
    
      几种常见的JVM垃圾回收器
    
    </summary>
    
      <category term="GC" scheme="http://yoursite.com/categories/GC/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java中常见的OOM</title>
    <link href="http://yoursite.com/2019/05/21/Java%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84OOM/"/>
    <id>http://yoursite.com/2019/05/21/Java中常见的OOM/</id>
    <published>2019-05-21T13:53:06.000Z</published>
    <updated>2019-05-21T13:54:18.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中常见的OOM异常"><a href="#Java中常见的OOM异常" class="headerlink" title="Java中常见的OOM异常"></a>Java中常见的OOM异常</h2><h3 id="1-栈溢出"><a href="#1-栈溢出" class="headerlink" title="1.栈溢出"></a>1.栈溢出</h3><blockquote><p>java.lang.StackOverflowError</p></blockquote><p>这是由于线程请求的栈深度大于虚拟机所允许的最大深度，无法压入新的栈帧，这时可以检查一下代码中是否存在死循环的<strong>递归</strong>调用。</p><h3 id="2-堆溢出"><a href="#2-堆溢出" class="headerlink" title="2.堆溢出"></a>2.堆溢出</h3><blockquote><p>java.lang.OutOfMemoryError: Java heap space</p></blockquote><p>堆空间无法给新的对象分配内存空间且GC一次后仍然无法分配足够的空间时会导致堆溢出。（对象太多、太大）</p><h3 id="3-元空间溢出"><a href="#3-元空间溢出" class="headerlink" title="3.元空间溢出"></a>3.元空间溢出</h3><blockquote><p>java.lang.OutOfMemoryError: Metaspace</p></blockquote><p> 在JDK1.8后，Metaspace 代替永久代，存放了以下的信息：虚拟机加载的类的信息、常量池、静态变量、即时编译后的代码。若不断生成类，往元空间灌，会造成元空间溢出。</p><h3 id="4-无法创建新进程"><a href="#4-无法创建新进程" class="headerlink" title="4.无法创建新进程"></a>4.无法创建新进程</h3><blockquote><p>java.lang.OutOfMemoryError:unable to create natvie thread</p></blockquote><p>高并发请求服务器时经常出现的异常，准确的说，该native thread异常与对应的平台有关。</p><p>导致原因：</p><ol><li>应用创建过多的线程，超过系统承载极限</li><li>服务器不允许创建这么多线程，linux默认单个进程可以创建的线程数为1024个</li></ol><p>解决方法：</p><ol><li>降低应用程序线程数量</li><li>对于那些确实需要的程序，修改Linux服务器的配置，扩大默认限制</li></ol><h3 id="5-GC回收异常"><a href="#5-GC回收异常" class="headerlink" title="5.GC回收异常"></a>5.GC回收异常</h3><blockquote><p>ava.lang:OutOfMemoryError: GC overhead limit exceeded</p></blockquote><p>GC回收时间长时会抛出OutOfMemoryError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存，连续多次GC都只回收了不到2%的极端情况下才会抛出。</p><p>假设不抛出GC overhead limit错误会发生什么情况呢？<br>那就是GC清理的这么点内存很快会再次填满，迫使GC再次执行，这样就形成恶性循环，CPU使用率一直是100%，而GC缺没有任何成果。</p><h3 id="6-本地直接内存溢出"><a href="#6-本地直接内存溢出" class="headerlink" title="6.本地直接内存溢出"></a>6.本地直接内存溢出</h3><blockquote><p>java.lang.OutOfMemoryError: Direct buffer memory</p></blockquote><p>写NIO程序时经常使用ByteBuffer来读取或写入数据，这是一种基于通道和缓冲区的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过DirectByteBuffer对象作为这块内存的引用进行操作。这样可以在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><blockquote><p>ByteBuffer.allocate()  分配JVM内存，属于GC范围，速度较慢</p></blockquote><blockquote><p>ByteBuffer.allocateDirect()  分配OS本地内存，不属于GC，速度较快</p></blockquote><p>但如果不断分配本地内存，堆内存很少使用，JVM不需要GC，DirectByteBuffer对象们就不会被回收，这时候，堆内存充足，但本地内存很可能使用光了，再次尝试分配本地内存就会出现OOM Error。</p>]]></content>
    
    <summary type="html">
    
      Java中常见的OOM异常
    
    </summary>
    
      <category term="OOM" scheme="http://yoursite.com/categories/OOM/"/>
    
    
      <category term="OOM" scheme="http://yoursite.com/tags/OOM/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8下String.intern()分析</title>
    <link href="http://yoursite.com/2019/05/21/JDK1-8%E4%B8%8BString-intern-%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/21/JDK1-8下String-intern-分析/</id>
    <published>2019-05-21T13:52:41.000Z</published>
    <updated>2019-05-21T13:56:00.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-String-intern-分析"><a href="#一-String-intern-分析" class="headerlink" title="一. String.intern()分析"></a>一. String.intern()分析</h2><p> 判断这个常量是否存在于常量池。<br>  如果存在<br>   判断存在内容是引用还是常量，<br>    如果是引用，<br>     返回引用地址指向堆空间对象，<br>    如果是常量，<br>     直接返回常量池常量<br>  如果不存在，<br>   将当前对象引用复制到常量池,并且返回的是当前对象的引用</p><h2 id="二-创建字符串分析"><a href="#二-创建字符串分析" class="headerlink" title="二. 创建字符串分析"></a>二. 创建字符串分析</h2><h3 id="1-只在常量池上创建常量"><a href="#1-只在常量池上创建常量" class="headerlink" title="1. 只在常量池上创建常量"></a>1. 只在常量池上创建常量</h3><blockquote><p>  String a1 = “AA”;</p></blockquote><h3 id="2-只在堆上创建对象"><a href="#2-只在堆上创建对象" class="headerlink" title="2. 只在堆上创建对象"></a>2. 只在堆上创建对象</h3><blockquote><p>String a2 = new String(“A”) + new String(“A”);</p></blockquote><h3 id="3-在堆上创建对象，在常量池上创建常量"><a href="#3-在堆上创建对象，在常量池上创建常量" class="headerlink" title="3. 在堆上创建对象，在常量池上创建常量"></a>3. 在堆上创建对象，在常量池上创建常量</h3><blockquote><p>String a3 = new String(“AA”);</p></blockquote><h3 id="4-在堆上创建对象，在常量池上创建引用"><a href="#4-在堆上创建对象，在常量池上创建引用" class="headerlink" title="4. 在堆上创建对象，在常量池上创建引用"></a>4. 在堆上创建对象，在常量池上创建引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a4 = new String(&quot;A&quot;) + new String(&quot;A&quot;);//只在堆上创建对象AA</span><br><span class="line"></span><br><span class="line">a4.intern();//将该对象AA的引用保存到常量池上</span><br></pre></td></tr></table></figure><h3 id="5-在堆上创建对象，在常量池上创建常量，在常量池上创建引用（不可能）"><a href="#5-在堆上创建对象，在常量池上创建常量，在常量池上创建引用（不可能）" class="headerlink" title="5. 在堆上创建对象，在常量池上创建常量，在常量池上创建引用（不可能）"></a>5. 在堆上创建对象，在常量池上创建常量，在常量池上创建引用（<font color="#DC143C">不可能</font>）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String a5 = new String(&quot;A&quot;) + new String(&quot;A&quot;);//只在堆上创建对象</span><br><span class="line"></span><br><span class="line">a5.intern();//在常量池上创建引用</span><br><span class="line"></span><br><span class="line">String a6 = &quot;AA&quot;;//此时不会再在常量池上创建常量AA，而是将a5的引用返回给a6</span><br><span class="line"></span><br><span class="line">System.out.println(a5 == a6); //true</span><br></pre></td></tr></table></figure><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">         String aa = &quot;AA&quot;;//设置常量AA到常量池</span><br><span class="line">         String bb = &quot;BB&quot;;//设置常量BB到常量池</span><br><span class="line">         String ccdd = &quot;CC&quot;+&quot;DD&quot;;//设置常量CCDD到常量池</span><br><span class="line">         String neeff = new String(&quot;EE&quot;)+new String(&quot;FF&quot;);//设置EE和FF到常量池。并且添加EE、FF和EEFF对象到堆</span><br><span class="line">         String aabb = aa+bb;//添加AABB对象到堆</span><br><span class="line">         String gghh = &quot;GG&quot;+new String(&quot;HH&quot;);//设置GG和HH常量到常量池,设置HH和GGHH对象到堆</span><br><span class="line">//         aa.intern();//啥事都不做，返回AA常量</span><br><span class="line">//         ccdd.intern();//啥事都不做，返回CCDD常量</span><br><span class="line">//         neeff.intern();//添加EEFF对象的引用到常量池，并返回EEFF对象</span><br><span class="line">//         aabb.intern();//添加AABB对象的引用到常量池，并返回AABB对象</span><br><span class="line">//         gghh.intern();//添加GGHH对象的引用到常量池，并返回GGHH对象</span><br><span class="line">         System.out.println(aa.intern()==aa); //true</span><br><span class="line">         System.out.println(neeff.intern()==&quot;EEFF&quot;);//true</span><br><span class="line">         System.out.println(&quot;EEFF&quot;==neeff);//true</span><br><span class="line">         String nccdd = new String(&quot;CCDD&quot;);</span><br><span class="line">         System.out.println(ccdd==nccdd);//false</span><br><span class="line">         System.out.println(ccdd==nccdd.intern());//true</span><br><span class="line">         System.out.println(aabb.intern()==aabb);//true</span><br><span class="line">         System.out.println(gghh==gghh.intern());//true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JDK1.8下String.intern()分析
    
    </summary>
    
      <category term="String" scheme="http://yoursite.com/categories/String/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>JVM常用基础参数</title>
    <link href="http://yoursite.com/2019/05/20/JVM%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2019/05/20/JVM常用基础参数/</id>
    <published>2019-05-20T13:46:31.000Z</published>
    <updated>2019-05-20T13:48:01.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM的参数类型"><a href="#JVM的参数类型" class="headerlink" title="JVM的参数类型"></a>JVM的参数类型</h2><ol><li>标配参数</li><li>x参数</li><li>xx参数</li></ol><h3 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h3><blockquote><p>-version， -help， java -showversion</p></blockquote><h3 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h3><ol><li>boolean类型：+开启/ -关闭  公式：-xx:+/-某个属性</li><li>KV设值类型：-xx:属性key=属性值value  case：-xx:MetaspaceSize=128m</li></ol><h2 id="常用基础参数"><a href="#常用基础参数" class="headerlink" title="常用基础参数"></a>常用基础参数</h2><ol><li>-Xms：初始内存大小，默认为物理内存的1/64，等价于<code>-xx:InitialHeapSize</code></li><li>-Xmx：最大分配内存，默认为物理内存的1/4，等价于<code>-xx:MaxHeapSize</code></li><li>-Xss：设置单个线程栈的大小，默认为 512K~1024K，等价于<code>-xx:ThreadStackSize</code></li><li>-Xmn：设置年轻代的大小，默认为堆空间的1/3，老年代为2/3</li><li><code>-xx:MetaspaceSize</code>：设置元空间的大小，元空间的本质和永久代类似，不过元空间不在虚拟机中，而是使用的本地内存</li><li><code>-xx:+UseSerialGC</code>：使用串行垃圾回收器</li><li><code>-xx:+UseParallelGC</code>：使用并行垃圾回收器</li><li><code>-xx:+PrintGCDetails</code>：输出GC详细的日志收集信息，包括GC 和FullGC</li><li><code>-xx:+SurvivorRatio</code>：设置年轻代中Eden区和S0,S1的比例，默认<code>-xx:+SurvivorRatio=8</code>，Eden:S0:S1=8:1:1</li><li><code>-xx:NewRatio</code>：设置年轻代和老年代在堆中的占比。默认<code>-xx:NewRatio=2</code>，年轻代占1，老年代占2，年轻代占堆的1/3</li><li><code>-xx:MaxTenuringThreshold</code>：设置垃圾的最大年龄，若为0，则年轻代对象不经过Survivor区，直接进入老年代，默认为15</li></ol><h2 id="如何在IDE中查看"><a href="#如何在IDE中查看" class="headerlink" title="如何在IDE中查看"></a>如何在IDE中查看</h2><ul><li><p>如何查看当前运行程序的配置</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br><span class="line">jinfo -flag 参数名 线程号</span><br><span class="line">jinfo -flags 线程号  -- 查看所有参数</span><br><span class="line">Non-default 后的是根据机器配置自动调整后出的参数</span><br><span class="line">Command line 后的是自己配置的参数</span><br></pre></td></tr></table></figure></li><li><p>查看初始默认值<br><code>java -xx:+PrintFlagsInitial -version</code></p></li><li><p>查看修改更新<br><code>java -xx:+PrintFlagsFinal -version</code><br>结果：  <strong>=</strong> 没改过；      <strong>:=</strong> 修改过或JVM根据硬件不同自动调整过</p></li><li>在运行时修改变更值  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -xx:+PrintFlagsFinal -xx:MetaspaceSize=128m 类名</span><br><span class="line">java -xx:+PrintCommandLineFlags -version 可以用来查看垃圾回收器</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      JVM常用基础参数
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java中的四种引用</title>
    <link href="http://yoursite.com/2019/05/20/Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/20/Java中的四种引用/</id>
    <published>2019-05-20T13:46:17.000Z</published>
    <updated>2019-05-20T13:49:15.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-强引用（Strong-Reference）"><a href="#1-强引用（Strong-Reference）" class="headerlink" title="1. 强引用（Strong Reference）"></a>1. 强引用（Strong Reference）</h2><p>强引用是指在程序代码中普遍存在的，类似“Object obj=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><p>只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象</p><h2 id="2-软引用（Soft-Reference）"><a href="#2-软引用（Soft-Reference）" class="headerlink" title="2. 软引用（Soft Reference）"></a>2. 软引用（Soft Reference）</h2><p>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，只有在<strong>内存不足</strong>的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。JDK 1.2之后，提供了SoftReference类来实现软引用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.SoftReference;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(<span class="string">"hello"</span>));</span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-弱引用（WeakReference）"><a href="#3-弱引用（WeakReference）" class="headerlink" title="3. 弱引用（WeakReference）"></a>3. 弱引用（WeakReference）</h2><p>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，<strong>无论内存是否充足</strong>，都会回收被弱引用关联的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     </span><br><span class="line">        WeakReference&lt;String&gt; sr = new WeakReference&lt;String&gt;(new String(&quot;hello&quot;));</span><br><span class="line">         </span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">        System.gc();                //通知JVM的gc进行垃圾回收</span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-虚引用（PhantomReference）"><a href="#4-虚引用（PhantomReference）" class="headerlink" title="4. 虚引用（PhantomReference）"></a>4. 虚引用（PhantomReference）</h2><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。如果一个对象与虚引用关联，跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。不能单独使用，必须和<strong>引用队列</strong> ReferenceQueue联合使用</p><p>ReferenceQueue是用来配合引用工作的，创建引用时可以指定关联的队列，当GC释放引用对象的内存时，会将引用加入到ReferenceQueue</p><p>如果程序发现某个虚引用被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于一种<strong>通知机制</strong>。当队列中有数据时，意味着引用指向的堆内存中的对象被回收。通过这种方式，JVM允许我们在对象被销毁后做一些我们想做的事</p><h2 id="四种引用对比"><a href="#四种引用对比" class="headerlink" title="四种引用对比"></a>四种引用对比</h2><table><thead><tr><th>对比</th><th>强引用</th><th>软引用</th><th>弱引用</th><th>虚引用</th></tr></thead><tbody><tr><td>引用强度</td><td>最强</td><td>第二</td><td>第三</td><td>最弱</td></tr><tr><td>如何使用</td><td>new Object()</td><td>SoftReference</td><td>WeakReference</td><td>PhantomReference</td></tr></tbody></table><h2 id="软引用和弱引用的使用场景"><a href="#软引用和弱引用的使用场景" class="headerlink" title="软引用和弱引用的使用场景"></a>软引用和弱引用的使用场景</h2><p>当一个应用要大量读取本地的图片，若每次都从硬盘读取会影响性能，而一次性全部加载进内存会造成内存溢出。</p><p>设计思路：使用一个HashMap来保存图片路径和相应图片对象关联的软引用间的映射关系，在内存不足时，JVM会自动回收这些空间</p><p><code>Map&lt;String, SoftReference&lt;BitMap&gt;&gt; imageCache = new Map&lt;String, SoftReference&lt;BitMap&gt;&gt;();</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line">&lt;br&gt;....</span><br><span class="line">public void addBitmapToCache(String path) &#123;</span><br><span class="line">// 强引用的Bitmap对象</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line">// 软引用的Bitmap对象</span><br><span class="line">SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap);</span><br><span class="line">// 添加该对象到Map中使其缓存</span><br><span class="line">imageCache.put(path, softBitmap);</span><br><span class="line">&#125;</span><br><span class="line">public Bitmap getBitmapByPath(String path) &#123;</span><br><span class="line">// 从缓存中取软引用的Bitmap对象</span><br><span class="line">SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);</span><br><span class="line">// 判断是否存在软引用</span><br><span class="line"><span class="keyword">if</span> (softBitmap == null) &#123;</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line">// 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空</span><br><span class="line">Bitmap bitmap = softBitmap.get();</span><br><span class="line"><span class="built_in">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Java中的四种引用
    
    </summary>
    
      <category term="Java引用" scheme="http://yoursite.com/categories/Java%E5%BC%95%E7%94%A8/"/>
    
    
      <category term="Java引用" scheme="http://yoursite.com/tags/Java%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM—垃圾回收机制(1)</title>
    <link href="http://yoursite.com/2019/05/16/JVM%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-1/"/>
    <id>http://yoursite.com/2019/05/16/JVM—垃圾回收机制-1/</id>
    <published>2019-05-16T08:50:17.000Z</published>
    <updated>2019-05-22T11:07:22.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h2><p>由于程序计数器、虚拟机栈、本地方法栈的生命周期都跟随线程的生命周期，当线程销毁了，内存也就回收了，所以这几个区域不用过多地考虑内存回收。由于<strong>堆</strong>和<strong>方法区</strong>的内存都是动态分配的，而且是线程共享的，所以内存回收主要关注这部分区域。</p><h2 id="如何判断对象是否存活"><a href="#如何判断对象是否存活" class="headerlink" title="如何判断对象是否存活"></a>如何判断对象是否存活</h2><p><strong>引用计数法</strong></p><blockquote><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，如果引用失效，计数器值减1，所以当该计数器的值为0时，就表示该对象可以被回收了。但是存在两个对象之间相互循环引用的问题。</p></blockquote><p><strong>可达性分析算法</strong></p><blockquote><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索的路径称为引用链，当一个对象到“GC Roots”没有任何引用链相连的话，也就是GC Roots到这个对象不可达时，证明此对象已经不可用，可以被回收了。</p></blockquote><p><strong>二次标记</strong></p><blockquote><p>在可达性分析算法中被判断是对象不可达时不一定会被垃圾回收机制回收，因为要真正宣告一个对象的死亡，必须经历两次标记的过程。如果发现对象不可达时，将会进行第一次标记，此时如果该对象调用了finalize()方法，那么这个对象会被放置在一个叫F-Queue的队列之中，如果在此队列中该对象没有成功拯救自己（拯救自己的方法是该对象有没有被重新引用），那么GC就会对F-Queue队列中的对象进行小规模的第二次标记，一旦被第二次标记的对象，将会被移除队列并等待被GC回收，所以finalize()方法是对象逃脱死亡命运的最后一次机会。</p></blockquote><h2 id="常用垃圾回收算法"><a href="#常用垃圾回收算法" class="headerlink" title="常用垃圾回收算法"></a>常用垃圾回收算法</h2><p><strong>引用计数法</strong>：  JVM一般不用</p><p><strong>复制算法</strong>：复制、清空、互换<br>把内存按容量划分为大小相等的两块区域，每次只使用其中的一块，当这一块的内存空间用完了，就把还存活的对象复制到另一块内存中去，然后把已经使用的过的内存空间一次性清理掉。这样每次都是对半个内存区域进行GC回收，并不会产生内存碎片，但是代价是把内存缩小了一半，效率比较低。<br>（1）Eden、SurvivorFrom <strong>复制</strong>到 SurvivorTo，年龄+1<br>首先 Eden 区满，触发第一次 GC，将活着的对象复制到 SurvivorFrom 区，当 Eden 区再次触发 GC 时撒扫描 Eden 区和 SurvivorFrom 区，对两区进行垃圾回收，还存活的对象复制到 SurvivorTo 区（若对象年龄达到老年的标准，复制到老年代）<br>（2）<strong>清空</strong> Eden、SurvivorFrom<br>清空 Eden、SurvivorFrom 区中的对象，也即复制之后的交换，谁空谁是To<br>（3）SurvivorFrom 区和 SurvivorTo 区<strong>互换</strong><br>原 To 区成为下一次 GC 时的 From 区，部分对象会在 From 区和 To 区间来回复制，达到15次（JVM参数MaxTenuringThreshold决定，默认值为15）还存活，将其复制到老年代</p><p><strong>标记—清除算法</strong>：<br>首先<strong>标记</strong>出需要回收的对象，在标记完成后进行统一的回收（<strong>标记即二次标记的过程</strong>）。此算法有两个不足：一是效率问题，标记和清除两个过程效率都不高；二是空间问题，标记清除后会产生大量不连续的<strong>内存碎片</strong>，内存空间碎片太多的话会导致以后程序在运行中想要分配较大对象的时候，无法找到一块连续的内存空间而导致不得不进行又一次的GC回收（后续的垃圾回收算法都是基于此算法进行改进的）</p><p><strong>标记—整理算法</strong>：<br>标记算法一样，区别是清除的时候会把所有存活的对象向一端移动（向上和向左），然后清除掉端边界以外的内存。相比标记—清除算法，此方法没有内存碎片，但付出了移动对象的成本。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>根据对象存活周期的不同将内存划分为几块（年轻代或老年代），然后根据每个年代的特点采用最合适的收集算法。</p><p>比如在<strong>年轻代</strong>中，每次都有大量对象死去，就选择<strong>复制算法</strong>；</p><p>而在<strong>老年代</strong>中对象的生存率高，没有额外的空间为它进行分配担保，所以采用<strong>标记—清除算法</strong>或者<strong>标记—整理算法</strong>来进行回收。</p><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><blockquote><p>什么是新生代、老年代</p></blockquote><p>新生代：新生代包含一个Eden区和两个Survivor区。大多数情况下，新创建的对象会在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机会触发一次Minor GC，如果Survivor区空间允许的话，该对象将被分配到Survivor。</p><p>老年代：<strong>大对象</strong>直接在老年代中分配，大对象指需要大量连续内存空间的Java对象。</p><blockquote><p>分代收集如何判定对象的年龄？</p></blockquote><p>虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden区出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间，并且对象年龄设置为1,。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当对象的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中</p><blockquote><p>为什么新生代中要有Survivor区？</p></blockquote><p>防止频繁触发FULL GC。如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代，这样会使老年代很快被填满，导致老年代触发FULL GC，由于老年代的内存空间远大于新生代，所以进行一次Full GC消耗的时间比Minor GC长得多。</p><blockquote><p>为什么要设置两个Survivor区？</p></blockquote><p>防止产生内存空间碎片。如果只有Survivor1，那么每一次当Eden区满时，触发Minor GC并把对象移入Survivor1中，如此循环对导致Survivor1中产生大量的空间碎片；所以需要有Survivor2，当Eden再一次满时，触发Minor GC，虚拟机会把Eden中和Survivor1中的存活对象通过复制算法移入Survivor2中，这样Survivor2就不会产生内存碎片，同时Eden和Survivor1会清理内存，保证下一次Minor GC触发时的操作。</p><blockquote><p>Minor GC和Full GC的区别？</p></blockquote><p>（1）新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多数都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度比较快。<br>（2）老年代GC（Full GC）：指发生在老年代的垃圾收集动作，速度非常慢，所以要尽量减少Full GC的发生。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li>强引用：指向使用new关键字创建的对象的引用都是强引用，只要该对象的强引用还在，该对象永远都不会被GC回收；</li><li>软引用：当内存不足时，就会被回收；</li><li>弱引用：只要发生GC，就会被回收；</li><li>虚引用：随时都会被回收；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解Java虚拟机》第2版 第3章 垃圾收集器与内存分配策略</p>]]></content>
    
    <summary type="html">
    
      JVM—垃圾回收机制
    
    </summary>
    
      <category term="GC" scheme="http://yoursite.com/categories/GC/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java内存原型</title>
    <link href="http://yoursite.com/2019/05/16/Java%E5%86%85%E5%AD%98%E5%8E%9F%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/05/16/Java内存原型/</id>
    <published>2019-05-16T08:50:00.000Z</published>
    <updated>2019-05-16T08:54:03.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java虚拟机内存原型"><a href="#Java虚拟机内存原型" class="headerlink" title="Java虚拟机内存原型"></a>Java虚拟机内存原型</h2><ul><li><strong>寄存器</strong>： 我们在程序中无法控制。</li><li><strong>栈</strong>： 存放基本类型的数据和对象引用，但对象本身不在栈中而是堆中。</li><li><strong>堆</strong>： 存放用 new 产生的数据</li><li><strong>静态域</strong>：存放在对象中用 static 定义的静态成员</li><li><strong>常量池</strong>：存放常量</li><li><strong>非 RAM 存储</strong>：硬盘等永久存储空间<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g339c07vh4j30d50d60ud.jpg" alt=""></li></ul><h2 id="常量池（constant-pool）"><a href="#常量池（constant-pool）" class="headerlink" title="常量池（constant pool）"></a>常量池（constant pool）</h2><p>常量池指的是在编译期被确定，并被保存在已编译的 class 文件中的一些数据。除了包含代码中所定义的各种基本类型（如 int、long 等等）和对象型（如 String 及数组）的常量值（final）外，还包含一些以文本形式出现的符号引用，比如： </p><ol><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ol><p>虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集合，包括直接常量（ string,integer 等）和其他类型：字段和方法的符号引用。<strong>对于 String 常量，它的值是在常量池中的。</strong> 而 JVM 中的常量池在内存当中是以表的形式存在的，对于 String 类型，有一张固定长度的CONSTANT_String_info 表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。在程序执行的时候，<strong>常量池会储存在 Method Area，而不是堆中</strong>。 </p><h2 id="Java内存分配中的栈"><a href="#Java内存分配中的栈" class="headerlink" title="Java内存分配中的栈"></a>Java内存分配中的栈</h2><p>栈的基本单位是<strong>帧</strong>（或栈帧）：每当一个 Java线程运行的时候，Java虚拟机会为该线程分配一个Java<br>栈。该线程在执行某个Java方法的时候，向Java栈压入一个帧，这个帧用于<strong>存储参数、局部变量、操作数、中间运算结果</strong>等。当这个方法执行完的时候，帧会从栈中弹出。Java栈上的所有数据是<strong>私有的</strong>，其他线程都不能访问该线程的栈数据。在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。当在一段代码块中定义一个变量时，Java就在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 </p><h2 id="Java内存中分配的堆"><a href="#Java内存中分配的堆" class="headerlink" title="Java内存中分配的堆"></a>Java内存中分配的堆</h2><p>Java虚拟机中的堆用来存放由 <strong>new</strong> 创建的<strong>对象和数组</strong>。在堆中分配的内存，由Java虚拟机的自动<strong>垃圾回收机制</strong>来管理堆的内存。简单的说和栈相对，<strong>堆主要是用来存放Java对象的，栈主要是用来存放对象引用的</strong>。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或对象起的一个名称。</p><p>引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能再被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是Java比较占内存的原因。<strong>实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针！</strong> </p><h2 id="堆和栈的比较"><a href="#堆和栈的比较" class="headerlink" title="堆和栈的比较"></a>堆和栈的比较</h2><p>java的堆是一个运行时数据区，类的对象从中分配空间。这些对象通过 new + 构造器等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，<strong>堆的优势</strong>是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 </p><p><strong>栈的优势</strong>是存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量数据（int，short，long，byte，float，double，boolean，char）和对象引用。 </p><p>栈有一个很重要的特殊性，就是<strong>存在栈中的数据可以共享</strong>。假设我们同时定义： int a=3；int b=3；编译器先处理 int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将 a 指向3，接着处理 int b = 3；在创建完 b 的引用变量后，因为在栈中已经有3这个值，便将b直接指向3这样，就出现了 a 与 b 同时均指向3的情况。 </p><p>这时，如果再令 a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 </p><p><strong>要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的</strong>，因为这种情况 a 的修改并不会影响到 b，它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。 </p>]]></content>
    
    <summary type="html">
    
      Java虚拟机内存原型
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="内存模型" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://yoursite.com/2019/05/15/%E6%AD%BB%E9%94%81/"/>
    <id>http://yoursite.com/2019/05/15/死锁/</id>
    <published>2019-05-15T14:45:39.000Z</published>
    <updated>2019-05-15T14:48:25.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁产生原因"><a href="#死锁产生原因" class="headerlink" title="死锁产生原因"></a>死锁产生原因</h2><p>死锁是指两个或者两个以上的进程在执行过程中，因抢夺资源而造成的一种互相等待的现象，若无外力干涉它们将都无法推进下去。</p><p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性也就很低，否则就会因争夺有限的资源而陷入死锁。</p><h2 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String lockA = <span class="string">"lockA"</span>;</span><br><span class="line">        String lockB = <span class="string">"lockB"</span>;</span><br><span class="line"></span><br><span class="line">        new Thread(new HoldLockThread(lockA,lockB),<span class="string">"ThreadAAA"</span>).start();</span><br><span class="line">        new Thread(new HoldLockThread(lockB,lockA),<span class="string">"ThreadBBB"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HoldLockThread implements Runnable&#123;</span><br><span class="line">    private String lockA;</span><br><span class="line">    private String lockB;</span><br><span class="line"></span><br><span class="line">    public HoldLockThread(String lockA,String lockB)&#123;</span><br><span class="line">        this.lockA = lockA;</span><br><span class="line">        this.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>()&#123;</span><br><span class="line">        synchronized (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t自己持有："</span>+lockA+<span class="string">"\t尝试获得："</span>+lockB);</span><br><span class="line">            //暂停一下</span><br><span class="line">            try&#123; TimeUnit.SECONDS.sleep(2); &#125;catch (InterruptedException e)&#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">            synchronized (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"\t自己持有："</span>+lockB+<span class="string">"\t尝试获得："</span>+lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何查找定位"><a href="#如何查找定位" class="headerlink" title="如何查找定位"></a>如何查找定位</h2><ul><li>linux环境下  使用 ps -ef|grep xxxx    ls -l 查看当前进程的命令</li><li>windows下的java运行程序，也有类似ps的查看进程的命令：jps -l 命令定位进程号；jstack xxxx(进程号)命令找到死锁查看</li></ul>]]></content>
    
    <summary type="html">
    
      死锁
    
    </summary>
    
      <category term="死锁" scheme="http://yoursite.com/categories/%E6%AD%BB%E9%94%81/"/>
    
    
      <category term="死锁" scheme="http://yoursite.com/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="http://yoursite.com/2019/05/15/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2019/05/15/Java线程池/</id>
    <published>2019-05-15T14:45:17.000Z</published>
    <updated>2019-05-15T14:48:16.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>之前我们在使用多线程都是用Thread的start()来创建启动一个线程，但是在实际开发中，如果每个请求到达就创建一个新线程，开销是相当大的。服务器在创建和销毁线程上花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个 jvm 里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。这就引入了线程池概念。（第4种获得/使用java多线程的方式）线程池的主要特点是：线程复用，控制最大并发数，管理线程。</p><h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><p>在java.util.concurrent包下，提供了一系列与线程池相关的类。合理的使用线程池，可以带来多个好处：</p><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><h2 id="如何使用线程池"><a href="#如何使用线程池" class="headerlink" title="如何使用线程池"></a>如何使用线程池</h2><ul><li>1、创建线程池</li><li>2、创建任务</li><li>3、执行任务</li><li>4、关闭线程池</li></ul><h2 id="五种线程池的使用场景"><a href="#五种线程池的使用场景" class="headerlink" title="五种线程池的使用场景"></a>五种线程池的使用场景</h2><ul><li><code>newSingleThreadExecutor</code> ：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</li><li><code>newFixedThreadPool</code> ：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。</li><li><code>newCachedThreadPool</code> ：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。</li><li><code>newScheduledThreadPool</code> ：一个可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</li><li><code>newWorkStealingPool</code> ：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行。</li></ul><h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = new ThreadPoolExecutor(2,</span><br><span class="line">                5,</span><br><span class="line">                1L,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;&gt;(3),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                new ThreadPoolExecutor.DiscardPolicy());</span><br></pre></td></tr></table></figure><p>线程池不允许用Executors来创建，而是通过ThreadPoolExecutor这样的方式，这样的处理方式可以让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br><strong>说明：</strong> Executors返回的线程池对象弊端如下：</p><ul><li>FixedThreadPool 和 SingleThreadExecutor：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，导致OOM。</li><li>CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，导致OOM。</li></ul><h2 id="线程池的七大参数"><a href="#线程池的七大参数" class="headerlink" title="线程池的七大参数"></a>线程池的七大参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) ;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize ：线程池中常驻的核心线程数，决定着新提交的任务是新开线程去执行还是放到任务队列中，也是线程池的最最核心的参数。一般线程池开始时是没有线程的，只有当任务来了并且线程数量小于corePoolSize才会创建线程。                             </li><li>maximumPoolSize ：最大线程数，线程池能创建的最大线程数量。</li><li>keepAliveTime ：在线程数量超过corePoolSize后，多余空闲线程的最大存活时间。</li><li>unit ：keepAliveTime时间单位</li><li>workQueue ：存放来不及处理的任务的队列，是一个BlockingQueue。</li><li><p>threadFactory ：生产线程的工厂类，可以定义线程名，优先级等。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">            .setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br></pre></td></tr></table></figure></li><li><p>handler ：拒绝策略，当前队列满且工作线程数大于或等于maximumPoolSize时启用，共4种策略。</p></li></ul><h2 id="4种拒绝策略"><a href="#4种拒绝策略" class="headerlink" title="4种拒绝策略"></a>4种拒绝策略</h2><ol><li><code>AbortPolicy</code> ：当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。</li><li><code>CallerRunsPolicy</code> ： 当任务添加到线程池中被拒绝时，将任务回退给调用者。</li><li><code>DiscardOldestPolicy</code> ：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最久的未处理任务，然后将被拒绝的任务添加到等待队列中，并尝试再次提交。</li><li><code>DiscardPolicy</code> ：当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务，如果允许任务丢失，这是最好的方案。<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2>线程池使用完毕，需要对其进行关闭，有两种方法<blockquote><p>shutdown()</p></blockquote></li></ol><p>说明：shutdown并不是直接关闭线程池，而是不再接受新的任务…如果线程池内有任务，那么把这些任务执行完毕后，关闭线程池</p><blockquote><p>shutdownNow()</p></blockquote><p>说明：这个方法表示不再接受新的任务，并把任务队列中的任务直接移出掉，如果有正在执行的，尝试进行停止</p><h2 id="线程池的底层工作原理"><a href="#线程池的底层工作原理" class="headerlink" title="线程池的底层工作原理"></a>线程池的底层工作原理</h2><ol><li>提交任务</li><li>核心线程是否已满？ Y 跳转至第3步；  N 创建执行线程</li><li>队列已满？   Y 跳转至第4步；  N 加入队列</li><li>最大线程已满？   Y 跳转至第5步；  N 创建线程</li><li>拒绝策略</li></ol><h2 id="如何配置合理的线程数"><a href="#如何配置合理的线程数" class="headerlink" title="如何配置合理的线程数"></a>如何配置合理的线程数</h2><p>线程池中线程数目的设置依托于硬件设备（CPU核数）以及需要执行任务的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查看CPU核数</span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure></p><p>CPU密集型任务：</p><ul><li>特点：大量运算，没有阻塞，CPU一直全速运行</li><li>配置：应配置尽可能<strong>少</strong>的线程数量。</li><li>公式：CPU核数 + 1</li></ul><p>IO密集型任务：</p><ul><li>特点：大部分线程阻塞，CPU不是一直执行任务</li><li>配置：应配置尽可能<strong>多</strong>的线程数量。如：CPU核数 * 2</li><li>公式：CPU核数 / (1 - 阻塞系数)  阻塞系数约为0.8~0.9</li></ul>]]></content>
    
    <summary type="html">
    
      Java线程池概述
    
    </summary>
    
      <category term="ThreadPool" scheme="http://yoursite.com/categories/ThreadPool/"/>
    
    
      <category term="ThreadPool" scheme="http://yoursite.com/tags/ThreadPool/"/>
    
  </entry>
  
  <entry>
    <title>JUC初探</title>
    <link href="http://yoursite.com/2019/05/15/JUC%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2019/05/15/JUC初探/</id>
    <published>2019-05-15T14:44:59.000Z</published>
    <updated>2019-05-15T14:49:18.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JUC-简介"><a href="#一、JUC-简介" class="headerlink" title="一、JUC 简介"></a>一、JUC 简介</h2><p>JUC：java.util.concurrent 在并发编程中使用的工具类</p><h2 id="二、Lock-接口"><a href="#二、Lock-接口" class="headerlink" title="二、Lock 接口"></a>二、Lock 接口</h2><h3 id="1-Synchronized"><a href="#1-Synchronized" class="headerlink" title="1. Synchronized"></a>1. Synchronized</h3><h4 id="1-1-多线程编程模板"><a href="#1-1-多线程编程模板" class="headerlink" title="1.1 多线程编程模板"></a>1.1 多线程编程模板</h4><ul><li>线程      操作      资源类</li><li>判断      干活      通知</li><li>高内聚低耦合</li><li><font color="#DC143C">注意：多线程的判断必须使用while循环，不能使用if</font><h4 id="1-2-实现步骤"><a href="#1-2-实现步骤" class="headerlink" title="1.2 实现步骤"></a>1.2 实现步骤</h4></li></ul><ol><li>创建资源类</li><li>资源类里创建同步方法、同步代码块<h3 id="2-Lock"><a href="#2-Lock" class="headerlink" title="2. Lock"></a>2. Lock</h3><h4 id="2-1-Lock是什么"><a href="#2-1-Lock是什么" class="headerlink" title="2.1 Lock是什么"></a>2.1 Lock是什么</h4>Lock 实现提供更广泛的锁定操作可以比使用synchronized 获得方法和声明更好。他们允许更灵活的结构，可以有完全不同的特性，可以支持多个相关的Condition 对象。<h4 id="2-2-Lock接口的实现"><a href="#2-2-Lock接口的实现" class="headerlink" title="2.2 Lock接口的实现"></a>2.2 Lock接口的实现</h4>ReentrantLock 可重入锁，参考Java8API<h4 id="2-3-lambda-表达式"><a href="#2-3-lambda-表达式" class="headerlink" title="2.3 lambda 表达式"></a>2.3 lambda 表达式</h4></li><li>要求：lambda 表达式，如果一个接口只有一个方法，我可以把方法名省略</li><li><p>编写规则：拷贝小括号（），写死右箭头-&gt;，落地大括号{…}</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo foo = () -&gt; &#123;System.out.println(&quot;****hello lambda&quot;);&#125;;</span><br></pre></td></tr></table></figure></li><li><p>函数式接口：lambda 表达式，必须是函数式接口，必须只有一个方法，如果接口只有一个方法java 默认它为函数式接口。为了正确使用Lambda 表达式，需要给接口加个注解：@FunctionalInterface，如有两个方法，立刻报错。</p><h4 id="2-4-Lock与Synchronized的区别，用Lock有什么好处"><a href="#2-4-Lock与Synchronized的区别，用Lock有什么好处" class="headerlink" title="2.4 Lock与Synchronized的区别，用Lock有什么好处"></a>2.4 Lock与Synchronized的区别，用Lock有什么好处</h4><ol><li><p>原始构成：</p><ul><li>synchronized是关键字，属于JVM层面<br>monitorenter（底层通过monitor对象来完成，wait/notify等方法也依赖于monitor对象，只有再同步块和方法中才能调用wait/notify等方法）， monitorexit<ul><li>lock是具体类（java.util.concurrent.locks.Lock）是API层面的锁</li></ul></li></ul></li><li><p>使用方法：</p><ul><li>synchronized不需要用户手动释放锁，当synchronized代码执行完后，系统会自动让线程释放对锁的占用   </li><li>ReentrantLock则需要用户手动释放锁，若没有主动释放，就有可能出现死锁的情况，需要lock()和unlock()方法配合try/finally语句块来完成</li></ul></li><li><p>等待是否可中断：</p><ul><li>synchronized不可中断，除非抛出异常或正常运行完成      <ul><li>ReentrantLock可中断，<br>（1）设置超时方法tryLock(long timeout, TimeUnit unit)<br>（2）LockInterruptibly()放在代码块中，调用interrupt()方法可中断</li></ul></li></ul></li><li><p>加锁是否公平：</p><ul><li>synchronized为非公平锁</li><li>ReentrantLock两者都可以，默认非公平锁，构造方法可传入boolean值，true为公平锁，false为非公平锁</li></ul></li><li><p>绑定多个条件的condition：</p><ul><li>synchronized没有</li><li>ReentrantLock可以实现分组唤醒需要被唤醒的线程，可以精确唤醒，而不是像synchronized要么随机唤醒一个线程，要么全部唤醒</li></ul></li></ol></li></ol><h2 id="三、Callable-接口"><a href="#三、Callable-接口" class="headerlink" title="三、Callable 接口"></a>三、Callable 接口</h2><h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a>1. 是什么</h3><h4 id="1-1-面试题：获得多线程的方法几种？"><a href="#1-1-面试题：获得多线程的方法几种？" class="headerlink" title="1.1 面试题：获得多线程的方法几种？"></a>1.1 面试题：获得多线程的方法几种？</h4><p>错误回答：<br>（1）继承thread 类（2）runnable 接口<br>正确回答：<br>传统的是继承thread 类和实现runnable 接口，java5 以后又有实现callable 接口和java 的线程池获得。</p><h4 id="1-2-功能接口"><a href="#1-2-功能接口" class="headerlink" title="1.2 功能接口"></a>1.2 功能接口</h4><p>Callable 是一个功能接口，因此可以用作lambda 表达式或方法引用的赋值对象。</p><h3 id="2-与-runnable-对比"><a href="#2-与-runnable-对比" class="headerlink" title="2. 与 runnable 对比"></a>2. 与 runnable 对比</h3><ol><li>Callable有返回值</li><li>Callable会抛异常</li><li>接口实现的方法不同 call()和run()</li></ol><h3 id="3-如何使用"><a href="#3-如何使用" class="headerlink" title="3. 如何使用"></a>3. 如何使用</h3><h4 id="3-1-FutureTask"><a href="#3-1-FutureTask" class="headerlink" title="3.1 FutureTask"></a>3.1 FutureTask</h4><ul><li>FutureTask 未来的任务，用它就干一件事，异步调用。</li><li><p>main 方法就像一个冰糖葫芦，一个个方法由main 串起来。但解决不了一个问题：正常调用挂起堵塞问题</p><blockquote><p>例子：高考：会做的先做，不会的放在后面做</p></blockquote></li><li><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future 对象在后台完成，当主线程将来需要时，就可以通过Future 对象获得后台作业的计算结果或者执行状态。</p></li><li>一般FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</li><li>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞get 方法。一旦计算完成，就不能再重新开始或取消计算。get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。</li><li>只计算一次，且get 方法一般放到最后，若不放在最后一般使用 while (!futureTask.isDone()) 循环</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new MyThread());</span><br><span class="line"></span><br><span class="line">//共用一个FutureTask只会进1次</span><br><span class="line">new Thread(futureTask,&quot;AA&quot;).start();</span><br><span class="line">new Thread(futureTask,&quot;BB&quot;).start();</span><br><span class="line">    </span><br><span class="line">int r2 = futureTask.get();</span><br></pre></td></tr></table></figure><h2 id="四、线程间的通信"><a href="#四、线程间的通信" class="headerlink" title="四、线程间的通信"></a>四、线程间的通信</h2><h3 id="1-线程间通信"><a href="#1-线程间通信" class="headerlink" title="1. 线程间通信"></a>1. 线程间通信</h3><p>（1）生产者+消费者<br>（2）通知等待唤醒机制</p><h3 id="2-synchronized-实现"><a href="#2-synchronized-实现" class="headerlink" title="2. synchronized 实现"></a>2. synchronized 实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void increment() throws InterruptedException&#123;</span><br><span class="line">    //1 判断</span><br><span class="line">    if(number !=0 ) &#123;</span><br><span class="line">        this.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    //2 干活</span><br><span class="line">    ++number;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+number);</span><br><span class="line">    //3 通知</span><br><span class="line">    this.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-lock实现"><a href="#3-lock实现" class="headerlink" title="3. lock实现"></a>3. lock实现</h3><h4 id="3-1-对标synchronized"><a href="#3-1-对标synchronized" class="headerlink" title="3.1 对标synchronized"></a>3.1 对标synchronized</h4><p>synchronized———wait———notify<br>lock———await———signal</p><h4 id="3-2-condition"><a href="#3-2-condition" class="headerlink" title="3.2 condition"></a>3.2 condition</h4><p>synchronized没有，ReentrantLock可以实现分组唤醒需要被唤醒的线程，可以使用condition进行精确唤醒（<strong>有顺序通知，需要有标识位</strong>），而不是像synchronized要么随机唤醒一个线程，要么全部唤醒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//1 判断</span><br><span class="line">while(number != 3)&#123; //number就是标识位</span><br><span class="line">    //A 就要停止</span><br><span class="line">    c3.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JUC简介
    
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/categories/JUC/"/>
    
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java阻塞队列：BlockingQueue</title>
    <link href="http://yoursite.com/2019/05/14/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9ABlockingQueue/"/>
    <id>http://yoursite.com/2019/05/14/Java阻塞队列：BlockingQueue/</id>
    <published>2019-05-14T14:01:17.000Z</published>
    <updated>2019-05-14T14:03:25.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阻塞队列：BlockingQueue"><a href="#阻塞队列：BlockingQueue" class="headerlink" title="阻塞队列：BlockingQueue"></a>阻塞队列：BlockingQueue</h2><p>阻塞队列是一种队列，一种可以在多线程环境下使用，并且支持阻塞等待的队列。也就是说，阻塞队列和一般的队列的区别就在于：</p><ul><li>多线程环境支持，多个线程可以安全的访问队列</li><li>支持生产和消费等待，多个线程之间互相配合，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线 程就会阻塞直到队列不满。</li></ul><h2 id="几种常用的阻塞队列"><a href="#几种常用的阻塞队列" class="headerlink" title="几种常用的阻塞队列"></a>几种常用的阻塞队列</h2><ul><li>ArrayBlockingQueue，基于数组结构的有界阻塞队列，按FIFO对元素进行排序</li><li>LinkedBlockingQueue，基于链表结构的阻塞队列，按FIFO对元素进行排序，有界但大小默认值为Integer.MAX_VALUE = 2 的 31 次方 - 1</li><li>LinkedBlockingDeque，基于链表结构的双端阻塞队列</li><li>LinkedTransferDeque，基于链表结构的无界阻塞队列</li><li>DelayQueue，使用优先级队列实现的延时无界阻塞队列</li><li>PriorityBlockingQueue，支持优先级排序的无界阻塞队列，在需要多线程支持、需要优先级队列支持的场景下会被运用</li><li>SynchronousQueue同步队列，一个不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移出操作，否则插入操作会一致阻塞（单个元素的队列）</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>阻塞队列在java中的一种典型使用场景是线程池，在线程池中，当提交的任务不能被立即得到执行的时候，线程池就会将提交的任务放到一个阻塞的任务队列中来，比如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">       return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>newFixedThreadPool使用了<strong>LinkedBlockingQueue</strong>这种阻塞队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>newCachedThreadPool使用了<strong>SynchronousQueue</strong>这种队列，这种队列的特点是不缓存数据，而是缓存线程，线程分为生产者线程和消费者线程，一个生产者线程和一个消费者线程是互补的，当一个生产者线程遇到一个消费者线程的时候就会直接进行数据交换，所以这种队列的技术点比较高，理解起来难度较大。一个线程只能缓存一个数据，当一个线程插入数据之后就会被阻塞，直到另外一个线程消费了其中的数据。</p><p>阻塞队列还提供了其他类型的队列，包括双端阻塞队列，延时阻塞队列，<strong>延时阻塞队列</strong>的使用可以在newScheduledThreadPool中找到，newScheduledThreadPool里面使用延时阻塞队列来调度周期性任务执行。</p><h2 id="BlockingQueue提供的一些方法"><a href="#BlockingQueue提供的一些方法" class="headerlink" title="BlockingQueue提供的一些方法"></a>BlockingQueue提供的一些方法</h2><p>根据插入和取出两种类型的操作，具体分为下面一些类型：<br>|操作类型| Throws Exception |Special Value|Blocks|Times out|<br>|–|–|–|–|–|<br>|插入| add(o) |offer(o)|put(o)|offer(o, timeout, unit)|<br>|取出(删除) | remove(o) |poll()|take()|poll(timeout, unit)|<br>|Examine(检查)| element() |peek()|not applicable|not applicable|</p><ul><li><strong>Throws Exception</strong> 类型的插入和取出在不能立即被执行的时候就会<strong>抛出异常</strong>。</li><li><strong>Special Value</strong> 类型的插入和取出在不能被立即执行的情况下会返回一个<strong>特殊的值（true 或者 false）</strong></li><li><strong>Blocked</strong> 类型的插入和取出操作在不能被立即执行的时候会<strong>阻塞线程</strong>直到可以操作的时候会被其他线程<strong>唤醒</strong></li><li><strong>Timed out</strong> 类型的插入和取出操作在不能立即执行的时候会<strong>被阻塞一定的时间</strong>，如果在指定的时间内没有被执行，那么会<strong>返回一个特殊值</strong></li></ul><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue需要你提供数组的大小，下面是ArrayBlockingQueue提供的三个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity): // 初始化数组大小</span><br><span class="line"></span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair): //初始化数组大小，并且设定是否是fair模式</span><br><span class="line"> </span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) //初始化数组大小，设置是否是fair模式，然后使用一个集合初始化阻塞队列</span><br></pre></td></tr></table></figure></p><p>在构造函数中有两个比较关键的参数，一个是capacity代表阻塞队列使用的数组的长度，另外一个是fair，代表阻塞队列的一种策略选择，用于构造用于线程同步的锁（ReentrantLock）是公平锁还是非公平锁，默认值为false，非公平锁</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue不存在容量的说法，任何插入操作都需要等待其他线程来消费，否则就会阻塞等待，也就是说，生产线程生产出一条数据之后就要等待消费者线程来将其消费掉，才能继续生产数据，否则就会阻塞等待消费。</p><p>SynchronousQueue通过使用Transferer类的transfer(E e, boolean timed, long nanos)方法来完成数据交易操作，根据fair模式和non-fair模式有两种类型的Transferer，fair模式对应于TransferQueue，non-fair模式对应TransferStack。</p><h2 id="总结：为什么使用BlockingQueue"><a href="#总结：为什么使用BlockingQueue" class="headerlink" title="总结：为什么使用BlockingQueue"></a>总结：为什么使用BlockingQueue</h2><p>使用阻塞队列，程序员不再需要关心什么时候该阻塞/唤醒线程</p>]]></content>
    
    <summary type="html">
    
      Java阻塞队列：BlockingQueue
    
    </summary>
    
      <category term="阻塞队列" scheme="http://yoursite.com/categories/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
      <category term="阻塞队列" scheme="http://yoursite.com/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>用ideal创建java项目，并添加maven管理</title>
    <link href="http://yoursite.com/2019/05/13/%E7%94%A8ideal%E5%88%9B%E5%BB%BAjava%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%B9%B6%E6%B7%BB%E5%8A%A0maven%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/13/用ideal创建java项目，并添加maven管理/</id>
    <published>2019-05-13T11:44:02.000Z</published>
    <updated>2019-05-13T11:49:08.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一步-创建项目"><a href="#第一步-创建项目" class="headerlink" title="第一步 创建项目"></a>第一步 创建项目</h2><p>File—&gt;New—&gt;Project</p><h2 id="第二步-修改项目结构"><a href="#第二步-修改项目结构" class="headerlink" title="第二步 修改项目结构"></a>第二步 修改项目结构</h2><p>在项目的src下面创建main/java和main/resources目录.</p><p>File—&gt;Project Structure 或者快捷键Ctrl+Shift+Alt+s.<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2zp18rt01j31060kowf5.jpg" alt=""><br>将Sources定位到java目录下，将Resources定位到resources下面.</p><p>此处补充idea下的java项目关于不同资源的标识符。</p><ul><li>Sources 一般用于标注类似 src 这种可编译目录。有时候我们不单单项目的 src 目录要可编译，还有其他一些特别的目录也许我们也要作为可编译的目录，就需要对该目录进行此标注。只有 Sources 这种可编译目录才可以新建 Java 类和包，这一点需要牢记。</li><li>Tests 一般用于标注可编译的单元测试目录。在规范的 maven 项目结构中，顶级目录是src，maven 的 src 我们是不会设置为Sources 的，而是在其子目录 main 目录下的 java 目录，我们会设置为 Sources。而单元测试的目录是 src - test - java，这里的 java 目录我们就会设置为 Tests，表示该目录是作为可编译的单元测试目录。一般这个和后面几个我们都是在 maven 项目下进行配置的，但是我这里还是会先说说。从这一点我们也可以看出 IntelliJ IDEA 对 maven 项目的支持是比彻底的。</li><li>Resources 一般用于标注资源文件目录。在 maven 项目下，资源目录是单独划分出来的，其目录为：src - main -resources，这里的 resources 目录我们就会设置为 Resources，表示该目录是作为资源目录。资源目录下的文件是会被编译到输出目录下的。</li><li>Test Resources 一般用于标注单元测试的资源文件目录。在 maven 项目下，单元测试的资源目录是单独划分出来的，其目录为：src - test -resources，这里的 resources 目录我们就会设置为 Test Resources，表示该目录是作为单元测试的资源目录。资源目录下的文件是会被编译到输出目录下的。</li><li>Excluded 一般用于标注排除目录。被排除的目录不会被 IntelliJ IDEA 创建索引，相当于被 IntelliJ IDEA 废弃，该目录下的代码文件是不具备代码检查和智能提示等常规代码功能。</li><li>通过上面的介绍，我们知道对于非 maven 项目我们只要会设置 src 即可。<h2 id="第三步-添加maven管理"><a href="#第三步-添加maven管理" class="headerlink" title="第三步 添加maven管理"></a>第三步 添加maven管理</h2>选中项目——&gt;右键——&gt;选择Add Framworks Support——&gt;选择maven</li></ul><p>此时就会生成pom.xml文件，可以在该文件里面添加项目的依赖了</p>]]></content>
    
    <summary type="html">
    
      用ideal创建java项目，并添加maven管理
    
    </summary>
    
      <category term="Ideal" scheme="http://yoursite.com/categories/Ideal/"/>
    
    
      <category term="Ideal" scheme="http://yoursite.com/tags/Ideal/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>JUC的几个常用辅助类</title>
    <link href="http://yoursite.com/2019/05/13/JUC%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/05/13/JUC的几个常用辅助类/</id>
    <published>2019-05-13T11:43:43.000Z</published>
    <updated>2019-05-13T11:51:21.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ReentrantReadWriteLock-读写锁"><a href="#1-ReentrantReadWriteLock-读写锁" class="headerlink" title="1. ReentrantReadWriteLock 读写锁"></a>1. ReentrantReadWriteLock 读写锁</h2><ul><li>多个线程同时读一个资源类没有问题，所以为了满足并发量，读取共享资源应该可以同时进行。</li><li>但是写共享资源只能有一个线程。</li><li><p>写操作：原子+独占，整个过程必须是一个完整的统一体，中间不许被分割，被打断。</p><p>总结：</p></li><li>读-读可以共存</li><li>读-写不可以共存</li><li>写-写不可以共存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">写锁</span><br><span class="line">reentrantReadWriteLock.writeLock().lock();</span><br><span class="line">reentrantReadWriteLock.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">读锁</span><br><span class="line">reentrantReadWriteLock.readLock().lock();</span><br><span class="line">reentrantReadWriteLock.readLock().unlock();</span><br></pre></td></tr></table></figure><h2 id="2-CountDownLatch-减少计数"><a href="#2-CountDownLatch-减少计数" class="headerlink" title="2. CountDownLatch 减少计数"></a>2. CountDownLatch 减少计数</h2><ul><li>CountDownLatch 主要有两个方法，当一个或多个线程调用await 方法时，这些线程会阻塞。</li><li>其它线程调用countDown 方法会将计数器减1(调用countDown 方法的线程不会阻塞)，当计数器的值变为0 时，因await 方法阻塞的线程会被唤醒，继续执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//自定义计数值</span><br><span class="line">java.util.concurrent.CountDownLatch countDownLatch = new java.util.concurrent.CountDownLatch(6);</span><br><span class="line">//计数值减1</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line">//线程阻塞</span><br><span class="line">countDownLatch.await();</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-CyclicBarrier-循环栅栏"><a href="#3-CyclicBarrier-循环栅栏" class="headerlink" title="3. CyclicBarrier 循环栅栏"></a>3. CyclicBarrier 循环栅栏</h2><ul><li>CyclicBarrier 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞,直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</li><li>线程进入屏障通过CyclicBarrier 的await()方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()-&gt;&#123;System.out.println(&quot;召唤神龙&quot;);&#125;);</span><br><span class="line"></span><br><span class="line">cyclicBarrier.await();</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-Semaphore-信号灯"><a href="#4-Semaphore-信号灯" class="headerlink" title="4. Semaphore 信号灯"></a>4. Semaphore 信号灯</h2><p>在信号量上我们定义两种操作：</p><ul><li>acquire（获取） 当一个线程调用acquire 操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</li><li>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</li><li>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = new Semaphore(3);  //模拟3个车位</span><br><span class="line"></span><br><span class="line">semaphore.acquire();//获取</span><br><span class="line"></span><br><span class="line">semaphore.release();//释放</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JUC的几个常用辅助类:ReentrantReadWriteLock 读写锁, CountDownLatch 减少计数, CyclicBarrier 循环栅栏, 4. Semaphore 信号灯
    
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/categories/JUC/"/>
    
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java插件Lombok的介绍和使用方法</title>
    <link href="http://yoursite.com/2019/05/13/Java%E6%8F%92%E4%BB%B6Lombok%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/05/13/Java插件Lombok的介绍和使用方法/</id>
    <published>2019-05-13T11:43:23.000Z</published>
    <updated>2019-05-13T11:47:43.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Lombok背景介绍"><a href="#1-Lombok背景介绍" class="headerlink" title="1. Lombok背景介绍"></a>1. Lombok背景介绍</h2><p>官方介绍如下：</p><blockquote><p>Project Lombok makes java a spicier language by adding ‘handlers’ that know how to build and compile simple, boilerplate-free, not-quite-java code.<br>大致意思是Lombok通过增加一些“处理程序”，可以让java变得简洁、快速。</p></blockquote><h2 id="2-Lombok使用方法"><a href="#2-Lombok使用方法" class="headerlink" title="2. Lombok使用方法"></a>2. Lombok使用方法</h2><p>Lombok能以简单的<strong>注解形式</strong>来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法，而且需要维护，当属性多时会出现大量的getter/setter方法，这些显得很冗长也没有太多技术含量，一旦修改属性，就容易出现忘记修改对应方法的失误。</p><p>Lombok能通过注解的方式，<strong>在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法</strong>。出现的神奇就是在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。这样就省去了手动重建这些代码的麻烦，使代码看起来更简洁些。</p><p>Lombok的使用跟引用jar包一样，可以在官网（<a href="https://projectlombok.org/download" target="_blank" rel="noopener">https://projectlombok.org/download</a>）下载jar包，也可以使用maven添加依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.16.20&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="2-1-Data"><a href="#2-1-Data" class="headerlink" title="2.1 @Data"></a>2.1 @Data</h3><p>@Data注解在类上，会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</p><h3 id="2-2-Getter-Setter"><a href="#2-2-Getter-Setter" class="headerlink" title="2.2 @Getter/@Setter"></a>2.2 @Getter/@Setter</h3><p>如果觉得@Data太过残暴（因为@Data集合了@ToString、@EqualsAndHashCode、@Getter/@Setter、@RequiredArgsConstructor的所有特性）不够精细，可以使用@Getter/@Setter注解，此注解在属性上，可以为相应的属性自动生成Getter/Setter方法。</p><h3 id="2-3-NonNull"><a href="#2-3-NonNull" class="headerlink" title="2.3 @NonNull"></a>2.3 @NonNull</h3><p>该注解用在属性或构造器上，Lombok会生成一个非空的声明，可用于校验参数，能帮助避免空指针。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import lombok.NonNull;</span><br><span class="line"></span><br><span class="line">public class NonNullExample extends Something &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  </span><br><span class="line">  public NonNullExample(@NonNull Person person) &#123;</span><br><span class="line">    super(&quot;Hello&quot;);</span><br><span class="line">    this.name = person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用Lombok：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import lombok.NonNull;</span><br><span class="line"></span><br><span class="line">public class NonNullExample extends Something &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  </span><br><span class="line">  public NonNullExample(@NonNull Person person) &#123;</span><br><span class="line">    super(&quot;Hello&quot;);</span><br><span class="line">    if (person == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.name = person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-4-Cleanup"><a href="#2-4-Cleanup" class="headerlink" title="2.4 @Cleanup"></a>2.4 @Cleanup</h3><p>该注解能帮助我们自动调用close()方法，很大的简化了代码。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import lombok.Cleanup;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class CleanupExample &#123;</span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    @Cleanup InputStream in = new FileInputStream(args[0]);</span><br><span class="line">    @Cleanup OutputStream out = new FileOutputStream(args[1]);</span><br><span class="line">    byte[] b = new byte[10000];</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      int r = in.read(b);</span><br><span class="line">      if (r == -1) break;</span><br><span class="line">      out.write(b, 0, r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用Lombok：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class CleanupExample &#123;</span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    InputStream in = new FileInputStream(args[0]);</span><br><span class="line">    try &#123;</span><br><span class="line">      OutputStream out = new FileOutputStream(args[1]);</span><br><span class="line">      try &#123;</span><br><span class="line">        byte[] b = new byte[10000];</span><br><span class="line">        while (true) &#123;</span><br><span class="line">          int r = in.read(b);</span><br><span class="line">          if (r == -1) break;</span><br><span class="line">          out.write(b, 0, r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        if (out != null) &#123;</span><br><span class="line">          out.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (in != null) &#123;</span><br><span class="line">        in.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-5-EqualsAndHashCode"><a href="#2-5-EqualsAndHashCode" class="headerlink" title="2.5 @EqualsAndHashCode"></a>2.5 @EqualsAndHashCode</h3><p>默认情况下，会使用所有非静态（non-static）和非瞬态（non-transient）属性来生成equals和hasCode，也能通过exclude注解来排除一些属性。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line">@EqualsAndHashCode(exclude=&#123;&quot;id&quot;, &quot;shape&quot;&#125;)</span><br><span class="line">public class EqualsAndHashCodeExample &#123;</span><br><span class="line">  private transient int transientVar = 10;</span><br><span class="line">  private String name;</span><br><span class="line">  private double score;</span><br><span class="line">  private Shape shape = new Square(5, 10);</span><br><span class="line">  private String[] tags;</span><br><span class="line">  private int id;</span><br><span class="line">  </span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @EqualsAndHashCode(callSuper=true)</span><br><span class="line">  public static class Square extends Shape &#123;</span><br><span class="line">    private final int width, height;</span><br><span class="line">    </span><br><span class="line">    public Square(int width, int height) &#123;</span><br><span class="line">      this.width = width;</span><br><span class="line">      this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-6-ToString"><a href="#2-6-ToString" class="headerlink" title="2.6 @ToString"></a>2.6 @ToString</h3><p>类使用@ToString注解，Lombok会生成一个toString()方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割。</p><p>通过将includeFieldNames参数设为true，就能明确的输出toString()属性。这一点是不是有点绕口，通过代码来看会更清晰些。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">@ToString(exclude=&quot;id&quot;)</span><br><span class="line">public class ToStringExample &#123;</span><br><span class="line">  private static final int STATIC_VAR = 10;</span><br><span class="line">  private String name;</span><br><span class="line">  private Shape shape = new Square(5, 10);</span><br><span class="line">  private String[] tags;</span><br><span class="line">  private int id;</span><br><span class="line">  </span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return this.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @ToString(callSuper=true, includeFieldNames=true)</span><br><span class="line">  public static class Square extends Shape &#123;</span><br><span class="line">    private final int width, height;</span><br><span class="line">    </span><br><span class="line">    public Square(int width, int height) &#123;</span><br><span class="line">      this.width = width;</span><br><span class="line">      this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用Lombok：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class ToStringExample &#123;</span><br><span class="line">  private static final int STATIC_VAR = 10;</span><br><span class="line">  private String name;</span><br><span class="line">  private Shape shape = new Square(5, 10);</span><br><span class="line">  private String[] tags;</span><br><span class="line">  private int id;</span><br><span class="line">  </span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return this.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class Square extends Shape &#123;</span><br><span class="line">    private final int width, height;</span><br><span class="line">    </span><br><span class="line">    public Square(int width, int height) &#123;</span><br><span class="line">      this.width = width;</span><br><span class="line">      this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">      return &quot;Square(super=&quot; + super.toString() + &quot;, width=&quot; + this.width + &quot;, height=&quot; + this.height + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public String toString() &#123;</span><br><span class="line">    return &quot;ToStringExample(&quot; + this.getName() + &quot;, &quot; + this.shape + &quot;, &quot; + Arrays.deepToString(this.tags) + &quot;)&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-7-NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor"><a href="#2-7-NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor" class="headerlink" title="2.7 @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor"></a>2.7 @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</h3><p>无参构造器、部分参数构造器、全参构造器。Lombok没法实现多种参数构造器的重载。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import lombok.AccessLevel;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.NonNull;</span><br><span class="line"></span><br><span class="line">@RequiredArgsConstructor(staticName = &quot;of&quot;)</span><br><span class="line">@AllArgsConstructor(access = AccessLevel.PROTECTED)</span><br><span class="line">public class ConstructorExample&lt;T&gt; &#123;</span><br><span class="line">  private int x, y;</span><br><span class="line">  @NonNull private T description;</span><br><span class="line">  </span><br><span class="line">  @NoArgsConstructor</span><br><span class="line">  public static class NoArgsExample &#123;</span><br><span class="line">    @NonNull private String field;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用Lombok：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> public class ConstructorExample&lt;T&gt; &#123;</span><br><span class="line">  private int x, y;</span><br><span class="line">  @NonNull private T description;</span><br><span class="line">  </span><br><span class="line">  private ConstructorExample(T description) &#123;</span><br><span class="line">    if (description == null) throw new NullPointerException(&quot;description&quot;);</span><br><span class="line">    this.description = description;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static &lt;T&gt; ConstructorExample&lt;T&gt; of(T description) &#123;</span><br><span class="line">    return new ConstructorExample&lt;T&gt;(description);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @java.beans.ConstructorProperties(&#123;&quot;x&quot;, &quot;y&quot;, &quot;description&quot;&#125;)</span><br><span class="line">  protected ConstructorExample(int x, int y, T description) &#123;</span><br><span class="line">    if (description == null) throw new NullPointerException(&quot;description&quot;);</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">    this.description = description;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class NoArgsExample &#123;</span><br><span class="line">    @NonNull private String field;</span><br><span class="line">    </span><br><span class="line">    public NoArgsExample() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-Idea下安装Lombok插件"><a href="#4-Idea下安装Lombok插件" class="headerlink" title="4. Idea下安装Lombok插件"></a>4. Idea下安装Lombok插件</h2><p>可直接通过搜索获取<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zro1xj2oj30tl0jgtbq.jpg" alt=""><br>另外还有一个关键点：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zrsvsv66j30zw0bk0v3.jpg" alt=""><br>接下来就可以编码了<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zrt7mtfyj31bu0yc146.jpg" alt=""></p><h2 id="5-Lombok的优缺点"><a href="#5-Lombok的优缺点" class="headerlink" title="5. Lombok的优缺点"></a>5. Lombok的优缺点</h2><p>优点：</p><ul><li>能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率</li><li>让代码变得简洁，不用过多的去关注相应的方法</li><li>属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等</li></ul><p>缺点：</p><ul><li>不支持多种参数构造器的重载</li><li>虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>Lombok虽然有很多优点，但Lombok更类似于一种IDE插件，项目也需要依赖相应的jar包。</p><p>Lombok依赖jar包是因为编译时要用它的注解，为什么说它又类似插件？因为在使用时，eclipse或IntelliJ IDEA都需要安装相应的插件，在编译器编译时通过操作AST（抽象语法树）改变字节码生成，变向的就是说它在改变java语法。它不像spring的依赖注入或者mybatis的ORM一样是运行时的特性，而是编译时的特性。这里我个人最感觉不爽的地方就是对插件的依赖！因为Lombok只是省去了一些人工生成代码的麻烦，但IDE都有快捷键来协助生成getter/setter等方法，也非常方便。</p>]]></content>
    
    <summary type="html">
    
      Java插件Lombok的介绍和使用方法
    
    </summary>
    
      <category term="Lombok" scheme="http://yoursite.com/categories/Lombok/"/>
    
    
      <category term="Ideal" scheme="http://yoursite.com/tags/Ideal/"/>
    
      <category term="Lombok" scheme="http://yoursite.com/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>ideal如何自定义模板</title>
    <link href="http://yoursite.com/2019/05/13/ideal%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2019/05/13/ideal如何自定义模板/</id>
    <published>2019-05-13T11:43:11.000Z</published>
    <updated>2019-05-13T11:45:39.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于模板-Template"><a href="#关于模板-Template" class="headerlink" title="关于模板(Template)"></a>关于模板(Template)</h2><blockquote><p>( Editor - Live Templates 和 Editor - General - Postfix Completion )</p></blockquote><h3 id="1-Live-Templates-实时代码模板-功能介绍"><a href="#1-Live-Templates-实时代码模板-功能介绍" class="headerlink" title="1. Live Templates(实时代码模板)功能介绍"></a>1. Live Templates(实时代码模板)功能介绍</h3><p>它的原理就是配置一些常用代码字母缩写，在输入简时可以出现你预定义的固定模式的代码，使得开发效率大提高 ，同时也可以增加个性化 。最简单的例子 就是在Java中输入sout会出现System.out.println();</p><h3 id="2-已有的常用模板"><a href="#2-已有的常用模板" class="headerlink" title="2. 已有的常用模板"></a>2. 已有的常用模板</h3><p><strong>Postfix Completion 默认如下：</strong><br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zqzumrjnj30j40g6dhp.jpg" alt=""><br><strong>Live Templates 默认如下：</strong><br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zr14wmdcj30mb0bydgq.jpg" alt=""><br>二者的区别：Live Templates 可以自定义，而 Postfix Completion 不行。有些操作二者都提供了模板，但Postfix Completion 较之 Live Templates 快0.01S。</p><p>举例：</p><ul><li>fori：可生成for循环</li><li>iter：可生成增强型for循环</li><li>itar：可生成普通for循环</li><li>list.for：可生成集合list的for循环，又如：list.fori 或 list.forr</li><li>ifn：可生成if(xxx = null)</li><li>prsf：可生成private static final</li></ul><h2 id="3-自定义模板"><a href="#3-自定义模板" class="headerlink" title="3. 自定义模板"></a>3. 自定义模板</h2><p>先定义一个模板的分组：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zrau8uirj30oe09g75r.jpg" alt=""><br>选中自定义的模板组，点击“+”来定义模板<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zrbx61caj30ix07a74p.jpg" alt=""><br>自定义步骤如下：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2zrd75ervj30k20bagmc.jpg" alt=""></p><ol><li>Abbreviation：模板的缩写</li><li>Description：模板的描述</li><li>Template text：模板的代码片段</li><li>Define：应用范围</li></ol>]]></content>
    
    <summary type="html">
    
      IDEA如何自定义模板
    
    </summary>
    
      <category term="Ideal" scheme="http://yoursite.com/categories/Ideal/"/>
    
    
      <category term="Ideal" scheme="http://yoursite.com/tags/Ideal/"/>
    
  </entry>
  
  <entry>
    <title>Redis初探</title>
    <link href="http://yoursite.com/2019/05/10/Redis%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2019/05/10/Redis初探/</id>
    <published>2019-05-10T03:36:49.000Z</published>
    <updated>2019-05-10T03:38:22.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sql对比NoSql"><a href="#Sql对比NoSql" class="headerlink" title="Sql对比NoSql"></a>Sql对比NoSql</h2><p>Sql：</p><ul><li>访问和处理关系数据库的计算机标准语言。mysql数据库，数据库以“文件形式存储在硬盘”里边。</li></ul><p>NoSql：</p><ul><li><strong>CAP： 强一致性（C），可用性（A），分区容错性（P）</strong></li><li>CAP核心理论：最多只能很好的满足两个特性</li><li>CAP的3进2：分区容错性必须要实现，只能在一致性和可用性之间权衡</li><li><strong>redis：CP</strong></li><li>网站架构的大多选择：AP</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1-什么是Redis"><a href="#1-什么是Redis" class="headerlink" title="1.  什么是Redis"></a>1.  什么是Redis</h3><p>Redis是远程数据服务，内存高速缓存数据库，支持丰富的数据结构，如String、list、hash、set、sorted set，可持久化，保证了数据安全。<strong>Redis是做数据缓存的。</strong></p><p>缓存有两种类型：数据缓存、页面缓存</p><p>使用缓存减轻数据库的负载。</p><p>在开发的时候如果有一些数据在短时间之内不会发生变化，而他们还要被频繁的访问，为了提高用户的请求速度和降低网站的负载，就把这些数据放到一个读取速度更快的介质上（或者是通过较少的计算量就可以获得该数据），该行为就称作对该数据的缓存。</p><p>该介质可以是文件、数据库、内存，内存经常用于数据缓存。</p><p>缓存的两种形式：<br> <font color="#DC143C">页面缓存</font>经常用在CMS内存管理系统里边<br> <font color="#DC143C">数据缓存</font>经常用于页面的具体数据里边</p><p>新闻页面（内容单一，集中）适合做页面缓存<br>商品页面的组成部分根据业务特点，各个部分数据比较独立，适合给他们分别做数据缓存。</p><h3 id="2-redis和memcache比较"><a href="#2-redis和memcache比较" class="headerlink" title="2.  redis和memcache比较"></a>2.  redis和memcache比较</h3><ul><li>Redis和Memcache都是将数据存放在内存中，都是<strong>内存数据库</strong>。不过memcache还可用于缓存其他东西，例如图片、视频等等。</li><li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持master-slave（主从）模型应用</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</li><li>Redis单个value的最大限制是1GB，memcached只能保存1MB的数据。</li><li>在Redis中，<strong>并不是所有的数据都一直存储在内存中</strong>的。这是和Memcached相比一个最大的区别（我个人是这么认为的）。</li></ul><h3 id="3-redis常见使用场景"><a href="#3-redis常见使用场景" class="headerlink" title="3.  redis常见使用场景"></a>3.  redis常见使用场景</h3><ul><li>会话缓存（最常用）</li><li>消息队列（如支付）</li><li>活动排行榜或计数</li><li>发布、订阅消息（消息通知）</li><li>商品列表，评论列表</li></ul><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="1-key的操作"><a href="#1-key的操作" class="headerlink" title="1.  key的操作"></a>1.  key的操作</h3><p>在redis里边，除了“\n”和空格不能作为名字的组成部分，其他内容都可以作为key的名字部分。名字长度不作要求。</p><h3 id="2-String类型操作"><a href="#2-String类型操作" class="headerlink" title="2.  String类型操作"></a>2.  String类型操作</h3><ul><li>String是redis最基本的类型</li><li>Redis的string可以包含任何数据。包括jpg图片或者序列化对象</li><li>单个value值最大上限是1G字节</li><li><p>如果只用string类型，redis就可以被看做加上持久化特性的memcache</p></li><li><p><font color="#DC143C">incr</font>：increament增长</p><pre><code>该指令可以对key进行累加1操作，默认是累加1操作，类似i++操作该指令可以针对**新key**或**已有key**进行操作新key：创建该key并累加1，其值为1已有key：key的信息值类型要求必须为整型的</code></pre></li><li><p><font color="#DC143C">decr</font>的操作模式与incr一致，不过其是减1操作</p></li><li><p><font color="#DC143C">substr</font>：对内容进行截取，包括<strong>start</strong>和<strong>end</strong>标记位置</p></li></ul><h3 id="3-数据类型List链表"><a href="#3-数据类型List链表" class="headerlink" title="3.  数据类型List链表"></a>3.  数据类型List链表</h3><p>list类型其实就是一个双向链表。通过push，pop操作从链表的头部或者尾部添加删除元素。这使得list既可以用作栈，也可以用作队列。</p><p>List类型操作：</p><ul><li><strong>lpush key string</strong>：在key对应list的头部添加字符串元素</li><li><strong>rpop key</strong>：从list的尾部删除元素，并返回删除元素</li><li><strong>llen key</strong> 返回 key：对应list的长度，key不存在返回0，如果key对应key不是list返回错误</li><li><strong>lrange key start end</strong>：返回指定区间内的元素，下标从0开始</li><li><strong>rpush key string</strong>：同上，在尾部添加</li><li><strong>lpop key</strong>：从list的头部删除元素，并返回删除元素</li><li><strong>ltrim key start end</strong>：截取list，保留指定区间内元素</li></ul><p><strong><em>list链表类型应用场合：</em></strong></p><p><font color="#DC143C">获得最新的10个登录用户信息</font>：select * from user order by logintime desc limit 10；<br>    以上sql语句可以实现用户需求，但是数据多的时候，全部数据都要受到影响，对数据库的复杂比较高。必要情况还需要给关键字段（id或logintime）设置索引，索引也比较耗费系统资源。<br>    如果通过list链表实现以上功能，可以在list链表中只保留最新的10个数据，每进来一个新数据就删除一个旧数据。每次就可以从链表中直接获得需要的数据。极大节省各方面资源消耗。</p><h3 id="4-set集合类型"><a href="#4-set集合类型" class="headerlink" title="4.  set集合类型"></a>4.  set集合类型</h3><ul><li>redis的set是string类型的<strong>无序集合</strong>。</li><li>set元素最大可以包含（2的32次方-1）个元素</li><li>关于set集合类型除了基本的添加删除操作，其他有用的操作还包括集合的取<strong>并集，交集，差集</strong>。通过这些操作可以很容易的实现sns的<font color="#DC143C">好友推荐功能</font>。</li><li>注意：每个集合中的<strong>各个元素不能重复</strong></li></ul><p>set类型操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">·sadd key member：添加一个string元素到key对应的set集合中，成功返回1，如果元素已经在                        set集合中，返回0，key对应的set不存在返回错误。</span><br><span class="line">·sren key member [member]:从key对应set中移除给定元素，成功返回1</span><br><span class="line">·smove p1 p2 member：从p1对应set中移除member并添加到p2对应set中</span><br><span class="line">·scard key：返回set元素个数</span><br><span class="line">·sismember key member：判断set的元素个数</span><br><span class="line">·sinter key1 key2...keyN：返回所有给定key的交集</span><br><span class="line">·sunion key1 key2...keyN：返回所有给定并集</span><br><span class="line">·sdiff key1 key2...keyN:返回所有给定key的差集</span><br><span class="line">·smembers key：返回key对应set的所有元素，结果是无序的。</span><br></pre></td></tr></table></figure></p><p><strong><em>set类型应用场合</em></strong>：<strong>qq好友推荐</strong></p><p>Tom朋友圈（与某某是好友）：mary jack xiaoming wang5 wang6<br>Linken朋友圈（与某某是好友）：yuehan daxiang luce wang5 wang6<br>创建Tom的朋友圈：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2w118a1w8j309104kmx4.jpg" alt=""><br>创建linken朋友圈：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2w149rpwxj309y06c0sr.jpg" alt=""><br>对两个set取交集和并集：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2w14svm04j309w049749.jpg" alt=""><br>取差集：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2w151cr1pj309i03o0so.jpg" alt=""></p><h3 id="5-Sort-Set排序集合类型"><a href="#5-Sort-Set排序集合类型" class="headerlink" title="5.  Sort Set排序集合类型"></a>5.  Sort Set排序集合类型</h3><ul><li>和set一样sorted set也是string类型元素的集合，不同的是每个元素都会关联一个<strong>权</strong>。通过<strong>权值</strong>可以有序的获取集合中的元素。</li><li>排序集合中的每个元素都是<strong>值、权的组合</strong>，之前的set集合类型每个元素就只有一个值。</li></ul><p>sort set排序类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">·zadd key score member：添加元素到集合，元素在集合中存在则更新对应score。</span><br><span class="line">·zren key member：删除指定元素，1表示成功，如果元素不存在返回0</span><br><span class="line">·zincrby key incr member：按照incr幅度增加对应member的score值，返回score值</span><br><span class="line">·zrank key member：返回指定元素在集合中的排名（下标），集合中元素是按score从小到大排序      的。</span><br><span class="line">·zrevrank key member：同上，但是集合中元素是按score从大到小排序的</span><br><span class="line">·zrange key start end：类似lrange操作从集合中去指定区间的元素。返回的是有序结果</span><br><span class="line">·zrevrange key start end：同上，返回结果是按score逆序的。</span><br><span class="line">·zcard key：返回集合中元素个数。</span><br><span class="line">·zscore key element：返回给定元素对应的score</span><br><span class="line">·zrenrangeburank key min max：删除集合中排名在给定区间的元素。</span><br></pre></td></tr></table></figure></p><p><strong><em>Sort set类型适合场合：</em></strong></p><p><font color="#DC143C">获得热门帖子（回复量）信息</font>：select * from message order by backnum desc limit 5；（以上需求可以通过简单的sql语句实现，但是sql语句比较耗费mysql数据库资源）</p><p>案例：获得热门帖子信息（前5）：<br>我们只做一个sort set排序集合，里边只保留5个元素信息，该5个元素是回复量最高的每个帖子被回复的时候，都有机会进入该集合里边，但是只有回复量最高的前5个帖子会存在于该集合，回复量低的就被删除。</p><h3 id="6-数据类型Hash"><a href="#6-数据类型Hash" class="headerlink" title="6.  数据类型Hash"></a>6.  数据类型Hash</h3><ul><li>是一个键值对集合，是string类型的field和value的映射表，适合<strong>存储对象</strong></li><li>hash数据类型存储的数据与mysql数据库中存储的一条记录极为相似。</li></ul><h2 id="持久化功能"><a href="#持久化功能" class="headerlink" title="持久化功能"></a>持久化功能</h2><p>Redis为了内部数据的安全考虑，会把本身的数据以<strong>文件</strong>形式保存到硬盘中一份，在服务器重启之后会把硬盘的数据恢复到内存（redis）的里边。</p><p>数据保存到硬盘的过程就称为“持久化”效果。</p><h3 id="1-snap-shotting快照持久化（RDB持久化）（保存结果）"><a href="#1-snap-shotting快照持久化（RDB持久化）（保存结果）" class="headerlink" title="1.  snap shotting快照持久化（RDB持久化）（保存结果）"></a>1.  snap shotting快照持久化（RDB持久化）（保存结果）</h3><ul><li>该持久化默认开启，一次性把redis中全部的数据保存一份存储到硬盘中，适合大规模数据恢复，但数据一致性和完整性差</li><li>手动发起快照持久化指令：<strong>bgsave</strong>指令</li><li>默认的文件名为：<strong>dump.rdb</strong></li><li>快照持久化的备份频率：<br>save 900 1 #900秒内如果超过1个key被修改，则发起快照保存<br>save 300 10 #300秒超过10个key被修改，发起快照保存<br>save 60 10000 #60秒超过10000个key被修改，发起快照保存</li></ul><h3 id="2-append-only-file（AOF持久化）（保存操作）"><a href="#2-append-only-file（AOF持久化）（保存操作）" class="headerlink" title="2.  append only file（AOF持久化）（保存操作）"></a>2.  append only file（AOF持久化）（保存操作）</h3><ul><li>本质：把用户执行的每个“写”指令（添加、删除、修改）都备份到文件中，还原数据的时候就是执行具体写指令而已。</li><li>开启AOF持久化（会清空redis内部的数据）</li><li>默认没有开启</li><li>手动开启，完整性高，但内容较多的情况下会影响恢复效率</li></ul><h3 id="3-应用场合"><a href="#3-应用场合" class="headerlink" title="3.  应用场合"></a>3.  应用场合</h3><ul><li>若只是使用redis作为缓存，可关闭持久化</li><li>若使用持久化功能，rdb与aof都建议开启</li></ul><h3 id="4-RDB持久化和AOF持久化的对比"><a href="#4-RDB持久化和AOF持久化的对比" class="headerlink" title="4.  RDB持久化和AOF持久化的对比"></a>4.  RDB持久化和AOF持久化的对比</h3><p>RDB：</p><ul><li>优点：节省磁盘空间，恢复速度快</li><li>缺点：数据庞大时仍然消耗性能，如果redis down掉会丢失最后一次快照的所有更改</li></ul><p>AOF:</p><ul><li>优点：丢失数据概率更低，日志文件可读性高，可处理错误的操作</li><li>缺点 ：相比RDB更占空间，恢复/备份更慢，读写同步会有性能压力</li></ul><h2 id="主从模式-master—slave"><a href="#主从模式-master—slave" class="headerlink" title="主从模式 master—slave"></a>主从模式 master—slave</h2><ul><li>为了降低每个redis服务器的负载，可以多设置几个，并做主从模式，一个服务器负责“写”数据，其他服务器负责“读”数据，主服务器数据会“自动”同步给从服务器。</li><li>Slave服务器默认禁止写操作。</li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ul><li>主从复制  <strong>作用：读写分离，容灾恢复</strong></li><li>配从不配主。常用三招：一主二仆、薪火相传、反客为主</li></ul><h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><ul><li>主从切换，多哨兵模式</li></ul>]]></content>
    
    <summary type="html">
    
      Redis初探
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="NoSql" scheme="http://yoursite.com/tags/NoSql/"/>
    
  </entry>
  
  <entry>
    <title>Ideal项目如何与github同步(pull,push)</title>
    <link href="http://yoursite.com/2019/05/09/Ideal%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E4%B8%8Egithub%E5%90%8C%E6%AD%A5-pull-push/"/>
    <id>http://yoursite.com/2019/05/09/Ideal项目如何与github同步-pull-push/</id>
    <published>2019-05-09T07:52:55.000Z</published>
    <updated>2019-05-09T07:55:11.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从GitHub更新项目到Ideal（pull）"><a href="#从GitHub更新项目到Ideal（pull）" class="headerlink" title="从GitHub更新项目到Ideal（pull）"></a>从GitHub更新项目到Ideal（pull）</h2><ol><li>右击项目名 –&gt; Git –&gt; Repository –&gt; pull</li></ol><h2 id="从Ideal更新项目到GitHub（push）"><a href="#从Ideal更新项目到GitHub（push）" class="headerlink" title="从Ideal更新项目到GitHub（push）"></a>从Ideal更新项目到GitHub（push）</h2><ol><li>右击项目名 –&gt; Git –&gt; commit diretory</li><li>右击项目名 –&gt; Git –&gt; Repository –&gt; push</li></ol>]]></content>
    
    <summary type="html">
    
      Ideal使用(pull,push)命令使本地项目与github端同步
    
    </summary>
    
      <category term="Ideal" scheme="http://yoursite.com/categories/Ideal/"/>
    
    
      <category term="Ideal" scheme="http://yoursite.com/tags/Ideal/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA新建Maven web项目</title>
    <link href="http://yoursite.com/2019/05/09/IntelliJ-IDEA%E6%96%B0%E5%BB%BAMaven-web%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/05/09/IntelliJ-IDEA新建Maven-web项目/</id>
    <published>2019-05-09T07:50:07.000Z</published>
    <updated>2019-05-09T07:56:36.217Z</updated>
    
    <content type="html"><![CDATA[<p>第一次使用Intellij idea，有诸多不熟悉，之处，网上很多教程千差万别，为日后少走弯路，特此记录。</p><p>步骤一：首先先创建一个project，打开-File-New-Project </p><p>步骤二：你要选择maven然后按照下面图片 的指示操作就可以了<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2v1hiedd3j30jv0g3q5d.jpg" alt=""><br>点击next按钮<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2v1iidlgtj30iw0670t3.jpg" alt=""><br>点击next，该图为示例图片，XX为你自己设置的项目名，如im，<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2v1jhtgvzj30me0iz3z4.jpg" alt=""><br>之后点击finish，等idea完全加载完成后，就可以看到项目已经生成了（有时也缺少下图中的resources目录，也需要手动创建）<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2v1la0jfjj30ic0h7ab6.jpg" alt=""><br>步骤三：配置tocat服务器。点击那个倒立的三角形，然后点击Edit Configurations<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2v1owauzdj30uc0k8q5s.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2v1p810f9j30uc0kj42c.jpg" alt=""><br>配置artifacts，标签由Server跳到Deploment，点击小铅笔一样的图标对artifacts进行配置<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2v1t6fu1mj30ty0o9wf7.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      IntelliJ IDEA新建Maven web项目并配置tomcat服务器
    
    </summary>
    
      <category term="Ideal" scheme="http://yoursite.com/categories/Ideal/"/>
    
    
      <category term="Ideal" scheme="http://yoursite.com/tags/Ideal/"/>
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
</feed>
