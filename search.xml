<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>消息中间件（二）MQ使用场景</title>
      <link href="/2019/05/22/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89MQ%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/05/22/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89MQ%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="一、消息队列概述"><a href="#一、消息队列概述" class="headerlink" title="一、消息队列概述"></a>一、消息队列概述</h2><p>消息队列中间件是分布式系统中重要的组件，主要解决<strong>应用解耦</strong>，<strong>异步消息</strong>，<strong>流量削锋</strong>等问题，实现高性能，高可用，可伸缩和最终一致性架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ</p><h2 id="二、消息队列应用场景"><a href="#二、消息队列应用场景" class="headerlink" title="二、消息队列应用场景"></a>二、消息队列应用场景</h2><p>以下介绍消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋，日志处理和消息通讯五个场景。</p><h3 id="2-1异步处理"><a href="#2-1异步处理" class="headerlink" title="2.1异步处理"></a>2.1异步处理</h3><p>场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式</p><p>a、串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a4yfuhc7j30ef03o3yf.jpg" alt=""><br>b、并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a4zgpr1ej30b305wq2x.jpg" alt=""><br>假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。<br>因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）</p><p>小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？</p><p>答案：引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a50rebq1j30fu059mx7.jpg" alt=""><br>按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了两倍。</p><h3 id="2-2应用解耦"><a href="#2-2应用解耦" class="headerlink" title="2.2应用解耦"></a>2.2应用解耦</h3><p>场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a52tmjlcj307y031a9w.jpg" alt=""><br>传统模式的缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合。</p><p>如何解决以上问题呢？引入应用消息队列后的方案，如下图：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a53olzr4j309m04za9y.jpg" alt=""><br><strong>订单系统</strong>：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功</p><p><strong>库存系统</strong>：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作<br>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦</p><h3 id="2-3流量削锋"><a href="#2-3流量削锋" class="headerlink" title="2.3流量削锋"></a>2.3流量削锋</h3><p>流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。</p><p><strong>应用场景</strong>：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。 既可以<strong>控制活动的人数</strong>，又可以<strong>缓解短时间内高流量压垮应用</strong>。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a56diqs2j30c4035glj.jpg" alt=""><br>用户的请求，服务器接收后，首先写入消息队列。<strong>假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面</strong>。</p><p>秒杀业务根据消息队列中的请求信息，再做后续处理。</p><h3 id="2-4日志处理"><a href="#2-4日志处理" class="headerlink" title="2.4日志处理"></a>2.4日志处理</h3><p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a57pr1l3j30co031dfq.jpg" alt=""><br>日志采集客户端，负责日志数据采集，定时写受写入Kafka队列</p><p>Kafka消息队列，负责日志数据的接收，存储和转发</p><p>日志处理应用：订阅并消费kafka队列中的日志数据 </p><h3 id="2-5消息通讯"><a href="#2-5消息通讯" class="headerlink" title="2.5消息通讯"></a>2.5消息通讯</h3><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</p><p>点对点通讯：客户端A和客户端B使用同一队列，进行消息通讯。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a59zqqpnj30ba0310sl.jpg" alt=""><br>聊天室通讯：客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a5aii01qj30ba039mx1.jpg" alt=""><br>以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。</p><h2 id="三、消息中间件示例"><a href="#三、消息中间件示例" class="headerlink" title="三、消息中间件示例"></a>三、消息中间件示例</h2><h3 id="3-1电商系统"><a href="#3-1电商系统" class="headerlink" title="3.1电商系统"></a>3.1电商系统</h3><p><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a5c0646cj30b704sta2.jpg" alt=""><br>消息队列采用高可用，可持久化的消息中间件。比如Active MQ，Rabbit MQ，Rocket Mq。</p><p>（1）应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性）<br>（2）扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。<br>（3）消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。</p><h3 id="3-2日志收集系统"><a href="#3-2日志收集系统" class="headerlink" title="3.2日志收集系统"></a>3.2日志收集系统</h3><p><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a5dr4nyij30f505kq52.jpg" alt=""><br>分为Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分组成。</p><ul><li>Zookeeper注册中心，提出负载均衡和地址查找服务</li><li>日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列</li><li>Kafka集群：接收，路由，存储，转发等消息处理</li><li>Storm集群：与OtherApp处于同一级别，采用拉的方式消费队列中的数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件（一）MQ详解及四大MQ比较</title>
      <link href="/2019/05/22/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89MQ%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%9B%9B%E5%A4%A7MQ%E6%AF%94%E8%BE%83/"/>
      <url>/2019/05/22/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89MQ%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%9B%9B%E5%A4%A7MQ%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h2 id="一、消息中间件相关知识"><a href="#一、消息中间件相关知识" class="headerlink" title="一、消息中间件相关知识"></a>一、消息中间件相关知识</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的<strong>ActiveMQ</strong>、<strong>RabbitMQ</strong>，炙手可热的<strong>Kafka</strong>，阿里巴巴自主开发RocketMQ等。</p><h3 id="2、消息中间件的组成"><a href="#2、消息中间件的组成" class="headerlink" title="2、消息中间件的组成"></a>2、消息中间件的组成</h3><h4 id="2-1-Broker"><a href="#2-1-Broker" class="headerlink" title="2.1 Broker"></a>2.1 Broker</h4><p>消息服务器，作为server提供消息核心服务</p><h4 id="2-2-Producer"><a href="#2-2-Producer" class="headerlink" title="2.2 Producer"></a>2.2 Producer</h4><p>消息生产者，业务的发起方，负责生产消息传输给broker，</p><h4 id="2-3-Consumer"><a href="#2-3-Consumer" class="headerlink" title="2.3 Consumer"></a>2.3 Consumer</h4><p>消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</p><h4 id="2-4-Topic"><a href="#2-4-Topic" class="headerlink" title="2.4 Topic"></a>2.4 Topic</h4><p>主题，<strong>发布订阅模式</strong>下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的<strong>广播</strong></p><h4 id="2-5-Queue"><a href="#2-5-Queue" class="headerlink" title="2.5 Queue"></a>2.5 Queue</h4><p>队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</p><h4 id="2-6-Message"><a href="#2-6-Message" class="headerlink" title="2.6 Message"></a>2.6 Message</h4><p>消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</p><h3 id="3、消息中间件模式分类"><a href="#3、消息中间件模式分类" class="headerlink" title="3、消息中间件模式分类"></a>3、消息中间件模式分类</h3><h4 id="3-1-点对点"><a href="#3-1-点对点" class="headerlink" title="3.1 点对点"></a>3.1 点对点</h4><p>PTP点对点：使用<strong>queue</strong>作为通信载体<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a44tfdaij30ps0fraev.jpg" alt=""><br>说明：<br>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。<br>消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p><h4 id="3-2-发布-订阅"><a href="#3-2-发布-订阅" class="headerlink" title="3.2 发布/订阅"></a>3.2 发布/订阅</h4><p>Pub/Sub发布订阅（广播）：使用<strong>topic</strong>作为通信载体<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a467j43dj30qa0gmtf8.jpg" alt=""><br>说明：<br>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。</p><p>queue与topic的不同之处：</p><ul><li><p>queue 实现了负载均衡，将producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者。 </p></li><li><p>topic 实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到一个消息的拷贝。</p></li></ul><h3 id="4、消息中间件的优势"><a href="#4、消息中间件的优势" class="headerlink" title="4、消息中间件的优势"></a>4、消息中间件的优势</h3><h4 id="4-1-系统解耦"><a href="#4-1-系统解耦" class="headerlink" title="4.1 系统解耦"></a>4.1 系统解耦</h4><p>交互系统之间没有直接的调用关系，只是通过消息传输，故系统侵入性不强，耦合度低。</p><h4 id="4-2-提高系统响应时间"><a href="#4-2-提高系统响应时间" class="headerlink" title="4.2 提高系统响应时间"></a>4.2 提高系统响应时间</h4><p>例如原来的一套逻辑，完成支付可能涉及先修改订单状态、计算会员积分、通知物流配送几个逻辑才能完成；通过MQ架构设计，就可将紧急重要（需要立刻响应）的业务放到该调用方法中，响应要求不高的使用消息队列，放到MQ队列中，供消费者处理。</p><h4 id="4-3-为大数据处理架构提供服务"><a href="#4-3-为大数据处理架构提供服务" class="headerlink" title="4.3 为大数据处理架构提供服务"></a>4.3 为大数据处理架构提供服务</h4><p>通过消息作为整合，大数据的背景下，消息队列还与实时处理架构整合，为数据处理提供性能支持。</p><h4 id="4-4-Java消息服务——JMS"><a href="#4-4-Java消息服务——JMS" class="headerlink" title="4.4 Java消息服务——JMS"></a>4.4 Java消息服务——JMS</h4><p>Java消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 </p><p>JMS中的P2P和Pub/Sub消息模式：点对点（point to point， queue）与发布订阅（publish/subscribe，topic）最初是由JMS定义的。这两种模式主要区别或解决的问题就是发送到队列的消息能否重复消费(多订阅)。</p><h3 id="5、消息中间件的应用场景"><a href="#5、消息中间件的应用场景" class="headerlink" title="5、消息中间件的应用场景"></a>5、消息中间件的应用场景</h3><h4 id="5-1-异步通信"><a href="#5-1-异步通信" class="headerlink" title="5.1 异步通信"></a>5.1 异步通信</h4><p>有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h4 id="5-2-解耦"><a href="#5-2-解耦" class="headerlink" title="5.2 解耦"></a>5.2 解耦</h4><p>降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p><h4 id="5-3-冗余"><a href="#5-3-冗余" class="headerlink" title="5.3 冗余"></a>5.3 冗余</h4><p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p><h4 id="5-4-扩展性"><a href="#5-4-扩展性" class="headerlink" title="5.4 扩展性"></a>5.4 扩展性</h4><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容。</p><h4 id="5-5-过载保护"><a href="#5-5-过载保护" class="headerlink" title="5.5 过载保护"></a>5.5 过载保护</h4><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p><h4 id="5-6-可恢复性"><a href="#5-6-可恢复性" class="headerlink" title="5.6 可恢复性"></a>5.6 可恢复性</h4><p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p><h4 id="5-7-顺序保证"><a href="#5-7-顺序保证" class="headerlink" title="5.7 顺序保证"></a>5.7 顺序保证</h4><p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。</p><h4 id="5-8-缓冲"><a href="#5-8-缓冲" class="headerlink" title="5.8 缓冲"></a>5.8 缓冲</h4><p>在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。</p><h4 id="5-9-数据流处理"><a href="#5-9-数据流处理" class="headerlink" title="5.9 数据流处理"></a>5.9 数据流处理</h4><p>分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择。</p><h3 id="6、常见消息中间件MQ介绍"><a href="#6、常见消息中间件MQ介绍" class="headerlink" title="6、常见消息中间件MQ介绍"></a>6、常见消息中间件MQ介绍</h3><h4 id="6-1-RocketMQ"><a href="#6-1-RocketMQ" class="headerlink" title="6.1 RocketMQ"></a>6.1 RocketMQ</h4><p>阿里系下开源的一款分布式、队列模型的消息中间件，原名Metaq，3.0版本名称改为RocketMQ，是阿里参照kafka设计思想使用java实现的一套mq。同时将阿里系内部多款mq产品（Notify、metaq）进行整合，只维护核心功能，去除了所有其他运行时依赖，保证核心功能最简化，在此基础上配合阿里上述其他开源产品实现不同场景下mq的架构，目前主要<strong>多用于订单交易系统</strong>。</p><p>具有以下特点：</p><ul><li>能够保证严格的消息顺序</li><li>提供针对消息的过滤功能</li><li>提供丰富的消息拉取模式</li><li>高效的订阅者水平扩展能力</li><li>实时的消息订阅机制</li><li>亿级消息堆积能力</li></ul><p>官方提供了一些不同于kafka的对比差异：<br><a href="https://rocketmq.apache.org/docs/motivation/" target="_blank" rel="noopener">https://rocketmq.apache.org/docs/motivation/</a></p><h4 id="6-2-RabbitMQ"><a href="#6-2-RabbitMQ" class="headerlink" title="6.2 RabbitMQ"></a>6.2 RabbitMQ</h4><p>使用Erlang编写的一个开源的消息队列，本身支持很多的协议，也正是如此，使得它变的非常重量级。更适合于企业级的开发。同时实现了Broker架构，核心思想是<strong>生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队</strong>。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。</p><h4 id="6-3-ActiveMQ"><a href="#6-3-ActiveMQ" class="headerlink" title="6.3 ActiveMQ"></a>6.3 ActiveMQ</h4><p>Apache下的一个子项目。使用Java完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，少量代码就可以高效地实现高级应用场景。可插拔的传输协议支持，比如：in-VM, TCP, SSL, NIO, UDP, multicast, JGroups and JXTA transports。RabbitMQ、ZeroMQ、ActiveMQ均支持常用的多种语言客户端 C++、Java、.Net,、Python、 Php、 Ruby等。</p><h4 id="6-4-Redis"><a href="#6-4-Redis" class="headerlink" title="6.4 Redis"></a>6.4 Redis</h4><p>使用C语言开发的一个<strong>Key-Value的NoSQL数据库</strong>，开发维护很活跃，虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：<strong>入队时，当数据比较小时Redis的性能要高于RabbitMQ</strong>，而如果数据大小超过了10K，Redis则慢的无法忍受；<strong>出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</strong></p><h4 id="7-5-Kafka"><a href="#7-5-Kafka" class="headerlink" title="7.5 Kafka"></a>7.5 Kafka</h4><p>Apache下的一个子项目，使用scala实现的一个高性能分布式<strong>Publish/Subscribe消息队列系统</strong>，具有以下特性：</p><ul><li>快速持久化：通过磁盘顺序读写与零拷贝机制，可以在O(1)的系统开销下进行消息持久化；</li><li>高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；</li><li>高堆积：支持topic下消费者较长时间离线，消息堆积量大；</li><li>完全的分布式系统：Broker、Producer、Consumer都原生自动支持分布式，依赖zookeeper自动实现复杂均衡；</li><li>支持Hadoop数据并行加载：对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案<h4 id="7-6-ZeroMQ"><a href="#7-6-ZeroMQ" class="headerlink" title="7.6 ZeroMQ"></a>7.6 ZeroMQ</h4>号称最快的消息队列系统，专门为高吞吐量/低延迟的场景开发，在<strong>金融界的应用中经常使用</strong>，偏重于实时数据通信场景。ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，开发成本高。因此ZeroMQ具有一个独特的非中间件的模式，更像一个socket library，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序本身就是使用ZeroMQ API完成逻辑服务的角色。但是ZeroMQ仅提供非持久性的队列，如果down机，数据将会丢失。如：Twitter的Storm中使用ZeroMQ作为数据流的传输。</li></ul><h2 id="二、主要消息中间件的比较"><a href="#二、主要消息中间件的比较" class="headerlink" title="二、主要消息中间件的比较"></a>二、主要消息中间件的比较</h2><p><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g3a4plh04xj30py0nq42h.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收器</title>
      <link href="/2019/05/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2019/05/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h2><p>Java虚拟机规范并没有规定垃圾收集器应该如何实现，用户可以根据系统特点对各个区域所使用的收集器进行组合使用。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g3a1qruuapj30fh09hq2v.jpg" alt=""><br>上图展示了7种不同分代的收集器，如果两两之间存在连线，说明可以组合使用。</p><h2 id="1、Serial收集器（串行GC）"><a href="#1、Serial收集器（串行GC）" class="headerlink" title="1、Serial收集器（串行GC）"></a>1、Serial收集器（串行GC）</h2><p>Serial 是一个采用单个线程并基于复制算法工作在新生代的收集器，进行垃圾收集时，必须暂停其他所有的工作线程。对于单CPU环境来说，Serial由于没有线程交互的开销，可以很高效的进行垃圾收集动作，是Client模式下新生代默认的收集器。</p><h2 id="2、ParNew收集器（并行GC）"><a href="#2、ParNew收集器（并行GC）" class="headerlink" title="2、ParNew收集器（并行GC）"></a>2、ParNew收集器（并行GC）</h2><p>ParNew其实是serial的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial一样。</p><h2 id="3、Parallel-Scavenge收集器（并行回收GC）"><a href="#3、Parallel-Scavenge收集器（并行回收GC）" class="headerlink" title="3、Parallel Scavenge收集器（并行回收GC）"></a>3、Parallel Scavenge收集器（并行回收GC）</h2><p>Parallel Scavenge是一个采用多线程基于复制算法并工作在新生代的收集器，其关注点在于达到一个可控的吞吐量，经常被称为“吞吐量优先”的收集器。</p><p>吞吐量 = 用户代码运行时间 /（用户代码运行时间 + 垃圾收集时间）</p><p>Parallel Scavenge提供了两个参数用于精确控制吞吐量：<br>1、-XX：MaxGCPauseMillis 设置垃圾收集的最大停顿时间<br>2、-XX：GCTimeRatio 设置吞吐量大小</p><h2 id="4、Serial-Old收集器-MSC（串行GC）"><a href="#4、Serial-Old收集器-MSC（串行GC）" class="headerlink" title="4、Serial Old收集器 MSC（串行GC）"></a>4、Serial Old收集器 MSC（串行GC）</h2><p>Serial Old 是一个采用单线程基于标记-整理算法并工作在老年代的收集器，是<strong>Client模式</strong>下老年代默认的收集器。</p><h2 id="5、Parallel-Old收集器（并行GC）"><a href="#5、Parallel-Old收集器（并行GC）" class="headerlink" title="5、Parallel Old收集器（并行GC）"></a>5、Parallel Old收集器（并行GC）</h2><p>Parallel Old是一个采用多线程基于标记-整理算法并工作在老年代的收集器。在注重吞吐量以及CPU资源敏感的场合，可以优先考虑<strong>Parallel Scavenge和Parallel Old</strong>的收集器组合。</p><h2 id="6、CMS收集器（并发GC）"><a href="#6、CMS收集器（并发GC）" class="headerlink" title="6、CMS收集器（并发GC）"></a>6、CMS收集器（并发GC）</h2><p>CMS(Concurrent Mark Sweep)是一种以获取最短回收停顿时间为目标的收集器，工作在老年代，基于“<strong>标记-清除</strong>”算法实现，整个过程分为以下4步：</p><p>1、<strong>初始标记</strong>：这个过程只是标记以下GC Roots能够直接关联的对象，但是仍然会Stop The World；<br>2、<strong>并发标记</strong>：进行GC Roots Tracing的过程，可以和用户线程一起工作。<br>3、<strong>重新标记</strong>：用于修正并发标记期间由于用户程序继续运行而导致标记产生变动的那部分记录，这个过程会暂停所有线程，但其停顿时间远比并发标记的时间短；<br>4、<strong>并发清理</strong>：可以和用户线程一起工作。</p><p>CMS收集器的缺点：</p><p>1、对CPU资源比较敏感，在并发阶段，虽然不会导致用户线程停顿，但是会占用一部分线程资源，降低系统的总吞吐量。<br>2、无法处理浮动垃圾，在并发清理阶段，用户线程的运行依然会产生新的垃圾对象，这部分垃圾只能在下一次GC时收集。<br>3、CMS是基于标记-清除算法实现的，意味着收集结束后会造成大量的<strong>内存碎片</strong>，可能导致出现老年代剩余空间很大，却无法找到足够大的连续空间分配当前对象，不得不提前触发一次Full GC。</p><p>JDK1.5实现中，当老年代空间使用率达到68%时，就会触发CMS收集器，如果应用中老年代增长不是太快，可以通过-XX:CMSInitiatingOccupancyFraction参数提高触发百分比，从而降低内存回收次数提高系统性能。</p><p>JDK1.6实现中，触发CMS收集器的阈值已经提升到92%，要是CMS运行期间预留的内存无法满足用户线程需要，会出现一次”Concurrent Mode Failure”失败，这是虚拟机会启动Serial Old收集器对老年代进行垃圾收集，当然，这样应用的停顿时间就更长了，所以这个阈值也不能设置的太高，如果导致了”Concurrent Mode Failure”失败，反而会降低性能，至于如何设置这个阈值，还得长时间的对老年代空间的使用情况进行监控。</p><h2 id="7、G1收集器"><a href="#7、G1收集器" class="headerlink" title="7、G1收集器"></a>7、G1收集器</h2><p>G1（Garbage First）是JDK1.7提供的一个工作在新生代和老年代的收集器，基于“标记-整理”算法实现，在收集结束后可以<strong>避免内存碎片</strong>问题。</p><p>G1优点：<br>1、并行与并发：充分利用多CPU来缩短Stop The World的停顿时间；<br>2、分代收集：不需要其他收集配合就可以管理整个Java堆，采用不同的方式处理新建的对象、已经存活一段时间和经历过多次GC的对象获取更好的收集效果;<br>3、<strong>空间整合</strong>：与CMS的”标记-清除”算法不同，G1在运行期间不会产生内存空间碎片，有利于应用的长时间运行，且分配大对象时，不会导致由于无法申请到足够大的连续内存而提前触发一次Full GC;<br>4、<strong>停顿预测</strong>：G1中可以建立可预测的停顿时间模型，能让使用者明确指定在M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><p>使用G1收集器时，Java堆的内存布局与其他收集器有很大区别，整个Java堆会被划分为<strong>多个大小相等的独立区域Region</strong>，新生代和老年代不再是物理隔离了，都是一部分Region（不需要连续）的集合。G1会跟踪各个Region的垃圾收集情况（回收空间大小和回收消耗的时间），维护一个优先列表，根据允许的收集时间，优先回收价值最大的Region，避免在整个Java堆上进行全区域的垃圾回收，确保了G1收集器可以在有限的时间内尽可能收集更多的垃圾。</p><p>不过问题来了：使用G1收集器，一个对象分配在某个Region中，可以和Java堆上任意的对象有引用关系，那么如何判定一个对象是否存活，是否需要扫描整个Java堆？其实这个问题在之前收集器中也存在，如果回收新生代的对象时，不得不同时扫描老年代的话，会大大降低Minor GC的效率。</p><p>针对这种情况，虚拟机提供了一个解决方案：G1收集器中Region之间的对象引用关系和其他收集器中新生代与老年代之间的对象引用关系被保存在Remenbered Set数据结构中，用来避免全堆扫描。G1中每个Region都有一个对应的Remenbered Set，当虚拟机发现程序对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于相同的Region中，如果不是，则通过CardTable把相关引用信息记录到被引用对象所属Region的Remenbered Set中。</p>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中常见的OOM</title>
      <link href="/2019/05/21/Java%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84OOM/"/>
      <url>/2019/05/21/Java%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84OOM/</url>
      
        <content type="html"><![CDATA[<h2 id="Java中常见的OOM异常"><a href="#Java中常见的OOM异常" class="headerlink" title="Java中常见的OOM异常"></a>Java中常见的OOM异常</h2><h3 id="1-栈溢出"><a href="#1-栈溢出" class="headerlink" title="1.栈溢出"></a>1.栈溢出</h3><blockquote><p>java.lang.StackOverflowError</p></blockquote><p>这是由于线程请求的栈深度大于虚拟机所允许的最大深度，无法压入新的栈帧，这时可以检查一下代码中是否存在死循环的<strong>递归</strong>调用。</p><h3 id="2-堆溢出"><a href="#2-堆溢出" class="headerlink" title="2.堆溢出"></a>2.堆溢出</h3><blockquote><p>java.lang.OutOfMemoryError: Java heap space</p></blockquote><p>堆空间无法给新的对象分配内存空间且GC一次后仍然无法分配足够的空间时会导致堆溢出。（对象太多、太大）</p><h3 id="3-元空间溢出"><a href="#3-元空间溢出" class="headerlink" title="3.元空间溢出"></a>3.元空间溢出</h3><blockquote><p>java.lang.OutOfMemoryError: Metaspace</p></blockquote><p> 在JDK1.8后，Metaspace 代替永久代，存放了以下的信息：虚拟机加载的类的信息、常量池、静态变量、即时编译后的代码。若不断生成类，往元空间灌，会造成元空间溢出。</p><h3 id="4-无法创建新进程"><a href="#4-无法创建新进程" class="headerlink" title="4.无法创建新进程"></a>4.无法创建新进程</h3><blockquote><p>java.lang.OutOfMemoryError:unable to create natvie thread</p></blockquote><p>高并发请求服务器时经常出现的异常，准确的说，该native thread异常与对应的平台有关。</p><p>导致原因：</p><ol><li>应用创建过多的线程，超过系统承载极限</li><li>服务器不允许创建这么多线程，linux默认单个进程可以创建的线程数为1024个</li></ol><p>解决方法：</p><ol><li>降低应用程序线程数量</li><li>对于那些确实需要的程序，修改Linux服务器的配置，扩大默认限制</li></ol><h3 id="5-GC回收异常"><a href="#5-GC回收异常" class="headerlink" title="5.GC回收异常"></a>5.GC回收异常</h3><blockquote><p>ava.lang:OutOfMemoryError: GC overhead limit exceeded</p></blockquote><p>GC回收时间长时会抛出OutOfMemoryError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存，连续多次GC都只回收了不到2%的极端情况下才会抛出。</p><p>假设不抛出GC overhead limit错误会发生什么情况呢？<br>那就是GC清理的这么点内存很快会再次填满，迫使GC再次执行，这样就形成恶性循环，CPU使用率一直是100%，而GC缺没有任何成果。</p><h3 id="6-本地直接内存溢出"><a href="#6-本地直接内存溢出" class="headerlink" title="6.本地直接内存溢出"></a>6.本地直接内存溢出</h3><blockquote><p>java.lang.OutOfMemoryError: Direct buffer memory</p></blockquote><p>写NIO程序时经常使用ByteBuffer来读取或写入数据，这是一种基于通道和缓冲区的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过DirectByteBuffer对象作为这块内存的引用进行操作。这样可以在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><blockquote><p>ByteBuffer.allocate()  分配JVM内存，属于GC范围，速度较慢</p></blockquote><blockquote><p>ByteBuffer.allocateDirect()  分配OS本地内存，不属于GC，速度较快</p></blockquote><p>但如果不断分配本地内存，堆内存很少使用，JVM不需要GC，DirectByteBuffer对象们就不会被回收，这时候，堆内存充足，但本地内存很可能使用光了，再次尝试分配本地内存就会出现OOM Error。</p>]]></content>
      
      
      <categories>
          
          <category> OOM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.8下String.intern()分析</title>
      <link href="/2019/05/21/JDK1-8%E4%B8%8BString-intern-%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/21/JDK1-8%E4%B8%8BString-intern-%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一-String-intern-分析"><a href="#一-String-intern-分析" class="headerlink" title="一. String.intern()分析"></a>一. String.intern()分析</h2><p> 判断这个常量是否存在于常量池。<br>  如果存在<br>   判断存在内容是引用还是常量，<br>    如果是引用，<br>     返回引用地址指向堆空间对象，<br>    如果是常量，<br>     直接返回常量池常量<br>  如果不存在，<br>   将当前对象引用复制到常量池,并且返回的是当前对象的引用</p><h2 id="二-创建字符串分析"><a href="#二-创建字符串分析" class="headerlink" title="二. 创建字符串分析"></a>二. 创建字符串分析</h2><h3 id="1-只在常量池上创建常量"><a href="#1-只在常量池上创建常量" class="headerlink" title="1. 只在常量池上创建常量"></a>1. 只在常量池上创建常量</h3><blockquote><p>  String a1 = “AA”;</p></blockquote><h3 id="2-只在堆上创建对象"><a href="#2-只在堆上创建对象" class="headerlink" title="2. 只在堆上创建对象"></a>2. 只在堆上创建对象</h3><blockquote><p>String a2 = new String(“A”) + new String(“A”);</p></blockquote><h3 id="3-在堆上创建对象，在常量池上创建常量"><a href="#3-在堆上创建对象，在常量池上创建常量" class="headerlink" title="3. 在堆上创建对象，在常量池上创建常量"></a>3. 在堆上创建对象，在常量池上创建常量</h3><blockquote><p>String a3 = new String(“AA”);</p></blockquote><h3 id="4-在堆上创建对象，在常量池上创建引用"><a href="#4-在堆上创建对象，在常量池上创建引用" class="headerlink" title="4. 在堆上创建对象，在常量池上创建引用"></a>4. 在堆上创建对象，在常量池上创建引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a4 = new String(&quot;A&quot;) + new String(&quot;A&quot;);//只在堆上创建对象AA</span><br><span class="line"></span><br><span class="line">a4.intern();//将该对象AA的引用保存到常量池上</span><br></pre></td></tr></table></figure><h3 id="5-在堆上创建对象，在常量池上创建常量，在常量池上创建引用（不可能）"><a href="#5-在堆上创建对象，在常量池上创建常量，在常量池上创建引用（不可能）" class="headerlink" title="5. 在堆上创建对象，在常量池上创建常量，在常量池上创建引用（不可能）"></a>5. 在堆上创建对象，在常量池上创建常量，在常量池上创建引用（<font color="#DC143C">不可能</font>）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String a5 = new String(&quot;A&quot;) + new String(&quot;A&quot;);//只在堆上创建对象</span><br><span class="line"></span><br><span class="line">a5.intern();//在常量池上创建引用</span><br><span class="line"></span><br><span class="line">String a6 = &quot;AA&quot;;//此时不会再在常量池上创建常量AA，而是将a5的引用返回给a6</span><br><span class="line"></span><br><span class="line">System.out.println(a5 == a6); //true</span><br></pre></td></tr></table></figure><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">         String aa = &quot;AA&quot;;//设置常量AA到常量池</span><br><span class="line">         String bb = &quot;BB&quot;;//设置常量BB到常量池</span><br><span class="line">         String ccdd = &quot;CC&quot;+&quot;DD&quot;;//设置常量CCDD到常量池</span><br><span class="line">         String neeff = new String(&quot;EE&quot;)+new String(&quot;FF&quot;);//设置EE和FF到常量池。并且添加EE、FF和EEFF对象到堆</span><br><span class="line">         String aabb = aa+bb;//添加AABB对象到堆</span><br><span class="line">         String gghh = &quot;GG&quot;+new String(&quot;HH&quot;);//设置GG和HH常量到常量池,设置HH和GGHH对象到堆</span><br><span class="line">//         aa.intern();//啥事都不做，返回AA常量</span><br><span class="line">//         ccdd.intern();//啥事都不做，返回CCDD常量</span><br><span class="line">//         neeff.intern();//添加EEFF对象的引用到常量池，并返回EEFF对象</span><br><span class="line">//         aabb.intern();//添加AABB对象的引用到常量池，并返回AABB对象</span><br><span class="line">//         gghh.intern();//添加GGHH对象的引用到常量池，并返回GGHH对象</span><br><span class="line">         System.out.println(aa.intern()==aa); //true</span><br><span class="line">         System.out.println(neeff.intern()==&quot;EEFF&quot;);//true</span><br><span class="line">         System.out.println(&quot;EEFF&quot;==neeff);//true</span><br><span class="line">         String nccdd = new String(&quot;CCDD&quot;);</span><br><span class="line">         System.out.println(ccdd==nccdd);//false</span><br><span class="line">         System.out.println(ccdd==nccdd.intern());//true</span><br><span class="line">         System.out.println(aabb.intern()==aabb);//true</span><br><span class="line">         System.out.println(gghh==gghh.intern());//true</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM常用基础参数</title>
      <link href="/2019/05/20/JVM%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0/"/>
      <url>/2019/05/20/JVM%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM的参数类型"><a href="#JVM的参数类型" class="headerlink" title="JVM的参数类型"></a>JVM的参数类型</h2><ol><li>标配参数</li><li>x参数</li><li>xx参数</li></ol><h3 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h3><blockquote><p>-version， -help， java -showversion</p></blockquote><h3 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h3><ol><li>boolean类型：+开启/ -关闭  公式：-xx:+/-某个属性</li><li>KV设值类型：-xx:属性key=属性值value  case：-xx:MetaspaceSize=128m</li></ol><h2 id="常用基础参数"><a href="#常用基础参数" class="headerlink" title="常用基础参数"></a>常用基础参数</h2><ol><li>-Xms：初始内存大小，默认为物理内存的1/64，等价于<code>-xx:InitialHeapSize</code></li><li>-Xmx：最大分配内存，默认为物理内存的1/4，等价于<code>-xx:MaxHeapSize</code></li><li>-Xss：设置单个线程栈的大小，默认为 512K~1024K，等价于<code>-xx:ThreadStackSize</code></li><li>-Xmn：设置年轻代的大小，默认为堆空间的1/3，老年代为2/3</li><li><code>-xx:MetaspaceSize</code>：设置元空间的大小，元空间的本质和永久代类似，不过元空间不在虚拟机中，而是使用的本地内存</li><li><code>-xx:+UseSerialGC</code>：使用串行垃圾回收器</li><li><code>-xx:+UseParallelGC</code>：使用并行垃圾回收器</li><li><code>-xx:+PrintGCDetails</code>：输出GC详细的日志收集信息，包括GC 和FullGC</li><li><code>-xx:+SurvivorRatio</code>：设置年轻代中Eden区和S0,S1的比例，默认<code>-xx:+SurvivorRatio=8</code>，Eden:S0:S1=8:1:1</li><li><code>-xx:NewRatio</code>：设置年轻代和老年代在堆中的占比。默认<code>-xx:NewRatio=2</code>，年轻代占1，老年代占2，年轻代占堆的1/3</li><li><code>-xx:MaxTenuringThreshold</code>：设置垃圾的最大年龄，若为0，则年轻代对象不经过Survivor区，直接进入老年代，默认为15</li></ol><h2 id="如何在IDE中查看"><a href="#如何在IDE中查看" class="headerlink" title="如何在IDE中查看"></a>如何在IDE中查看</h2><ul><li><p>如何查看当前运行程序的配置</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br><span class="line">jinfo -flag 参数名 线程号</span><br><span class="line">jinfo -flags 线程号  -- 查看所有参数</span><br><span class="line">Non-default 后的是根据机器配置自动调整后出的参数</span><br><span class="line">Command line 后的是自己配置的参数</span><br></pre></td></tr></table></figure></li><li><p>查看初始默认值<br><code>java -xx:+PrintFlagsInitial -version</code></p></li><li><p>查看修改更新<br><code>java -xx:+PrintFlagsFinal -version</code><br>结果：  <strong>=</strong> 没改过；      <strong>:=</strong> 修改过或JVM根据硬件不同自动调整过</p></li><li>在运行时修改变更值  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -xx:+PrintFlagsFinal -xx:MetaspaceSize=128m 类名</span><br><span class="line">java -xx:+PrintCommandLineFlags -version 可以用来查看垃圾回收器</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的四种引用</title>
      <link href="/2019/05/20/Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/"/>
      <url>/2019/05/20/Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-强引用（Strong-Reference）"><a href="#1-强引用（Strong-Reference）" class="headerlink" title="1. 强引用（Strong Reference）"></a>1. 强引用（Strong Reference）</h2><p>强引用是指在程序代码中普遍存在的，类似“Object obj=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><p>只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象</p><h2 id="2-软引用（Soft-Reference）"><a href="#2-软引用（Soft-Reference）" class="headerlink" title="2. 软引用（Soft Reference）"></a>2. 软引用（Soft Reference）</h2><p>软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，只有在<strong>内存不足</strong>的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。JDK 1.2之后，提供了SoftReference类来实现软引用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.SoftReference;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">        SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(<span class="string">"hello"</span>));</span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-弱引用（WeakReference）"><a href="#3-弱引用（WeakReference）" class="headerlink" title="3. 弱引用（WeakReference）"></a>3. 弱引用（WeakReference）</h2><p>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，<strong>无论内存是否充足</strong>，都会回收被弱引用关联的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     </span><br><span class="line">        WeakReference&lt;String&gt; sr = new WeakReference&lt;String&gt;(new String(&quot;hello&quot;));</span><br><span class="line">         </span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">        System.gc();                //通知JVM的gc进行垃圾回收</span><br><span class="line">        System.out.println(sr.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-虚引用（PhantomReference）"><a href="#4-虚引用（PhantomReference）" class="headerlink" title="4. 虚引用（PhantomReference）"></a>4. 虚引用（PhantomReference）</h2><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。如果一个对象与虚引用关联，跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。不能单独使用，必须和<strong>引用队列</strong> ReferenceQueue联合使用</p><p>ReferenceQueue是用来配合引用工作的，创建引用时可以指定关联的队列，当GC释放引用对象的内存时，会将引用加入到ReferenceQueue</p><p>如果程序发现某个虚引用被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于一种<strong>通知机制</strong>。当队列中有数据时，意味着引用指向的堆内存中的对象被回收。通过这种方式，JVM允许我们在对象被销毁后做一些我们想做的事</p><h2 id="四种引用对比"><a href="#四种引用对比" class="headerlink" title="四种引用对比"></a>四种引用对比</h2><table><thead><tr><th>对比</th><th>强引用</th><th>软引用</th><th>弱引用</th><th>虚引用</th></tr></thead><tbody><tr><td>引用强度</td><td>最强</td><td>第二</td><td>第三</td><td>最弱</td></tr><tr><td>如何使用</td><td>new Object()</td><td>SoftReference</td><td>WeakReference</td><td>PhantomReference</td></tr></tbody></table><h2 id="软引用和弱引用的使用场景"><a href="#软引用和弱引用的使用场景" class="headerlink" title="软引用和弱引用的使用场景"></a>软引用和弱引用的使用场景</h2><p>当一个应用要大量读取本地的图片，若每次都从硬盘读取会影响性能，而一次性全部加载进内存会造成内存溢出。</p><p>设计思路：使用一个HashMap来保存图片路径和相应图片对象关联的软引用间的映射关系，在内存不足时，JVM会自动回收这些空间</p><p><code>Map&lt;String, SoftReference&lt;BitMap&gt;&gt; imageCache = new Map&lt;String, SoftReference&lt;BitMap&gt;&gt;();</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line">&lt;br&gt;....</span><br><span class="line">public void addBitmapToCache(String path) &#123;</span><br><span class="line">// 强引用的Bitmap对象</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line">// 软引用的Bitmap对象</span><br><span class="line">SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap);</span><br><span class="line">// 添加该对象到Map中使其缓存</span><br><span class="line">imageCache.put(path, softBitmap);</span><br><span class="line">&#125;</span><br><span class="line">public Bitmap getBitmapByPath(String path) &#123;</span><br><span class="line">// 从缓存中取软引用的Bitmap对象</span><br><span class="line">SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);</span><br><span class="line">// 判断是否存在软引用</span><br><span class="line"><span class="keyword">if</span> (softBitmap == null) &#123;</span><br><span class="line"><span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line">// 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空</span><br><span class="line">Bitmap bitmap = softBitmap.get();</span><br><span class="line"><span class="built_in">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java引用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM—垃圾回收机制(1)</title>
      <link href="/2019/05/16/JVM%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-1/"/>
      <url>/2019/05/16/JVM%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-1/</url>
      
        <content type="html"><![CDATA[<h2 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h2><p>由于程序计数器、虚拟机栈、本地方法栈的生命周期都跟随线程的生命周期，当线程销毁了，内存也就回收了，所以这几个区域不用过多地考虑内存回收。由于<strong>堆</strong>和<strong>方法区</strong>的内存都是动态分配的，而且是线程共享的，所以内存回收主要关注这部分区域。</p><h2 id="如何判断对象是否存活"><a href="#如何判断对象是否存活" class="headerlink" title="如何判断对象是否存活"></a>如何判断对象是否存活</h2><p><strong>引用计数法</strong></p><blockquote><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，如果引用失效，计数器值减1，所以当该计数器的值为0时，就表示该对象可以被回收了。但是存在两个对象之间相互循环引用的问题。</p></blockquote><p><strong>可达性分析算法</strong></p><blockquote><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索的路径称为引用链，当一个对象到“GC Roots”没有任何引用链相连的话，也就是GC Roots到这个对象不可达时，证明此对象已经不可用，可以被回收了。</p></blockquote><p><strong>二次标记</strong></p><blockquote><p>在可达性分析算法中被判断是对象不可达时不一定会被垃圾回收机制回收，因为要真正宣告一个对象的死亡，必须经历两次标记的过程。如果发现对象不可达时，将会进行第一次标记，此时如果该对象调用了finalize()方法，那么这个对象会被放置在一个叫F-Queue的队列之中，如果在此队列中该对象没有成功拯救自己（拯救自己的方法是该对象有没有被重新引用），那么GC就会对F-Queue队列中的对象进行小规模的第二次标记，一旦被第二次标记的对象，将会被移除队列并等待被GC回收，所以finalize()方法是对象逃脱死亡命运的最后一次机会。</p></blockquote><h2 id="常用垃圾回收算法"><a href="#常用垃圾回收算法" class="headerlink" title="常用垃圾回收算法"></a>常用垃圾回收算法</h2><p><strong>引用计数法</strong>：  JVM一般不用</p><p><strong>复制算法</strong>：复制、清空、互换<br>把内存按容量划分为大小相等的两块区域，每次只使用其中的一块，当这一块的内存空间用完了，就把还存活的对象复制到另一块内存中去，然后把已经使用的过的内存空间一次性清理掉。这样每次都是对半个内存区域进行GC回收，并不会产生内存碎片，但是代价是把内存缩小了一半，效率比较低。<br>（1）Eden、SurvivorFrom <strong>复制</strong>到 SurvivorTo，年龄+1<br>首先 Eden 区满，触发第一次 GC，将活着的对象复制到 SurvivorFrom 区，当 Eden 区再次触发 GC 时撒扫描 Eden 区和 SurvivorFrom 区，对两区进行垃圾回收，还存活的对象复制到 SurvivorTo 区（若对象年龄达到老年的标准，复制到老年代）<br>（2）<strong>清空</strong> Eden、SurvivorFrom<br>清空 Eden、SurvivorFrom 区中的对象，也即复制之后的交换，谁空谁是To<br>（3）SurvivorFrom 区和 SurvivorTo 区<strong>互换</strong><br>原 To 区成为下一次 GC 时的 From 区，部分对象会在 From 区和 To 区间来回复制，达到15次（JVM参数MaxTenuringThreshold决定，默认值为15）还存活，将其复制到老年代</p><p><strong>标记—清除算法</strong>：<br>首先<strong>标记</strong>出需要回收的对象，在标记完成后进行统一的回收（<strong>标记即二次标记的过程</strong>）。此算法有两个不足：一是效率问题，标记和清除两个过程效率都不高；二是空间问题，标记清除后会产生大量不连续的<strong>内存碎片</strong>，内存空间碎片太多的话会导致以后程序在运行中想要分配较大对象的时候，无法找到一块连续的内存空间而导致不得不进行又一次的GC回收（后续的垃圾回收算法都是基于此算法进行改进的）</p><p><strong>标记—整理算法</strong>：<br>标记算法一样，区别是清除的时候会把所有存活的对象向一端移动（向上和向左），然后清除掉端边界以外的内存。相比标记—清除算法，此方法没有内存碎片，但付出了移动对象的成本。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>根据对象存活周期的不同将内存划分为几块（年轻代或老年代），然后根据每个年代的特点采用最合适的收集算法。</p><p>比如在<strong>年轻代</strong>中，每次都有大量对象死去，就选择<strong>复制算法</strong>；</p><p>而在<strong>老年代</strong>中对象的生存率高，没有额外的空间为它进行分配担保，所以采用<strong>标记—清除算法</strong>或者<strong>标记—整理算法</strong>来进行回收。</p><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><blockquote><p>什么是新生代、老年代</p></blockquote><p>新生代：新生代包含一个Eden区和两个Survivor区。大多数情况下，新创建的对象会在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机会触发一次Minor GC，如果Survivor区空间允许的话，该对象将被分配到Survivor。</p><p>老年代：<strong>大对象</strong>直接在老年代中分配，大对象指需要大量连续内存空间的Java对象。</p><blockquote><p>分代收集如何判定对象的年龄？</p></blockquote><p>虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden区出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间，并且对象年龄设置为1,。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当对象的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中</p><blockquote><p>为什么新生代中要有Survivor区？</p></blockquote><p>防止频繁触发FULL GC。如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代，这样会使老年代很快被填满，导致老年代触发FULL GC，由于老年代的内存空间远大于新生代，所以进行一次Full GC消耗的时间比Minor GC长得多。</p><blockquote><p>为什么要设置两个Survivor区？</p></blockquote><p>防止产生内存空间碎片。如果只有Survivor1，那么每一次当Eden区满时，触发Minor GC并把对象移入Survivor1中，如此循环对导致Survivor1中产生大量的空间碎片；所以需要有Survivor2，当Eden再一次满时，触发Minor GC，虚拟机会把Eden中和Survivor1中的存活对象通过复制算法移入Survivor2中，这样Survivor2就不会产生内存碎片，同时Eden和Survivor1会清理内存，保证下一次Minor GC触发时的操作。</p><blockquote><p>Minor GC和Full GC的区别？</p></blockquote><p>（1）新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多数都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度比较快。<br>（2）老年代GC（Full GC）：指发生在老年代的垃圾收集动作，速度非常慢，所以要尽量减少Full GC的发生。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li>强引用：指向使用new关键字创建的对象的引用都是强引用，只要该对象的强引用还在，该对象永远都不会被GC回收；</li><li>软引用：当内存不足时，就会被回收；</li><li>弱引用：只要发生GC，就会被回收；</li><li>虚引用：随时都会被回收；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解Java虚拟机》第2版 第3章 垃圾收集器与内存分配策略</p>]]></content>
      
      
      <categories>
          
          <category> GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存原型</title>
      <link href="/2019/05/16/Java%E5%86%85%E5%AD%98%E5%8E%9F%E5%9E%8B/"/>
      <url>/2019/05/16/Java%E5%86%85%E5%AD%98%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Java虚拟机内存原型"><a href="#Java虚拟机内存原型" class="headerlink" title="Java虚拟机内存原型"></a>Java虚拟机内存原型</h2><ul><li><strong>寄存器</strong>： 我们在程序中无法控制。</li><li><strong>栈</strong>： 存放基本类型的数据和对象引用，但对象本身不在栈中而是堆中。</li><li><strong>堆</strong>： 存放用 new 产生的数据</li><li><strong>静态域</strong>：存放在对象中用 static 定义的静态成员</li><li><strong>常量池</strong>：存放常量</li><li><strong>非 RAM 存储</strong>：硬盘等永久存储空间<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g339c07vh4j30d50d60ud.jpg" alt=""></li></ul><h2 id="常量池（constant-pool）"><a href="#常量池（constant-pool）" class="headerlink" title="常量池（constant pool）"></a>常量池（constant pool）</h2><p>常量池指的是在编译期被确定，并被保存在已编译的 class 文件中的一些数据。除了包含代码中所定义的各种基本类型（如 int、long 等等）和对象型（如 String 及数组）的常量值（final）外，还包含一些以文本形式出现的符号引用，比如： </p><ol><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ol><p>虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集合，包括直接常量（ string,integer 等）和其他类型：字段和方法的符号引用。<strong>对于 String 常量，它的值是在常量池中的。</strong> 而 JVM 中的常量池在内存当中是以表的形式存在的，对于 String 类型，有一张固定长度的CONSTANT_String_info 表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。在程序执行的时候，<strong>常量池会储存在 Method Area，而不是堆中</strong>。 </p><h2 id="Java内存分配中的栈"><a href="#Java内存分配中的栈" class="headerlink" title="Java内存分配中的栈"></a>Java内存分配中的栈</h2><p>栈的基本单位是<strong>帧</strong>（或栈帧）：每当一个 Java线程运行的时候，Java虚拟机会为该线程分配一个Java<br>栈。该线程在执行某个Java方法的时候，向Java栈压入一个帧，这个帧用于<strong>存储参数、局部变量、操作数、中间运算结果</strong>等。当这个方法执行完的时候，帧会从栈中弹出。Java栈上的所有数据是<strong>私有的</strong>，其他线程都不能访问该线程的栈数据。在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。当在一段代码块中定义一个变量时，Java就在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 </p><h2 id="Java内存中分配的堆"><a href="#Java内存中分配的堆" class="headerlink" title="Java内存中分配的堆"></a>Java内存中分配的堆</h2><p>Java虚拟机中的堆用来存放由 <strong>new</strong> 创建的<strong>对象和数组</strong>。在堆中分配的内存，由Java虚拟机的自动<strong>垃圾回收机制</strong>来管理堆的内存。简单的说和栈相对，<strong>堆主要是用来存放Java对象的，栈主要是用来存放对象引用的</strong>。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或对象起的一个名称。</p><p>引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能再被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是Java比较占内存的原因。<strong>实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针！</strong> </p><h2 id="堆和栈的比较"><a href="#堆和栈的比较" class="headerlink" title="堆和栈的比较"></a>堆和栈的比较</h2><p>java的堆是一个运行时数据区，类的对象从中分配空间。这些对象通过 new + 构造器等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，<strong>堆的优势</strong>是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 </p><p><strong>栈的优势</strong>是存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量数据（int，short，long，byte，float，double，boolean，char）和对象引用。 </p><p>栈有一个很重要的特殊性，就是<strong>存在栈中的数据可以共享</strong>。假设我们同时定义： int a=3；int b=3；编译器先处理 int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将 a 指向3，接着处理 int b = 3；在创建完 b 的引用变量后，因为在栈中已经有3这个值，便将b直接指向3这样，就出现了 a 与 b 同时均指向3的情况。 </p><p>这时，如果再令 a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 </p><p><strong>要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的</strong>，因为这种情况 a 的修改并不会影响到 b，它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。 </p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁</title>
      <link href="/2019/05/15/%E6%AD%BB%E9%94%81/"/>
      <url>/2019/05/15/%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁产生原因"><a href="#死锁产生原因" class="headerlink" title="死锁产生原因"></a>死锁产生原因</h2><p>死锁是指两个或者两个以上的进程在执行过程中，因抢夺资源而造成的一种互相等待的现象，若无外力干涉它们将都无法推进下去。</p><p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性也就很低，否则就会因争夺有限的资源而陷入死锁。</p><h2 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String lockA = <span class="string">"lockA"</span>;</span><br><span class="line">        String lockB = <span class="string">"lockB"</span>;</span><br><span class="line"></span><br><span class="line">        new Thread(new HoldLockThread(lockA,lockB),<span class="string">"ThreadAAA"</span>).start();</span><br><span class="line">        new Thread(new HoldLockThread(lockB,lockA),<span class="string">"ThreadBBB"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HoldLockThread implements Runnable&#123;</span><br><span class="line">    private String lockA;</span><br><span class="line">    private String lockB;</span><br><span class="line"></span><br><span class="line">    public HoldLockThread(String lockA,String lockB)&#123;</span><br><span class="line">        this.lockA = lockA;</span><br><span class="line">        this.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>()&#123;</span><br><span class="line">        synchronized (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t自己持有："</span>+lockA+<span class="string">"\t尝试获得："</span>+lockB);</span><br><span class="line">            //暂停一下</span><br><span class="line">            try&#123; TimeUnit.SECONDS.sleep(2); &#125;catch (InterruptedException e)&#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">            synchronized (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"\t自己持有："</span>+lockB+<span class="string">"\t尝试获得："</span>+lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何查找定位"><a href="#如何查找定位" class="headerlink" title="如何查找定位"></a>如何查找定位</h2><ul><li>linux环境下  使用 ps -ef|grep xxxx    ls -l 查看当前进程的命令</li><li>windows下的java运行程序，也有类似ps的查看进程的命令：jps -l 命令定位进程号；jstack xxxx(进程号)命令找到死锁查看</li></ul>]]></content>
      
      
      <categories>
          
          <category> 死锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 死锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池</title>
      <link href="/2019/05/15/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/05/15/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>之前我们在使用多线程都是用Thread的start()来创建启动一个线程，但是在实际开发中，如果每个请求到达就创建一个新线程，开销是相当大的。服务器在创建和销毁线程上花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个 jvm 里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。这就引入了线程池概念。（第4种获得/使用java多线程的方式）线程池的主要特点是：线程复用，控制最大并发数，管理线程。</p><h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><p>在java.util.concurrent包下，提供了一系列与线程池相关的类。合理的使用线程池，可以带来多个好处：</p><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><h2 id="如何使用线程池"><a href="#如何使用线程池" class="headerlink" title="如何使用线程池"></a>如何使用线程池</h2><ul><li>1、创建线程池</li><li>2、创建任务</li><li>3、执行任务</li><li>4、关闭线程池</li></ul><h2 id="五种线程池的使用场景"><a href="#五种线程池的使用场景" class="headerlink" title="五种线程池的使用场景"></a>五种线程池的使用场景</h2><ul><li><code>newSingleThreadExecutor</code> ：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</li><li><code>newFixedThreadPool</code> ：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。</li><li><code>newCachedThreadPool</code> ：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。</li><li><code>newScheduledThreadPool</code> ：一个可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</li><li><code>newWorkStealingPool</code> ：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行。</li></ul><h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = new ThreadPoolExecutor(2,</span><br><span class="line">                5,</span><br><span class="line">                1L,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;&gt;(3),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                new ThreadPoolExecutor.DiscardPolicy());</span><br></pre></td></tr></table></figure><p>线程池不允许用Executors来创建，而是通过ThreadPoolExecutor这样的方式，这样的处理方式可以让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br><strong>说明：</strong> Executors返回的线程池对象弊端如下：</p><ul><li>FixedThreadPool 和 SingleThreadExecutor：允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，导致OOM。</li><li>CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，导致OOM。</li></ul><h2 id="线程池的七大参数"><a href="#线程池的七大参数" class="headerlink" title="线程池的七大参数"></a>线程池的七大参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) ;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize ：线程池中常驻的核心线程数，决定着新提交的任务是新开线程去执行还是放到任务队列中，也是线程池的最最核心的参数。一般线程池开始时是没有线程的，只有当任务来了并且线程数量小于corePoolSize才会创建线程。                             </li><li>maximumPoolSize ：最大线程数，线程池能创建的最大线程数量。</li><li>keepAliveTime ：在线程数量超过corePoolSize后，多余空闲线程的最大存活时间。</li><li>unit ：keepAliveTime时间单位</li><li>workQueue ：存放来不及处理的任务的队列，是一个BlockingQueue。</li><li><p>threadFactory ：生产线程的工厂类，可以定义线程名，优先级等。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()</span><br><span class="line">            .setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br></pre></td></tr></table></figure></li><li><p>handler ：拒绝策略，当前队列满且工作线程数大于或等于maximumPoolSize时启用，共4种策略。</p></li></ul><h2 id="4种拒绝策略"><a href="#4种拒绝策略" class="headerlink" title="4种拒绝策略"></a>4种拒绝策略</h2><ol><li><code>AbortPolicy</code> ：当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。</li><li><code>CallerRunsPolicy</code> ： 当任务添加到线程池中被拒绝时，将任务回退给调用者。</li><li><code>DiscardOldestPolicy</code> ：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最久的未处理任务，然后将被拒绝的任务添加到等待队列中，并尝试再次提交。</li><li><code>DiscardPolicy</code> ：当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务，如果允许任务丢失，这是最好的方案。<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2>线程池使用完毕，需要对其进行关闭，有两种方法<blockquote><p>shutdown()</p></blockquote></li></ol><p>说明：shutdown并不是直接关闭线程池，而是不再接受新的任务…如果线程池内有任务，那么把这些任务执行完毕后，关闭线程池</p><blockquote><p>shutdownNow()</p></blockquote><p>说明：这个方法表示不再接受新的任务，并把任务队列中的任务直接移出掉，如果有正在执行的，尝试进行停止</p><h2 id="线程池的底层工作原理"><a href="#线程池的底层工作原理" class="headerlink" title="线程池的底层工作原理"></a>线程池的底层工作原理</h2><ol><li>提交任务</li><li>核心线程是否已满？ Y 跳转至第3步；  N 创建执行线程</li><li>队列已满？   Y 跳转至第4步；  N 加入队列</li><li>最大线程已满？   Y 跳转至第5步；  N 创建线程</li><li>拒绝策略</li></ol><h2 id="如何配置合理的线程数"><a href="#如何配置合理的线程数" class="headerlink" title="如何配置合理的线程数"></a>如何配置合理的线程数</h2><p>线程池中线程数目的设置依托于硬件设备（CPU核数）以及需要执行任务的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查看CPU核数</span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure></p><p>CPU密集型任务：</p><ul><li>特点：大量运算，没有阻塞，CPU一直全速运行</li><li>配置：应配置尽可能<strong>少</strong>的线程数量。</li><li>公式：CPU核数 + 1</li></ul><p>IO密集型任务：</p><ul><li>特点：大部分线程阻塞，CPU不是一直执行任务</li><li>配置：应配置尽可能<strong>多</strong>的线程数量。如：CPU核数 * 2</li><li>公式：CPU核数 / (1 - 阻塞系数)  阻塞系数约为0.8~0.9</li></ul>]]></content>
      
      
      <categories>
          
          <category> ThreadPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadPool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC初探</title>
      <link href="/2019/05/15/JUC%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/05/15/JUC%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JUC-简介"><a href="#一、JUC-简介" class="headerlink" title="一、JUC 简介"></a>一、JUC 简介</h2><p>JUC：java.util.concurrent 在并发编程中使用的工具类</p><h2 id="二、Lock-接口"><a href="#二、Lock-接口" class="headerlink" title="二、Lock 接口"></a>二、Lock 接口</h2><h3 id="1-Synchronized"><a href="#1-Synchronized" class="headerlink" title="1. Synchronized"></a>1. Synchronized</h3><h4 id="1-1-多线程编程模板"><a href="#1-1-多线程编程模板" class="headerlink" title="1.1 多线程编程模板"></a>1.1 多线程编程模板</h4><ul><li>线程      操作      资源类</li><li>判断      干活      通知</li><li>高内聚低耦合</li><li><font color="#DC143C">注意：多线程的判断必须使用while循环，不能使用if</font><h4 id="1-2-实现步骤"><a href="#1-2-实现步骤" class="headerlink" title="1.2 实现步骤"></a>1.2 实现步骤</h4></li></ul><ol><li>创建资源类</li><li>资源类里创建同步方法、同步代码块<h3 id="2-Lock"><a href="#2-Lock" class="headerlink" title="2. Lock"></a>2. Lock</h3><h4 id="2-1-Lock是什么"><a href="#2-1-Lock是什么" class="headerlink" title="2.1 Lock是什么"></a>2.1 Lock是什么</h4>Lock 实现提供更广泛的锁定操作可以比使用synchronized 获得方法和声明更好。他们允许更灵活的结构，可以有完全不同的特性，可以支持多个相关的Condition 对象。<h4 id="2-2-Lock接口的实现"><a href="#2-2-Lock接口的实现" class="headerlink" title="2.2 Lock接口的实现"></a>2.2 Lock接口的实现</h4>ReentrantLock 可重入锁，参考Java8API<h4 id="2-3-lambda-表达式"><a href="#2-3-lambda-表达式" class="headerlink" title="2.3 lambda 表达式"></a>2.3 lambda 表达式</h4></li><li>要求：lambda 表达式，如果一个接口只有一个方法，我可以把方法名省略</li><li><p>编写规则：拷贝小括号（），写死右箭头-&gt;，落地大括号{…}</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo foo = () -&gt; &#123;System.out.println(&quot;****hello lambda&quot;);&#125;;</span><br></pre></td></tr></table></figure></li><li><p>函数式接口：lambda 表达式，必须是函数式接口，必须只有一个方法，如果接口只有一个方法java 默认它为函数式接口。为了正确使用Lambda 表达式，需要给接口加个注解：@FunctionalInterface，如有两个方法，立刻报错。</p><h4 id="2-4-Lock与Synchronized的区别，用Lock有什么好处"><a href="#2-4-Lock与Synchronized的区别，用Lock有什么好处" class="headerlink" title="2.4 Lock与Synchronized的区别，用Lock有什么好处"></a>2.4 Lock与Synchronized的区别，用Lock有什么好处</h4><ol><li><p>原始构成：</p><ul><li>synchronized是关键字，属于JVM层面<br>monitorenter（底层通过monitor对象来完成，wait/notify等方法也依赖于monitor对象，只有再同步块和方法中才能调用wait/notify等方法）， monitorexit<ul><li>lock是具体类（java.util.concurrent.locks.Lock）是API层面的锁</li></ul></li></ul></li><li><p>使用方法：</p><ul><li>synchronized不需要用户手动释放锁，当synchronized代码执行完后，系统会自动让线程释放对锁的占用   </li><li>ReentrantLock则需要用户手动释放锁，若没有主动释放，就有可能出现死锁的情况，需要lock()和unlock()方法配合try/finally语句块来完成</li></ul></li><li><p>等待是否可中断：</p><ul><li>synchronized不可中断，除非抛出异常或正常运行完成      <ul><li>ReentrantLock可中断，<br>（1）设置超时方法tryLock(long timeout, TimeUnit unit)<br>（2）LockInterruptibly()放在代码块中，调用interrupt()方法可中断</li></ul></li></ul></li><li><p>加锁是否公平：</p><ul><li>synchronized为非公平锁</li><li>ReentrantLock两者都可以，默认非公平锁，构造方法可传入boolean值，true为公平锁，false为非公平锁</li></ul></li><li><p>绑定多个条件的condition：</p><ul><li>synchronized没有</li><li>ReentrantLock可以实现分组唤醒需要被唤醒的线程，可以精确唤醒，而不是像synchronized要么随机唤醒一个线程，要么全部唤醒</li></ul></li></ol></li></ol><h2 id="三、Callable-接口"><a href="#三、Callable-接口" class="headerlink" title="三、Callable 接口"></a>三、Callable 接口</h2><h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a>1. 是什么</h3><h4 id="1-1-面试题：获得多线程的方法几种？"><a href="#1-1-面试题：获得多线程的方法几种？" class="headerlink" title="1.1 面试题：获得多线程的方法几种？"></a>1.1 面试题：获得多线程的方法几种？</h4><p>错误回答：<br>（1）继承thread 类（2）runnable 接口<br>正确回答：<br>传统的是继承thread 类和实现runnable 接口，java5 以后又有实现callable 接口和java 的线程池获得。</p><h4 id="1-2-功能接口"><a href="#1-2-功能接口" class="headerlink" title="1.2 功能接口"></a>1.2 功能接口</h4><p>Callable 是一个功能接口，因此可以用作lambda 表达式或方法引用的赋值对象。</p><h3 id="2-与-runnable-对比"><a href="#2-与-runnable-对比" class="headerlink" title="2. 与 runnable 对比"></a>2. 与 runnable 对比</h3><ol><li>Callable有返回值</li><li>Callable会抛异常</li><li>接口实现的方法不同 call()和run()</li></ol><h3 id="3-如何使用"><a href="#3-如何使用" class="headerlink" title="3. 如何使用"></a>3. 如何使用</h3><h4 id="3-1-FutureTask"><a href="#3-1-FutureTask" class="headerlink" title="3.1 FutureTask"></a>3.1 FutureTask</h4><ul><li>FutureTask 未来的任务，用它就干一件事，异步调用。</li><li><p>main 方法就像一个冰糖葫芦，一个个方法由main 串起来。但解决不了一个问题：正常调用挂起堵塞问题</p><blockquote><p>例子：高考：会做的先做，不会的放在后面做</p></blockquote></li><li><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future 对象在后台完成，当主线程将来需要时，就可以通过Future 对象获得后台作业的计算结果或者执行状态。</p></li><li>一般FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</li><li>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞get 方法。一旦计算完成，就不能再重新开始或取消计算。get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。</li><li>只计算一次，且get 方法一般放到最后，若不放在最后一般使用 while (!futureTask.isDone()) 循环</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new MyThread());</span><br><span class="line"></span><br><span class="line">//共用一个FutureTask只会进1次</span><br><span class="line">new Thread(futureTask,&quot;AA&quot;).start();</span><br><span class="line">new Thread(futureTask,&quot;BB&quot;).start();</span><br><span class="line">    </span><br><span class="line">int r2 = futureTask.get();</span><br></pre></td></tr></table></figure><h2 id="四、线程间的通信"><a href="#四、线程间的通信" class="headerlink" title="四、线程间的通信"></a>四、线程间的通信</h2><h3 id="1-线程间通信"><a href="#1-线程间通信" class="headerlink" title="1. 线程间通信"></a>1. 线程间通信</h3><p>（1）生产者+消费者<br>（2）通知等待唤醒机制</p><h3 id="2-synchronized-实现"><a href="#2-synchronized-实现" class="headerlink" title="2. synchronized 实现"></a>2. synchronized 实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void increment() throws InterruptedException&#123;</span><br><span class="line">    //1 判断</span><br><span class="line">    if(number !=0 ) &#123;</span><br><span class="line">        this.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    //2 干活</span><br><span class="line">    ++number;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+number);</span><br><span class="line">    //3 通知</span><br><span class="line">    this.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-lock实现"><a href="#3-lock实现" class="headerlink" title="3. lock实现"></a>3. lock实现</h3><h4 id="3-1-对标synchronized"><a href="#3-1-对标synchronized" class="headerlink" title="3.1 对标synchronized"></a>3.1 对标synchronized</h4><p>synchronized———wait———notify<br>lock———await———signal</p><h4 id="3-2-condition"><a href="#3-2-condition" class="headerlink" title="3.2 condition"></a>3.2 condition</h4><p>synchronized没有，ReentrantLock可以实现分组唤醒需要被唤醒的线程，可以使用condition进行精确唤醒（<strong>有顺序通知，需要有标识位</strong>），而不是像synchronized要么随机唤醒一个线程，要么全部唤醒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//1 判断</span><br><span class="line">while(number != 3)&#123; //number就是标识位</span><br><span class="line">    //A 就要停止</span><br><span class="line">    c3.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java阻塞队列：BlockingQueue</title>
      <link href="/2019/05/14/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9ABlockingQueue/"/>
      <url>/2019/05/14/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9ABlockingQueue/</url>
      
        <content type="html"><![CDATA[<h2 id="阻塞队列：BlockingQueue"><a href="#阻塞队列：BlockingQueue" class="headerlink" title="阻塞队列：BlockingQueue"></a>阻塞队列：BlockingQueue</h2><p>阻塞队列是一种队列，一种可以在多线程环境下使用，并且支持阻塞等待的队列。也就是说，阻塞队列和一般的队列的区别就在于：</p><ul><li>多线程环境支持，多个线程可以安全的访问队列</li><li>支持生产和消费等待，多个线程之间互相配合，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线 程就会阻塞直到队列不满。</li></ul><h2 id="几种常用的阻塞队列"><a href="#几种常用的阻塞队列" class="headerlink" title="几种常用的阻塞队列"></a>几种常用的阻塞队列</h2><ul><li>ArrayBlockingQueue，基于数组结构的有界阻塞队列，按FIFO对元素进行排序</li><li>LinkedBlockingQueue，基于链表结构的阻塞队列，按FIFO对元素进行排序，有界但大小默认值为Integer.MAX_VALUE = 2 的 31 次方 - 1</li><li>LinkedBlockingDeque，基于链表结构的双端阻塞队列</li><li>LinkedTransferDeque，基于链表结构的无界阻塞队列</li><li>DelayQueue，使用优先级队列实现的延时无界阻塞队列</li><li>PriorityBlockingQueue，支持优先级排序的无界阻塞队列，在需要多线程支持、需要优先级队列支持的场景下会被运用</li><li>SynchronousQueue同步队列，一个不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移出操作，否则插入操作会一致阻塞（单个元素的队列）</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>阻塞队列在java中的一种典型使用场景是线程池，在线程池中，当提交的任务不能被立即得到执行的时候，线程池就会将提交的任务放到一个阻塞的任务队列中来，比如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">       return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>newFixedThreadPool使用了<strong>LinkedBlockingQueue</strong>这种阻塞队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>newCachedThreadPool使用了<strong>SynchronousQueue</strong>这种队列，这种队列的特点是不缓存数据，而是缓存线程，线程分为生产者线程和消费者线程，一个生产者线程和一个消费者线程是互补的，当一个生产者线程遇到一个消费者线程的时候就会直接进行数据交换，所以这种队列的技术点比较高，理解起来难度较大。一个线程只能缓存一个数据，当一个线程插入数据之后就会被阻塞，直到另外一个线程消费了其中的数据。</p><p>阻塞队列还提供了其他类型的队列，包括双端阻塞队列，延时阻塞队列，<strong>延时阻塞队列</strong>的使用可以在newScheduledThreadPool中找到，newScheduledThreadPool里面使用延时阻塞队列来调度周期性任务执行。</p><h2 id="BlockingQueue提供的一些方法"><a href="#BlockingQueue提供的一些方法" class="headerlink" title="BlockingQueue提供的一些方法"></a>BlockingQueue提供的一些方法</h2><p>根据插入和取出两种类型的操作，具体分为下面一些类型：<br>|操作类型| Throws Exception |Special Value|Blocks|Times out|<br>|–|–|–|–|–|<br>|插入| add(o) |offer(o)|put(o)|offer(o, timeout, unit)|<br>|取出(删除) | remove(o) |poll()|take()|poll(timeout, unit)|<br>|Examine(检查)| element() |peek()|not applicable|not applicable|</p><ul><li><strong>Throws Exception</strong> 类型的插入和取出在不能立即被执行的时候就会<strong>抛出异常</strong>。</li><li><strong>Special Value</strong> 类型的插入和取出在不能被立即执行的情况下会返回一个<strong>特殊的值（true 或者 false）</strong></li><li><strong>Blocked</strong> 类型的插入和取出操作在不能被立即执行的时候会<strong>阻塞线程</strong>直到可以操作的时候会被其他线程<strong>唤醒</strong></li><li><strong>Timed out</strong> 类型的插入和取出操作在不能立即执行的时候会<strong>被阻塞一定的时间</strong>，如果在指定的时间内没有被执行，那么会<strong>返回一个特殊值</strong></li></ul><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue需要你提供数组的大小，下面是ArrayBlockingQueue提供的三个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity): // 初始化数组大小</span><br><span class="line"></span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair): //初始化数组大小，并且设定是否是fair模式</span><br><span class="line"> </span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) //初始化数组大小，设置是否是fair模式，然后使用一个集合初始化阻塞队列</span><br></pre></td></tr></table></figure></p><p>在构造函数中有两个比较关键的参数，一个是capacity代表阻塞队列使用的数组的长度，另外一个是fair，代表阻塞队列的一种策略选择，用于构造用于线程同步的锁（ReentrantLock）是公平锁还是非公平锁，默认值为false，非公平锁</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue不存在容量的说法，任何插入操作都需要等待其他线程来消费，否则就会阻塞等待，也就是说，生产线程生产出一条数据之后就要等待消费者线程来将其消费掉，才能继续生产数据，否则就会阻塞等待消费。</p><p>SynchronousQueue通过使用Transferer类的transfer(E e, boolean timed, long nanos)方法来完成数据交易操作，根据fair模式和non-fair模式有两种类型的Transferer，fair模式对应于TransferQueue，non-fair模式对应TransferStack。</p><h2 id="总结：为什么使用BlockingQueue"><a href="#总结：为什么使用BlockingQueue" class="headerlink" title="总结：为什么使用BlockingQueue"></a>总结：为什么使用BlockingQueue</h2><p>使用阻塞队列，程序员不再需要关心什么时候该阻塞/唤醒线程</p>]]></content>
      
      
      <categories>
          
          <category> 阻塞队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用ideal创建java项目，并添加maven管理</title>
      <link href="/2019/05/13/%E7%94%A8ideal%E5%88%9B%E5%BB%BAjava%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%B9%B6%E6%B7%BB%E5%8A%A0maven%E7%AE%A1%E7%90%86/"/>
      <url>/2019/05/13/%E7%94%A8ideal%E5%88%9B%E5%BB%BAjava%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%B9%B6%E6%B7%BB%E5%8A%A0maven%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步-创建项目"><a href="#第一步-创建项目" class="headerlink" title="第一步 创建项目"></a>第一步 创建项目</h2><p>File—&gt;New—&gt;Project</p><h2 id="第二步-修改项目结构"><a href="#第二步-修改项目结构" class="headerlink" title="第二步 修改项目结构"></a>第二步 修改项目结构</h2><p>在项目的src下面创建main/java和main/resources目录.</p><p>File—&gt;Project Structure 或者快捷键Ctrl+Shift+Alt+s.<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2zp18rt01j31060kowf5.jpg" alt=""><br>将Sources定位到java目录下，将Resources定位到resources下面.</p><p>此处补充idea下的java项目关于不同资源的标识符。</p><ul><li>Sources 一般用于标注类似 src 这种可编译目录。有时候我们不单单项目的 src 目录要可编译，还有其他一些特别的目录也许我们也要作为可编译的目录，就需要对该目录进行此标注。只有 Sources 这种可编译目录才可以新建 Java 类和包，这一点需要牢记。</li><li>Tests 一般用于标注可编译的单元测试目录。在规范的 maven 项目结构中，顶级目录是src，maven 的 src 我们是不会设置为Sources 的，而是在其子目录 main 目录下的 java 目录，我们会设置为 Sources。而单元测试的目录是 src - test - java，这里的 java 目录我们就会设置为 Tests，表示该目录是作为可编译的单元测试目录。一般这个和后面几个我们都是在 maven 项目下进行配置的，但是我这里还是会先说说。从这一点我们也可以看出 IntelliJ IDEA 对 maven 项目的支持是比彻底的。</li><li>Resources 一般用于标注资源文件目录。在 maven 项目下，资源目录是单独划分出来的，其目录为：src - main -resources，这里的 resources 目录我们就会设置为 Resources，表示该目录是作为资源目录。资源目录下的文件是会被编译到输出目录下的。</li><li>Test Resources 一般用于标注单元测试的资源文件目录。在 maven 项目下，单元测试的资源目录是单独划分出来的，其目录为：src - test -resources，这里的 resources 目录我们就会设置为 Test Resources，表示该目录是作为单元测试的资源目录。资源目录下的文件是会被编译到输出目录下的。</li><li>Excluded 一般用于标注排除目录。被排除的目录不会被 IntelliJ IDEA 创建索引，相当于被 IntelliJ IDEA 废弃，该目录下的代码文件是不具备代码检查和智能提示等常规代码功能。</li><li>通过上面的介绍，我们知道对于非 maven 项目我们只要会设置 src 即可。<h2 id="第三步-添加maven管理"><a href="#第三步-添加maven管理" class="headerlink" title="第三步 添加maven管理"></a>第三步 添加maven管理</h2>选中项目——&gt;右键——&gt;选择Add Framworks Support——&gt;选择maven</li></ul><p>此时就会生成pom.xml文件，可以在该文件里面添加项目的依赖了</p>]]></content>
      
      
      <categories>
          
          <category> Ideal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ideal </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC的几个常用辅助类</title>
      <link href="/2019/05/13/JUC%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB/"/>
      <url>/2019/05/13/JUC%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ReentrantReadWriteLock-读写锁"><a href="#1-ReentrantReadWriteLock-读写锁" class="headerlink" title="1. ReentrantReadWriteLock 读写锁"></a>1. ReentrantReadWriteLock 读写锁</h2><ul><li>多个线程同时读一个资源类没有问题，所以为了满足并发量，读取共享资源应该可以同时进行。</li><li>但是写共享资源只能有一个线程。</li><li><p>写操作：原子+独占，整个过程必须是一个完整的统一体，中间不许被分割，被打断。</p><p>总结：</p></li><li>读-读可以共存</li><li>读-写不可以共存</li><li>写-写不可以共存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">写锁</span><br><span class="line">reentrantReadWriteLock.writeLock().lock();</span><br><span class="line">reentrantReadWriteLock.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">读锁</span><br><span class="line">reentrantReadWriteLock.readLock().lock();</span><br><span class="line">reentrantReadWriteLock.readLock().unlock();</span><br></pre></td></tr></table></figure><h2 id="2-CountDownLatch-减少计数"><a href="#2-CountDownLatch-减少计数" class="headerlink" title="2. CountDownLatch 减少计数"></a>2. CountDownLatch 减少计数</h2><ul><li>CountDownLatch 主要有两个方法，当一个或多个线程调用await 方法时，这些线程会阻塞。</li><li>其它线程调用countDown 方法会将计数器减1(调用countDown 方法的线程不会阻塞)，当计数器的值变为0 时，因await 方法阻塞的线程会被唤醒，继续执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//自定义计数值</span><br><span class="line">java.util.concurrent.CountDownLatch countDownLatch = new java.util.concurrent.CountDownLatch(6);</span><br><span class="line">//计数值减1</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line">//线程阻塞</span><br><span class="line">countDownLatch.await();</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-CyclicBarrier-循环栅栏"><a href="#3-CyclicBarrier-循环栅栏" class="headerlink" title="3. CyclicBarrier 循环栅栏"></a>3. CyclicBarrier 循环栅栏</h2><ul><li>CyclicBarrier 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞,直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</li><li>线程进入屏障通过CyclicBarrier 的await()方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()-&gt;&#123;System.out.println(&quot;召唤神龙&quot;);&#125;);</span><br><span class="line"></span><br><span class="line">cyclicBarrier.await();</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-Semaphore-信号灯"><a href="#4-Semaphore-信号灯" class="headerlink" title="4. Semaphore 信号灯"></a>4. Semaphore 信号灯</h2><p>在信号量上我们定义两种操作：</p><ul><li>acquire（获取） 当一个线程调用acquire 操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</li><li>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</li><li>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = new Semaphore(3);  //模拟3个车位</span><br><span class="line"></span><br><span class="line">semaphore.acquire();//获取</span><br><span class="line"></span><br><span class="line">semaphore.release();//释放</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java插件Lombok的介绍和使用方法</title>
      <link href="/2019/05/13/Java%E6%8F%92%E4%BB%B6Lombok%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/05/13/Java%E6%8F%92%E4%BB%B6Lombok%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Lombok背景介绍"><a href="#1-Lombok背景介绍" class="headerlink" title="1. Lombok背景介绍"></a>1. Lombok背景介绍</h2><p>官方介绍如下：</p><blockquote><p>Project Lombok makes java a spicier language by adding ‘handlers’ that know how to build and compile simple, boilerplate-free, not-quite-java code.<br>大致意思是Lombok通过增加一些“处理程序”，可以让java变得简洁、快速。</p></blockquote><h2 id="2-Lombok使用方法"><a href="#2-Lombok使用方法" class="headerlink" title="2. Lombok使用方法"></a>2. Lombok使用方法</h2><p>Lombok能以简单的<strong>注解形式</strong>来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法，而且需要维护，当属性多时会出现大量的getter/setter方法，这些显得很冗长也没有太多技术含量，一旦修改属性，就容易出现忘记修改对应方法的失误。</p><p>Lombok能通过注解的方式，<strong>在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法</strong>。出现的神奇就是在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。这样就省去了手动重建这些代码的麻烦，使代码看起来更简洁些。</p><p>Lombok的使用跟引用jar包一样，可以在官网（<a href="https://projectlombok.org/download" target="_blank" rel="noopener">https://projectlombok.org/download</a>）下载jar包，也可以使用maven添加依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.16.20&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="2-1-Data"><a href="#2-1-Data" class="headerlink" title="2.1 @Data"></a>2.1 @Data</h3><p>@Data注解在类上，会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</p><h3 id="2-2-Getter-Setter"><a href="#2-2-Getter-Setter" class="headerlink" title="2.2 @Getter/@Setter"></a>2.2 @Getter/@Setter</h3><p>如果觉得@Data太过残暴（因为@Data集合了@ToString、@EqualsAndHashCode、@Getter/@Setter、@RequiredArgsConstructor的所有特性）不够精细，可以使用@Getter/@Setter注解，此注解在属性上，可以为相应的属性自动生成Getter/Setter方法。</p><h3 id="2-3-NonNull"><a href="#2-3-NonNull" class="headerlink" title="2.3 @NonNull"></a>2.3 @NonNull</h3><p>该注解用在属性或构造器上，Lombok会生成一个非空的声明，可用于校验参数，能帮助避免空指针。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import lombok.NonNull;</span><br><span class="line"></span><br><span class="line">public class NonNullExample extends Something &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  </span><br><span class="line">  public NonNullExample(@NonNull Person person) &#123;</span><br><span class="line">    super(&quot;Hello&quot;);</span><br><span class="line">    this.name = person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用Lombok：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import lombok.NonNull;</span><br><span class="line"></span><br><span class="line">public class NonNullExample extends Something &#123;</span><br><span class="line">  private String name;</span><br><span class="line">  </span><br><span class="line">  public NonNullExample(@NonNull Person person) &#123;</span><br><span class="line">    super(&quot;Hello&quot;);</span><br><span class="line">    if (person == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.name = person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-4-Cleanup"><a href="#2-4-Cleanup" class="headerlink" title="2.4 @Cleanup"></a>2.4 @Cleanup</h3><p>该注解能帮助我们自动调用close()方法，很大的简化了代码。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import lombok.Cleanup;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class CleanupExample &#123;</span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    @Cleanup InputStream in = new FileInputStream(args[0]);</span><br><span class="line">    @Cleanup OutputStream out = new FileOutputStream(args[1]);</span><br><span class="line">    byte[] b = new byte[10000];</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      int r = in.read(b);</span><br><span class="line">      if (r == -1) break;</span><br><span class="line">      out.write(b, 0, r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用Lombok：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class CleanupExample &#123;</span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    InputStream in = new FileInputStream(args[0]);</span><br><span class="line">    try &#123;</span><br><span class="line">      OutputStream out = new FileOutputStream(args[1]);</span><br><span class="line">      try &#123;</span><br><span class="line">        byte[] b = new byte[10000];</span><br><span class="line">        while (true) &#123;</span><br><span class="line">          int r = in.read(b);</span><br><span class="line">          if (r == -1) break;</span><br><span class="line">          out.write(b, 0, r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        if (out != null) &#123;</span><br><span class="line">          out.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (in != null) &#123;</span><br><span class="line">        in.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-5-EqualsAndHashCode"><a href="#2-5-EqualsAndHashCode" class="headerlink" title="2.5 @EqualsAndHashCode"></a>2.5 @EqualsAndHashCode</h3><p>默认情况下，会使用所有非静态（non-static）和非瞬态（non-transient）属性来生成equals和hasCode，也能通过exclude注解来排除一些属性。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line">@EqualsAndHashCode(exclude=&#123;&quot;id&quot;, &quot;shape&quot;&#125;)</span><br><span class="line">public class EqualsAndHashCodeExample &#123;</span><br><span class="line">  private transient int transientVar = 10;</span><br><span class="line">  private String name;</span><br><span class="line">  private double score;</span><br><span class="line">  private Shape shape = new Square(5, 10);</span><br><span class="line">  private String[] tags;</span><br><span class="line">  private int id;</span><br><span class="line">  </span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @EqualsAndHashCode(callSuper=true)</span><br><span class="line">  public static class Square extends Shape &#123;</span><br><span class="line">    private final int width, height;</span><br><span class="line">    </span><br><span class="line">    public Square(int width, int height) &#123;</span><br><span class="line">      this.width = width;</span><br><span class="line">      this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-6-ToString"><a href="#2-6-ToString" class="headerlink" title="2.6 @ToString"></a>2.6 @ToString</h3><p>类使用@ToString注解，Lombok会生成一个toString()方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割。</p><p>通过将includeFieldNames参数设为true，就能明确的输出toString()属性。这一点是不是有点绕口，通过代码来看会更清晰些。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">@ToString(exclude=&quot;id&quot;)</span><br><span class="line">public class ToStringExample &#123;</span><br><span class="line">  private static final int STATIC_VAR = 10;</span><br><span class="line">  private String name;</span><br><span class="line">  private Shape shape = new Square(5, 10);</span><br><span class="line">  private String[] tags;</span><br><span class="line">  private int id;</span><br><span class="line">  </span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return this.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @ToString(callSuper=true, includeFieldNames=true)</span><br><span class="line">  public static class Square extends Shape &#123;</span><br><span class="line">    private final int width, height;</span><br><span class="line">    </span><br><span class="line">    public Square(int width, int height) &#123;</span><br><span class="line">      this.width = width;</span><br><span class="line">      this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用Lombok：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class ToStringExample &#123;</span><br><span class="line">  private static final int STATIC_VAR = 10;</span><br><span class="line">  private String name;</span><br><span class="line">  private Shape shape = new Square(5, 10);</span><br><span class="line">  private String[] tags;</span><br><span class="line">  private int id;</span><br><span class="line">  </span><br><span class="line">  public String getName() &#123;</span><br><span class="line">    return this.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class Square extends Shape &#123;</span><br><span class="line">    private final int width, height;</span><br><span class="line">    </span><br><span class="line">    public Square(int width, int height) &#123;</span><br><span class="line">      this.width = width;</span><br><span class="line">      this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">      return &quot;Square(super=&quot; + super.toString() + &quot;, width=&quot; + this.width + &quot;, height=&quot; + this.height + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override public String toString() &#123;</span><br><span class="line">    return &quot;ToStringExample(&quot; + this.getName() + &quot;, &quot; + this.shape + &quot;, &quot; + Arrays.deepToString(this.tags) + &quot;)&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-7-NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor"><a href="#2-7-NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor" class="headerlink" title="2.7 @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor"></a>2.7 @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</h3><p>无参构造器、部分参数构造器、全参构造器。Lombok没法实现多种参数构造器的重载。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import lombok.AccessLevel;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.NonNull;</span><br><span class="line"></span><br><span class="line">@RequiredArgsConstructor(staticName = &quot;of&quot;)</span><br><span class="line">@AllArgsConstructor(access = AccessLevel.PROTECTED)</span><br><span class="line">public class ConstructorExample&lt;T&gt; &#123;</span><br><span class="line">  private int x, y;</span><br><span class="line">  @NonNull private T description;</span><br><span class="line">  </span><br><span class="line">  @NoArgsConstructor</span><br><span class="line">  public static class NoArgsExample &#123;</span><br><span class="line">    @NonNull private String field;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用Lombok：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> public class ConstructorExample&lt;T&gt; &#123;</span><br><span class="line">  private int x, y;</span><br><span class="line">  @NonNull private T description;</span><br><span class="line">  </span><br><span class="line">  private ConstructorExample(T description) &#123;</span><br><span class="line">    if (description == null) throw new NullPointerException(&quot;description&quot;);</span><br><span class="line">    this.description = description;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static &lt;T&gt; ConstructorExample&lt;T&gt; of(T description) &#123;</span><br><span class="line">    return new ConstructorExample&lt;T&gt;(description);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @java.beans.ConstructorProperties(&#123;&quot;x&quot;, &quot;y&quot;, &quot;description&quot;&#125;)</span><br><span class="line">  protected ConstructorExample(int x, int y, T description) &#123;</span><br><span class="line">    if (description == null) throw new NullPointerException(&quot;description&quot;);</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">    this.description = description;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static class NoArgsExample &#123;</span><br><span class="line">    @NonNull private String field;</span><br><span class="line">    </span><br><span class="line">    public NoArgsExample() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-Idea下安装Lombok插件"><a href="#4-Idea下安装Lombok插件" class="headerlink" title="4. Idea下安装Lombok插件"></a>4. Idea下安装Lombok插件</h2><p>可直接通过搜索获取<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zro1xj2oj30tl0jgtbq.jpg" alt=""><br>另外还有一个关键点：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zrsvsv66j30zw0bk0v3.jpg" alt=""><br>接下来就可以编码了<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zrt7mtfyj31bu0yc146.jpg" alt=""></p><h2 id="5-Lombok的优缺点"><a href="#5-Lombok的优缺点" class="headerlink" title="5. Lombok的优缺点"></a>5. Lombok的优缺点</h2><p>优点：</p><ul><li>能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率</li><li>让代码变得简洁，不用过多的去关注相应的方法</li><li>属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等</li></ul><p>缺点：</p><ul><li>不支持多种参数构造器的重载</li><li>虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>Lombok虽然有很多优点，但Lombok更类似于一种IDE插件，项目也需要依赖相应的jar包。</p><p>Lombok依赖jar包是因为编译时要用它的注解，为什么说它又类似插件？因为在使用时，eclipse或IntelliJ IDEA都需要安装相应的插件，在编译器编译时通过操作AST（抽象语法树）改变字节码生成，变向的就是说它在改变java语法。它不像spring的依赖注入或者mybatis的ORM一样是运行时的特性，而是编译时的特性。这里我个人最感觉不爽的地方就是对插件的依赖！因为Lombok只是省去了一些人工生成代码的麻烦，但IDE都有快捷键来协助生成getter/setter等方法，也非常方便。</p>]]></content>
      
      
      <categories>
          
          <category> Lombok </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ideal </tag>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ideal如何自定义模板</title>
      <link href="/2019/05/13/ideal%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/05/13/ideal%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="关于模板-Template"><a href="#关于模板-Template" class="headerlink" title="关于模板(Template)"></a>关于模板(Template)</h2><blockquote><p>( Editor - Live Templates 和 Editor - General - Postfix Completion )</p></blockquote><h3 id="1-Live-Templates-实时代码模板-功能介绍"><a href="#1-Live-Templates-实时代码模板-功能介绍" class="headerlink" title="1. Live Templates(实时代码模板)功能介绍"></a>1. Live Templates(实时代码模板)功能介绍</h3><p>它的原理就是配置一些常用代码字母缩写，在输入简时可以出现你预定义的固定模式的代码，使得开发效率大提高 ，同时也可以增加个性化 。最简单的例子 就是在Java中输入sout会出现System.out.println();</p><h3 id="2-已有的常用模板"><a href="#2-已有的常用模板" class="headerlink" title="2. 已有的常用模板"></a>2. 已有的常用模板</h3><p><strong>Postfix Completion 默认如下：</strong><br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zqzumrjnj30j40g6dhp.jpg" alt=""><br><strong>Live Templates 默认如下：</strong><br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zr14wmdcj30mb0bydgq.jpg" alt=""><br>二者的区别：Live Templates 可以自定义，而 Postfix Completion 不行。有些操作二者都提供了模板，但Postfix Completion 较之 Live Templates 快0.01S。</p><p>举例：</p><ul><li>fori：可生成for循环</li><li>iter：可生成增强型for循环</li><li>itar：可生成普通for循环</li><li>list.for：可生成集合list的for循环，又如：list.fori 或 list.forr</li><li>ifn：可生成if(xxx = null)</li><li>prsf：可生成private static final</li></ul><h2 id="3-自定义模板"><a href="#3-自定义模板" class="headerlink" title="3. 自定义模板"></a>3. 自定义模板</h2><p>先定义一个模板的分组：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zrau8uirj30oe09g75r.jpg" alt=""><br>选中自定义的模板组，点击“+”来定义模板<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2zrbx61caj30ix07a74p.jpg" alt=""><br>自定义步骤如下：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2zrd75ervj30k20bagmc.jpg" alt=""></p><ol><li>Abbreviation：模板的缩写</li><li>Description：模板的描述</li><li>Template text：模板的代码片段</li><li>Define：应用范围</li></ol>]]></content>
      
      
      <categories>
          
          <category> Ideal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ideal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis初探</title>
      <link href="/2019/05/10/Redis%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/05/10/Redis%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Sql对比NoSql"><a href="#Sql对比NoSql" class="headerlink" title="Sql对比NoSql"></a>Sql对比NoSql</h2><p>Sql：</p><ul><li>访问和处理关系数据库的计算机标准语言。mysql数据库，数据库以“文件形式存储在硬盘”里边。</li></ul><p>NoSql：</p><ul><li><strong>CAP： 强一致性（C），可用性（A），分区容错性（P）</strong></li><li>CAP核心理论：最多只能很好的满足两个特性</li><li>CAP的3进2：分区容错性必须要实现，只能在一致性和可用性之间权衡</li><li><strong>redis：CP</strong></li><li>网站架构的大多选择：AP</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="1-什么是Redis"><a href="#1-什么是Redis" class="headerlink" title="1.  什么是Redis"></a>1.  什么是Redis</h3><p>Redis是远程数据服务，内存高速缓存数据库，支持丰富的数据结构，如String、list、hash、set、sorted set，可持久化，保证了数据安全。<strong>Redis是做数据缓存的。</strong></p><p>缓存有两种类型：数据缓存、页面缓存</p><p>使用缓存减轻数据库的负载。</p><p>在开发的时候如果有一些数据在短时间之内不会发生变化，而他们还要被频繁的访问，为了提高用户的请求速度和降低网站的负载，就把这些数据放到一个读取速度更快的介质上（或者是通过较少的计算量就可以获得该数据），该行为就称作对该数据的缓存。</p><p>该介质可以是文件、数据库、内存，内存经常用于数据缓存。</p><p>缓存的两种形式：<br> <font color="#DC143C">页面缓存</font>经常用在CMS内存管理系统里边<br> <font color="#DC143C">数据缓存</font>经常用于页面的具体数据里边</p><p>新闻页面（内容单一，集中）适合做页面缓存<br>商品页面的组成部分根据业务特点，各个部分数据比较独立，适合给他们分别做数据缓存。</p><h3 id="2-redis和memcache比较"><a href="#2-redis和memcache比较" class="headerlink" title="2.  redis和memcache比较"></a>2.  redis和memcache比较</h3><ul><li>Redis和Memcache都是将数据存放在内存中，都是<strong>内存数据库</strong>。不过memcache还可用于缓存其他东西，例如图片、视频等等。</li><li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持master-slave（主从）模型应用</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</li><li>Redis单个value的最大限制是1GB，memcached只能保存1MB的数据。</li><li>在Redis中，<strong>并不是所有的数据都一直存储在内存中</strong>的。这是和Memcached相比一个最大的区别（我个人是这么认为的）。</li></ul><h3 id="3-redis常见使用场景"><a href="#3-redis常见使用场景" class="headerlink" title="3.  redis常见使用场景"></a>3.  redis常见使用场景</h3><ul><li>会话缓存（最常用）</li><li>消息队列（如支付）</li><li>活动排行榜或计数</li><li>发布、订阅消息（消息通知）</li><li>商品列表，评论列表</li></ul><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="1-key的操作"><a href="#1-key的操作" class="headerlink" title="1.  key的操作"></a>1.  key的操作</h3><p>在redis里边，除了“\n”和空格不能作为名字的组成部分，其他内容都可以作为key的名字部分。名字长度不作要求。</p><h3 id="2-String类型操作"><a href="#2-String类型操作" class="headerlink" title="2.  String类型操作"></a>2.  String类型操作</h3><ul><li>String是redis最基本的类型</li><li>Redis的string可以包含任何数据。包括jpg图片或者序列化对象</li><li>单个value值最大上限是1G字节</li><li><p>如果只用string类型，redis就可以被看做加上持久化特性的memcache</p></li><li><p><font color="#DC143C">incr</font>：increament增长</p><pre><code>该指令可以对key进行累加1操作，默认是累加1操作，类似i++操作该指令可以针对**新key**或**已有key**进行操作新key：创建该key并累加1，其值为1已有key：key的信息值类型要求必须为整型的</code></pre></li><li><p><font color="#DC143C">decr</font>的操作模式与incr一致，不过其是减1操作</p></li><li><p><font color="#DC143C">substr</font>：对内容进行截取，包括<strong>start</strong>和<strong>end</strong>标记位置</p></li></ul><h3 id="3-数据类型List链表"><a href="#3-数据类型List链表" class="headerlink" title="3.  数据类型List链表"></a>3.  数据类型List链表</h3><p>list类型其实就是一个双向链表。通过push，pop操作从链表的头部或者尾部添加删除元素。这使得list既可以用作栈，也可以用作队列。</p><p>List类型操作：</p><ul><li><strong>lpush key string</strong>：在key对应list的头部添加字符串元素</li><li><strong>rpop key</strong>：从list的尾部删除元素，并返回删除元素</li><li><strong>llen key</strong> 返回 key：对应list的长度，key不存在返回0，如果key对应key不是list返回错误</li><li><strong>lrange key start end</strong>：返回指定区间内的元素，下标从0开始</li><li><strong>rpush key string</strong>：同上，在尾部添加</li><li><strong>lpop key</strong>：从list的头部删除元素，并返回删除元素</li><li><strong>ltrim key start end</strong>：截取list，保留指定区间内元素</li></ul><p><strong><em>list链表类型应用场合：</em></strong></p><p><font color="#DC143C">获得最新的10个登录用户信息</font>：select * from user order by logintime desc limit 10；<br>    以上sql语句可以实现用户需求，但是数据多的时候，全部数据都要受到影响，对数据库的复杂比较高。必要情况还需要给关键字段（id或logintime）设置索引，索引也比较耗费系统资源。<br>    如果通过list链表实现以上功能，可以在list链表中只保留最新的10个数据，每进来一个新数据就删除一个旧数据。每次就可以从链表中直接获得需要的数据。极大节省各方面资源消耗。</p><h3 id="4-set集合类型"><a href="#4-set集合类型" class="headerlink" title="4.  set集合类型"></a>4.  set集合类型</h3><ul><li>redis的set是string类型的<strong>无序集合</strong>。</li><li>set元素最大可以包含（2的32次方-1）个元素</li><li>关于set集合类型除了基本的添加删除操作，其他有用的操作还包括集合的取<strong>并集，交集，差集</strong>。通过这些操作可以很容易的实现sns的<font color="#DC143C">好友推荐功能</font>。</li><li>注意：每个集合中的<strong>各个元素不能重复</strong></li></ul><p>set类型操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">·sadd key member：添加一个string元素到key对应的set集合中，成功返回1，如果元素已经在                        set集合中，返回0，key对应的set不存在返回错误。</span><br><span class="line">·sren key member [member]:从key对应set中移除给定元素，成功返回1</span><br><span class="line">·smove p1 p2 member：从p1对应set中移除member并添加到p2对应set中</span><br><span class="line">·scard key：返回set元素个数</span><br><span class="line">·sismember key member：判断set的元素个数</span><br><span class="line">·sinter key1 key2...keyN：返回所有给定key的交集</span><br><span class="line">·sunion key1 key2...keyN：返回所有给定并集</span><br><span class="line">·sdiff key1 key2...keyN:返回所有给定key的差集</span><br><span class="line">·smembers key：返回key对应set的所有元素，结果是无序的。</span><br></pre></td></tr></table></figure></p><p><strong><em>set类型应用场合</em></strong>：<strong>qq好友推荐</strong></p><p>Tom朋友圈（与某某是好友）：mary jack xiaoming wang5 wang6<br>Linken朋友圈（与某某是好友）：yuehan daxiang luce wang5 wang6<br>创建Tom的朋友圈：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2w118a1w8j309104kmx4.jpg" alt=""><br>创建linken朋友圈：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2w149rpwxj309y06c0sr.jpg" alt=""><br>对两个set取交集和并集：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2w14svm04j309w049749.jpg" alt=""><br>取差集：<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2w151cr1pj309i03o0so.jpg" alt=""></p><h3 id="5-Sort-Set排序集合类型"><a href="#5-Sort-Set排序集合类型" class="headerlink" title="5.  Sort Set排序集合类型"></a>5.  Sort Set排序集合类型</h3><ul><li>和set一样sorted set也是string类型元素的集合，不同的是每个元素都会关联一个<strong>权</strong>。通过<strong>权值</strong>可以有序的获取集合中的元素。</li><li>排序集合中的每个元素都是<strong>值、权的组合</strong>，之前的set集合类型每个元素就只有一个值。</li></ul><p>sort set排序类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">·zadd key score member：添加元素到集合，元素在集合中存在则更新对应score。</span><br><span class="line">·zren key member：删除指定元素，1表示成功，如果元素不存在返回0</span><br><span class="line">·zincrby key incr member：按照incr幅度增加对应member的score值，返回score值</span><br><span class="line">·zrank key member：返回指定元素在集合中的排名（下标），集合中元素是按score从小到大排序      的。</span><br><span class="line">·zrevrank key member：同上，但是集合中元素是按score从大到小排序的</span><br><span class="line">·zrange key start end：类似lrange操作从集合中去指定区间的元素。返回的是有序结果</span><br><span class="line">·zrevrange key start end：同上，返回结果是按score逆序的。</span><br><span class="line">·zcard key：返回集合中元素个数。</span><br><span class="line">·zscore key element：返回给定元素对应的score</span><br><span class="line">·zrenrangeburank key min max：删除集合中排名在给定区间的元素。</span><br></pre></td></tr></table></figure></p><p><strong><em>Sort set类型适合场合：</em></strong></p><p><font color="#DC143C">获得热门帖子（回复量）信息</font>：select * from message order by backnum desc limit 5；（以上需求可以通过简单的sql语句实现，但是sql语句比较耗费mysql数据库资源）</p><p>案例：获得热门帖子信息（前5）：<br>我们只做一个sort set排序集合，里边只保留5个元素信息，该5个元素是回复量最高的每个帖子被回复的时候，都有机会进入该集合里边，但是只有回复量最高的前5个帖子会存在于该集合，回复量低的就被删除。</p><h3 id="6-数据类型Hash"><a href="#6-数据类型Hash" class="headerlink" title="6.  数据类型Hash"></a>6.  数据类型Hash</h3><ul><li>是一个键值对集合，是string类型的field和value的映射表，适合<strong>存储对象</strong></li><li>hash数据类型存储的数据与mysql数据库中存储的一条记录极为相似。</li></ul><h2 id="持久化功能"><a href="#持久化功能" class="headerlink" title="持久化功能"></a>持久化功能</h2><p>Redis为了内部数据的安全考虑，会把本身的数据以<strong>文件</strong>形式保存到硬盘中一份，在服务器重启之后会把硬盘的数据恢复到内存（redis）的里边。</p><p>数据保存到硬盘的过程就称为“持久化”效果。</p><h3 id="1-snap-shotting快照持久化（RDB持久化）（保存结果）"><a href="#1-snap-shotting快照持久化（RDB持久化）（保存结果）" class="headerlink" title="1.  snap shotting快照持久化（RDB持久化）（保存结果）"></a>1.  snap shotting快照持久化（RDB持久化）（保存结果）</h3><ul><li>该持久化默认开启，一次性把redis中全部的数据保存一份存储到硬盘中，适合大规模数据恢复，但数据一致性和完整性差</li><li>手动发起快照持久化指令：<strong>bgsave</strong>指令</li><li>默认的文件名为：<strong>dump.rdb</strong></li><li>快照持久化的备份频率：<br>save 900 1 #900秒内如果超过1个key被修改，则发起快照保存<br>save 300 10 #300秒超过10个key被修改，发起快照保存<br>save 60 10000 #60秒超过10000个key被修改，发起快照保存</li></ul><h3 id="2-append-only-file（AOF持久化）（保存操作）"><a href="#2-append-only-file（AOF持久化）（保存操作）" class="headerlink" title="2.  append only file（AOF持久化）（保存操作）"></a>2.  append only file（AOF持久化）（保存操作）</h3><ul><li>本质：把用户执行的每个“写”指令（添加、删除、修改）都备份到文件中，还原数据的时候就是执行具体写指令而已。</li><li>开启AOF持久化（会清空redis内部的数据）</li><li>默认没有开启</li><li>手动开启，完整性高，但内容较多的情况下会影响恢复效率</li></ul><h3 id="3-应用场合"><a href="#3-应用场合" class="headerlink" title="3.  应用场合"></a>3.  应用场合</h3><ul><li>若只是使用redis作为缓存，可关闭持久化</li><li>若使用持久化功能，rdb与aof都建议开启</li></ul><h3 id="4-RDB持久化和AOF持久化的对比"><a href="#4-RDB持久化和AOF持久化的对比" class="headerlink" title="4.  RDB持久化和AOF持久化的对比"></a>4.  RDB持久化和AOF持久化的对比</h3><p>RDB：</p><ul><li>优点：节省磁盘空间，恢复速度快</li><li>缺点：数据庞大时仍然消耗性能，如果redis down掉会丢失最后一次快照的所有更改</li></ul><p>AOF:</p><ul><li>优点：丢失数据概率更低，日志文件可读性高，可处理错误的操作</li><li>缺点 ：相比RDB更占空间，恢复/备份更慢，读写同步会有性能压力</li></ul><h2 id="主从模式-master—slave"><a href="#主从模式-master—slave" class="headerlink" title="主从模式 master—slave"></a>主从模式 master—slave</h2><ul><li>为了降低每个redis服务器的负载，可以多设置几个，并做主从模式，一个服务器负责“写”数据，其他服务器负责“读”数据，主服务器数据会“自动”同步给从服务器。</li><li>Slave服务器默认禁止写操作。</li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ul><li>主从复制  <strong>作用：读写分离，容灾恢复</strong></li><li>配从不配主。常用三招：一主二仆、薪火相传、反客为主</li></ul><h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><ul><li>主从切换，多哨兵模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> NoSql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ideal项目如何与github同步(pull,push)</title>
      <link href="/2019/05/09/Ideal%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E4%B8%8Egithub%E5%90%8C%E6%AD%A5-pull-push/"/>
      <url>/2019/05/09/Ideal%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E4%B8%8Egithub%E5%90%8C%E6%AD%A5-pull-push/</url>
      
        <content type="html"><![CDATA[<h2 id="从GitHub更新项目到Ideal（pull）"><a href="#从GitHub更新项目到Ideal（pull）" class="headerlink" title="从GitHub更新项目到Ideal（pull）"></a>从GitHub更新项目到Ideal（pull）</h2><ol><li>右击项目名 –&gt; Git –&gt; Repository –&gt; pull</li></ol><h2 id="从Ideal更新项目到GitHub（push）"><a href="#从Ideal更新项目到GitHub（push）" class="headerlink" title="从Ideal更新项目到GitHub（push）"></a>从Ideal更新项目到GitHub（push）</h2><ol><li>右击项目名 –&gt; Git –&gt; commit diretory</li><li>右击项目名 –&gt; Git –&gt; Repository –&gt; push</li></ol>]]></content>
      
      
      <categories>
          
          <category> Ideal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ideal </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA新建Maven web项目</title>
      <link href="/2019/05/09/IntelliJ-IDEA%E6%96%B0%E5%BB%BAMaven-web%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/05/09/IntelliJ-IDEA%E6%96%B0%E5%BB%BAMaven-web%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>第一次使用Intellij idea，有诸多不熟悉，之处，网上很多教程千差万别，为日后少走弯路，特此记录。</p><p>步骤一：首先先创建一个project，打开-File-New-Project </p><p>步骤二：你要选择maven然后按照下面图片 的指示操作就可以了<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2v1hiedd3j30jv0g3q5d.jpg" alt=""><br>点击next按钮<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2v1iidlgtj30iw0670t3.jpg" alt=""><br>点击next，该图为示例图片，XX为你自己设置的项目名，如im，<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2v1jhtgvzj30me0iz3z4.jpg" alt=""><br>之后点击finish，等idea完全加载完成后，就可以看到项目已经生成了（有时也缺少下图中的resources目录，也需要手动创建）<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2v1la0jfjj30ic0h7ab6.jpg" alt=""><br>步骤三：配置tocat服务器。点击那个倒立的三角形，然后点击Edit Configurations<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2v1owauzdj30uc0k8q5s.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2v1p810f9j30uc0kj42c.jpg" alt=""><br>配置artifacts，标签由Server跳到Deploment，点击小铅笔一样的图标对artifacts进行配置<br><img src="http://ww1.sinaimg.cn/large/006pqaYvly1g2v1t6fu1mj30ty0o9wf7.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Ideal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ideal </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Ideal上传本地项目至GitHub</title>
      <link href="/2019/05/08/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Ideal%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E8%87%B3GitHub/"/>
      <url>/2019/05/08/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Ideal%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E8%87%B3GitHub/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA配置github并上传项目"><a href="#IDEA配置github并上传项目" class="headerlink" title="IDEA配置github并上传项目"></a>IDEA配置github并上传项目</h1><h2 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a>配置GitHub</h2><ol><li><p>在github中创建一个账号：<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">https://github.com/join?source=header-home</a></p></li><li><p>下载并安装git：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p></li><li><p>安装成功后打开Git Bash，输入下列命令，设置git全局用户名和邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>在IDEA中设置Git，在File–&gt;Setting-&gt;Version Control–&gt;Git–&gt;Path to Git executable选择你的git安装后的git.exe文件，然后点击Test，测试是否设置成功<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2u6ku0q2ij30s70c9jsn.jpg" alt=""><br>要是在bin目录下没找到此exe，不妨看看cmd目录下面有没有，也就是c://~install/cmd/git.exe;</p></li><li><p>在IDEA中设置GitHub，File–&gt;Setting-&gt;Version Control–&gt;GibHub<br> Host：github.com<br> Token：点击Create API Token，输入在github中注册的用户名和密码生成token<br>　点击Test，测试是否连接成功<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2u6mtqppej30sb0d0jsj.jpg" alt=""></p></li><li>创建本地仓库，VCS–&gt;Import into Version Control–&gt;Create Git Repository…<br>(要给自己的项目建立一个git本地仓库,因为后面修改代码应当先上传到本地仓库，再从本地仓库上传到github上)<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2u6ow38xjj30s90ea0ua.jpg" alt="">在弹框中选中项目所在的位置，点击OK，此时项目文件全部变成红色（若选中其他位置，则git–&gt;add不可点选，不知为何）</li><li>上传项目到本地仓库，项目右键选择Git–&gt;add，此时项目文件变成绿色，此时文件只是处于暂存区，并没有真正进入到版本库（本地）中。(本步骤是接着第6步骤的，把代码add到暂存区当中)<img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2u6taf24bj30la0fjdi6.jpg" alt=""></li><li>项目右键Git–&gt; Commit Directory，在弹窗中输入Commit Message，点击commit，此时项目文件从暂存区真正进入版本库中，项目文件变成白色。<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2u6vkwmlhj30j40g0dhx.jpg" alt=""><br>(此步骤接着第7步骤，只有commint directory才是提交到本地仓库)<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2u6w9s6nvj30kw0mzgo6.jpg" alt=""></li><li>上传项目到GitHub中，VCS–&gt;Import into Version Control–&gt;Share Project on GitHub，在弹框中输入仓库名和描述，点击Share，即可是上传，中间会弹窗输入GitHub的用户名和密码（已输入过用户名和密码并记住的不会再次弹框输入），上传成功后IDEA右下角会给出提示<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2u6x0spe6j30bn0760su.jpg" alt=""></li><li>提交修改文件到GitHub<br>新增文件（红色），右键–&gt;Git–&gt;add，将新增的文件加入本地仓库，此时文件变绿色<br>修改文件（蓝色）<br>在项目右键–&gt;Git–&gt;Commit Directory，查看有变动的文件并输入Commit Message，点击Commit and Push…<br>提交后会进行语法检查，若存在错误或警告会给出确认提示，点击Commit，弹出Push框，点击Push，上传GitHub成功（因为此时是你自己的项目，所以有权限提交，一般git到别人的项目，应当叫别人给与权限你才能提交）<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2u701vzhhj30aa07q74h.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2u70li5i4j30l40mx76g.jpg" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> Ideal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ideal </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库sql实战(2)</title>
      <link href="/2019/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93sql%E5%AE%9E%E6%88%98-2/"/>
      <url>/2019/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93sql%E5%AE%9E%E6%88%98-2/</url>
      
        <content type="html"><![CDATA[<ol><li>获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=’9999-01-01’。结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `dept_emp` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `dept_no` char(4) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">CREATE TABLE `dept_manager` (</span><br><span class="line">    `dept_no` char(4) NOT NULL,</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`dept_no`));</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, m.emp_no manager_no from dept_emp e inner join dept_manager m </span><br><span class="line">on e.dept_no = m.dept_no </span><br><span class="line"><span class="built_in">where</span> e.to_date=<span class="string">'9999-01-01'</span> and m.to_date=<span class="string">'9999-01-01'</span> and e.emp_no&lt;&gt;m.emp_no</span><br></pre></td></tr></table></figure><ul><li>用 INNER JOIN 连接两张表，因为要输出自己的经理，得知自己与经理的部门要相同，故有限制条件 de.dept_no = dm.dept_no</li><li>再用 WHERE 限制当前员工与当前经理的条件，即 dm.to_date 等于 ‘9999-01-01’ 、de.to_date 等于 ‘9999-01-01’ 、 de.emp_no 不等于 dm.emp_no <strong>(e.emp_no&lt;&gt;m.emp_no)</strong></li><li>为了增强代码可读性，将 dept_emp 用别名 de 代替，dept_manager 用 dm 代替，最后根据题意将 de.emp_no 用别名 manager_no 代替后输出</li></ul><hr><ol start="2"><li>获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `dept_emp` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `dept_no` char(4) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">CREATE TABLE `salaries` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `salary` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select e.dept_no, e.emp_no, max(s.salary) salary from dept_emp e inner join salaries s </span><br><span class="line">on e.emp_no = s.emp_no </span><br><span class="line"><span class="built_in">where</span> e.to_date = <span class="string">'9999-01-01'</span> and s.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line">group by e.dept_no</span><br></pre></td></tr></table></figure><ul><li>先用INNER JOIN连接两张表，限制条件是两张表的emp_no相同，即d.emp_no = s.emp_no；</li><li>选取每个员工当前的工资水平，用d.to_date = ‘9999-01-01’ AND s.to_date = ‘9999-01-01’作条件限制，因为此表中每条最新记录的 to_date 都用 9999-01-01 表示；</li><li>用GROUP BY d.dept_no将每个部门分为一组，用MAX()函数选取每组中工资最高者；</li></ul><hr><ol start="3"><li>从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &quot;titles&quot; (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `title` varchar(50) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date DEFAULT NULL);</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select title, count(emp_no) t from titles </span><br><span class="line">group by title having t&gt;=2</span><br></pre></td></tr></table></figure><ul><li>用COUNT()函数和GROUP BY语句可以统计同一title值的记录条数</li><li>由于WHERE后不可跟COUNT()函数，故用<strong>HAVING</strong>语句来限定t&gt;=2的条件</li><li><strong>where</strong>和<strong>having</strong>的不同之处在于，where是查找之前的限定，而having是查找之后。</li></ul><hr><ol start="4"><li>从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。注意对于重复的emp_no进行忽略。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select title, count(distinct emp_no) t from titles </span><br><span class="line">group by title having t&gt;=2</span><br></pre></td></tr></table></figure></li></ol><ul><li>和上一题类似，注意使用<strong>distinct</strong> 对重复的emp_no进行忽略</li></ul><hr><ol start="5"><li>查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `employees` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `birth_date` date NOT NULL,</span><br><span class="line">    `first_name` varchar(14) NOT NULL,</span><br><span class="line">    `last_name` varchar(16) NOT NULL,</span><br><span class="line">    `gender` char(1) NOT NULL,</span><br><span class="line">    `hire_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`));</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from employees </span><br><span class="line"><span class="built_in">where</span> (emp_no%2)=1 and last_name != <span class="string">'Mary'</span> </span><br><span class="line">order by hire_date desc</span><br></pre></td></tr></table></figure><ul><li>员工号为奇数，则emp_no取余应为1</li><li>last_name不为Mary，用‘！=’ 或 ‘&lt;&gt;’表示</li><li>根据hire_date逆序排列，用desc</li></ul><hr><ol start="6"><li>统计出当前各个title类型对应的员工当前薪水对应的平均工资。结果给出title以及平均工资avg。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `salaries` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `salary` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">CREATE TABLE IF NOT EXISTS &quot;titles&quot; (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `title` varchar(50) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date DEFAULT NULL);</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select title,avg(salary) as avg from salaries,titles </span><br><span class="line"><span class="built_in">where</span> salaries.emp_no = titles.emp_no and salaries.to_date=<span class="string">'9999-01-01'</span> and titles.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line">group by title</span><br></pre></td></tr></table></figure><ul><li>多表查询，连接查询是一种特殊的多表查询</li></ul><hr><ol start="7"><li>获取当前（to_date=’9999-01-01’）薪水第二多的员工的emp_no以及其对应的薪水salary<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `salaries` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `salary` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, salary from salaries </span><br><span class="line"><span class="built_in">where</span> to_date=<span class="string">'9999-01-01'</span> </span><br><span class="line">and salary = (select distinct salary from salaries order by salary desc <span class="built_in">limit</span> 1,1)</span><br><span class="line">或</span><br><span class="line">select emp_no,salary from salaries</span><br><span class="line"><span class="built_in">where</span> to_date = <span class="string">'9999-01-01'</span></span><br><span class="line">order by salary desc <span class="built_in">limit</span> 1,1</span><br></pre></td></tr></table></figure><ul><li>注意多个人工资相同的情况</li></ul><hr><ol start="8"><li>查找当前薪水(to_date=’9999-01-01’)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, max(s.salary), e.last_name, e.first_name from employees e inner join salaries s </span><br><span class="line">on e.emp_no=s.emp_no </span><br><span class="line"><span class="built_in">where</span> s.to_date=<span class="string">'9999-01-01'</span> and s.salary != (select max(salary) from salaries <span class="built_in">where</span> to_date=<span class="string">'9999-01-01'</span>)</span><br></pre></td></tr></table></figure></li></ol><p>本题做法很多，主要思想为多层SELECT嵌套与MAX()函数结合</p><ul><li>先利用MAX()函数找出salaries中当前薪水最高者，即SELECT MAX(salary) FROM salaries WHERE to_date = ‘9999-01-01’</li><li>再利用INNER JOIN连接employees与salaries表，限定条件为【同一员工】e.emp_no = s.emp_no、【当前】s.to_date = ‘9999-01-01’与【非薪水最高】s.salary NOT IN (SELECT MAX(salary) FROM salaries WHERE to_date = ‘9999-01-01’)</li><li>在以上限制条件下找薪水最高者，即为所有员工薪水的次高者</li></ul><hr><ol start="9"><li>查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `departments` (</span><br><span class="line">    `dept_no` char(4) NOT NULL,</span><br><span class="line">    `dept_name` varchar(40) NOT NULL,</span><br><span class="line">    PRIMARY KEY (`dept_no`));</span><br><span class="line">CREATE TABLE `dept_emp` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `dept_no` char(4) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">CREATE TABLE `employees` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `birth_date` date NOT NULL,</span><br><span class="line">    `first_name` varchar(14) NOT NULL,</span><br><span class="line">    `last_name` varchar(16) NOT NULL,</span><br><span class="line">    `gender` char(1) NOT NULL,</span><br><span class="line">    `hire_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`));</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.last_name, e.first_name, dp.dept_name from employees e </span><br><span class="line">left outer join dept_emp de on e.emp_no = de.emp_no </span><br><span class="line">left outer join departments dp on de.dept_no=dp.dept_no</span><br></pre></td></tr></table></figure><p>本题思路为运用两次LEFT JOIN连接嵌套</p><ul><li>第一次LEFT JOIN连接employees表与dept_emp表，得到所有员工的last_name和first_name以及对应的dept_no，也包括暂时没有分配部门的员工</li><li>第二次LEFT JOIN连接上表与departments表，即连接dept_no与dept_name，得到所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工</li><li><strong>注意：</strong> 第一次 left join 是把未分配部门的员工算进去了，但是只得到了部门号，没有部门名，所以第二次也要 left join 把含有部门名 departments 连接起来，否则在第二次连接时就选不上未分配部门的员工了。</li></ul><hr><ol start="10"><li>查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `salaries` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `salary` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT ( </span><br><span class="line">(SELECT salary FROM salaries WHERE emp_no = 10001 ORDER BY to_date DESC LIMIT 1) -</span><br><span class="line">(SELECT salary FROM salaries WHERE emp_no = 10001 ORDER BY to_date ASC LIMIT 1)</span><br><span class="line">) AS growth</span><br></pre></td></tr></table></figure><ul><li>先分别找到emp_no=10001的员工的第一次工资记录与最后一次工资记录</li><li>再将最后一次工资记录减去第一次工资记录得到入职以来salary的涨幅，最后用别名growth代替</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL查询语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库sql实战(1)</title>
      <link href="/2019/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93sql%E5%AE%9E%E6%88%98-1/"/>
      <url>/2019/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93sql%E5%AE%9E%E6%88%98-1/</url>
      
        <content type="html"><![CDATA[<ol><li>查找最晚入职的员工的所有信息<br>数据表定义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `employees` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `birth_date` date NOT NULL,</span><br><span class="line">    `first_name` varchar(14) NOT NULL,</span><br><span class="line">    `last_name` varchar(16) NOT NULL,</span><br><span class="line">    `gender` char(1) NOT NULL,</span><br><span class="line">    `hire_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`));</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees <span class="built_in">where</span> hire_date = (select max(hire_date) from employees)</span><br></pre></td></tr></table></figure><p>最晚入职的当天未必就一个人，也许有多人，使用排序并限制得只能取得指定数量的结果。因此不使用limit和top，而是使用聚合查询的max函数求出最晚的入职时间，按最晚入职时间进行查询。</p><hr><ol start="2"><li>查找入职员工时间排名倒数第三的员工所有信息 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees <span class="built_in">where</span> hire_date = (select distinct hire_date from employees order by hire_date desc <span class="built_in">limit</span> 2,1)</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>distinct：</strong> 在使用MySQL时，有时需要查询出某个字段不重复的记录，这时可以使用mysql提供的distinct这个关键字来过滤重复的记录。</li><li><strong>limit字句：</strong> Limit子句可以被用于强制 SELECT 语句返回指定的记录数。Limit接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//初始记录行的偏移量是 0(而不是 1)：</span><br><span class="line">mysql&gt; SELECT * FROM table LIMIT 5,10; //检索记录行6-15</span><br><span class="line"></span><br><span class="line">//为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</span><br><span class="line">mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last</span><br><span class="line"></span><br><span class="line">//如果只给定一个参数，它表示返回最大的记录行数目。换句话说，LIMIT n 等价于 LIMIT 0,n：</span><br><span class="line">mysql&gt; SELECT * FROM table LIMIT 5;     //检索前 5 个记录行</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="3"><li>查找各个部门当前(to_date=’9999-01-01’)领导当前薪水详情以及其对应部门编号dept_no<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `dept_manager` (</span><br><span class="line">    `dept_no` char(4) NOT NULL,</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">    CREATE TABLE `salaries` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `salary` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select salaries.*, dept_manager.dept_no from salaries inner join dept_manager </span><br><span class="line">on salaries.emp_no=dept_manager.emp_no </span><br><span class="line">and salaries.to_date=<span class="string">'9999-01-01'</span> and dept_manager.to_date=<span class="string">'9999-01-01'</span>;</span><br></pre></td></tr></table></figure><p>使用多表查询或连接查询，根据要求，确定salaries表为主表，使用inner join进行连接，连接条件为emp_no字段相同，在加入where字句筛选to_date=’9999-01-01’。</p><hr><ol start="4"><li>查找所有已经分配部门的员工的last_name和first_name<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `dept_emp` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `dept_no` char(4) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">CREATE TABLE `employees` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `birth_date` date NOT NULL,</span><br><span class="line">    `first_name` varchar(14) NOT NULL,</span><br><span class="line">    `last_name` varchar(16) NOT NULL,</span><br><span class="line">    `gender` char(1) NOT NULL,</span><br><span class="line">    `hire_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`));</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.last_name, e.first_name, d.dept_no from employees e inner join dept_emp d on e.emp_no = d.emp_no</span><br></pre></td></tr></table></figure><p>因为要查找所有已分配部门的员工信息，所以两表中都存在的emp_no才是所要查询的目标，因此使用inner join。</p><hr><ol start="5"><li>查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.last_name, e.first_name, d.dept_no from employees e left outer join dept_emp d on e.emp_no = d.emp_no</span><br></pre></td></tr></table></figure></li></ol><p>因为要查找所有员工信息，所以左表中所有的emp_no都要包含，因此使用left outer join。</p><hr><ol start="6"><li><p>查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `employees` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `birth_date` date NOT NULL,</span><br><span class="line">    `first_name` varchar(14) NOT NULL,</span><br><span class="line">    `last_name` varchar(16) NOT NULL,</span><br><span class="line">    `gender` char(1) NOT NULL,</span><br><span class="line">    `hire_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`));</span><br><span class="line">CREATE TABLE `salaries` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `salary` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, s.salary from employees e inner join salaries s</span><br><span class="line">on s.emp_no = e.emp_no and s.from_date = e.hire_date</span><br><span class="line">order by e.emp_no desc</span><br></pre></td></tr></table></figure></li></ol><ul><li>由于测试数据中，salaries.emp_no 不唯一（因为号码为 emp_no 的员工会有多次涨薪的可能，所以在 salaries 中对应的记录不止一条），而employees.emp_no 唯一，即 salaries 的数据会多于 employees，因此需先找到 employees.emp_no 在 salaries 表中对应的记录salaries.emp_no，则有限制条件 e.emp_no = s.emp_no</li><li>根据题意注意到 salaries.from_date 和 employees.hire_date 的值应该要相等，因此有限制条件 e.hire_date = s.from_date</li><li>根据题意要按照 emp_no 值逆序排列，因此最后要加上 ORDER BY e.emp_no DESC</li></ul><hr><ol start="7"><li><p>查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `salaries` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `salary` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, count(emp_no) t from salaries group by emp_no having t&gt;15</span><br></pre></td></tr></table></figure></li></ol><ul><li>用COUNT()函数和GROUP BY语句可以统计同一emp_no值的记录条数</li><li>根据题意，输出的涨幅次数为t，故用AS语句将COUNT(emp_no)的值转换为t (AS可省略)</li><li>由于COUNT()函数不可用于WHERE语句中，故使用HAVING语句来限定t&gt;15的条件</li><li><strong>having子句：</strong> having字句可以让我们筛选<strong>成组后</strong>的各种数据，<strong>where字句在聚合前</strong>先筛选记录，也就是说作用在group by和having字句前。而 having子句在聚合后对组记录进行筛选。我的理解就是真实表中没有此数据，这些数据是通过一些函数生存。</li></ul><hr><ol start="8"><li>找出所有员工当前(to_date=’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select distinct salary from salaries <span class="built_in">where</span> to_date=<span class="string">'9999-01-01'</span> order by salary desc</span><br><span class="line">或</span><br><span class="line">select salary from salaries <span class="built_in">where</span> to_date=<span class="string">'9999-01-01'</span> group by salary order by salary desc</span><br></pre></td></tr></table></figure></li></ol><p>相同薪水显示一次，使用SELECT DISTINCT可去除重复值，但是大表一般用distinct效率不高，大数据量的时候都禁止用distinct，可以用group by解决重复问题。</p><hr><ol start="9"><li><p>获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `dept_manager` (</span><br><span class="line">    `dept_no` char(4) NOT NULL,</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">CREATE TABLE `salaries` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `salary` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT d.dept_no, d.emp_no, s.salary </span><br><span class="line">FROM salaries AS s INNER JOIN dept_manager AS d </span><br><span class="line">ON d.emp_no = s.emp_no</span><br><span class="line">AND d.to_date = <span class="string">'9999-01-01'</span></span><br><span class="line">AND s.to_date = <span class="string">'9999-01-01'</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>先用INNER JOIN连接两张表，限制条件是两张表的emp_no相同，即d.emp_no = s.emp_no，并且将salaries用别名s代替，dept_manager用别名d代替</li><li>根据题意，要获取当前manager的当前salary情况，再加上限制条件d.to_date = ‘9999-01-01’ AND s.to_date = ‘9999-01-01’即可（因为同一emp_no在salaries表中对应多条涨薪记录，而当s.to_date = ‘9999-01-01’时是该员工当前的薪水记录）</li></ul><ol start="10"><li>获取所有非manager的员工emp_no<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `dept_manager` (</span><br><span class="line">    `dept_no` char(4) NOT NULL,</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `from_date` date NOT NULL,</span><br><span class="line">    `to_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">CREATE TABLE `employees` (</span><br><span class="line">    `emp_no` int(11) NOT NULL,</span><br><span class="line">    `birth_date` date NOT NULL,</span><br><span class="line">    `first_name` varchar(14) NOT NULL,</span><br><span class="line">    `last_name` varchar(16) NOT NULL,</span><br><span class="line">    `gender` char(1) NOT NULL,</span><br><span class="line">    `hire_date` date NOT NULL,</span><br><span class="line">    PRIMARY KEY (`emp_no`));</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>方法1：SQL支持集合运算</p><p>  – EXPECT  集合差运算</p><p>  – UNION  集合并运算</p><p>  – INTERSECT 集合交运算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no from employees e </span><br><span class="line">EXCEPT</span><br><span class="line">select d.emp_no from dept_manager d</span><br></pre></td></tr></table></figure></li><li><p>方法2：使用NOT IN选出在employees但不在dept_manager中的emp_no记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT emp_no FROM employees</span><br><span class="line">WHERE emp_no NOT IN (SELECT emp_no FROM dept_manager)</span><br></pre></td></tr></table></figure></li><li><p>方法3：先使用LEFT JOIN连接两张表，再从此表中选出dept_no值为NULL对应的emp_no记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT employees.emp_no FROM employees LEFT JOIN dept_manager</span><br><span class="line">ON employees.emp_no = dept_manager.emp_no</span><br><span class="line">WHERE dept_no IS NULL</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL查询语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8的集合4：LinkedHashMap的实现原理</title>
      <link href="/2019/05/06/Java8%E7%9A%84%E9%9B%86%E5%90%884%EF%BC%9ALinkedHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2019/05/06/Java8%E7%9A%84%E9%9B%86%E5%90%884%EF%BC%9ALinkedHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>按照惯例，先看一下源码里的第一段注释：</p><p>Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)</p><p>从注释中，我们可以先了解到LinkedHashMap是通过<strong>哈希表</strong>和<strong>链表</strong>实现的，它通过维护一个链表来保证对哈希表迭代时的<strong>有序性</strong>，而这个有序是指<strong>键值对插入的顺序</strong>。另外，当向哈希表中重复插入某个键的时候，不会影响到原来的有序性。也就是说，假设你插入的键的顺序为1、2、3、4，后来再次插入2，迭代时的顺序还是1、2、3、4，而不会因为后来插入的2变成1、3、4、2。（但其实我们可以改变它的规则，使它变成1、3、4、2）</p><p>LinkedHashMap的实现主要分两部分，一部分是哈希表，另外一部分是链表。哈希表部分继承了HashMap，拥有了HashMap那一套高效的操作，LinkedHashMap中链表的部分，通过一个双向链表，按序存储HashMap的每个键值对，借此来维护有序性。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>LinkedHashMap 是继承自 HashMap 的，所以它已经从 HashMap 那里继承了与哈希表相关的操作了，那么在 LinkedHashMap 中，它可以专注于链表实现的那部分，所以与链表实现相关的属性如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//LinkedHashMap的链表节点继承了HashMap的节点，而且每个节点都包含了前指针和后指针，所以这里可以看出它是一个双向链表</span><br><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//头指针</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">//尾指针</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">//默认为false。当为true时，表示链表中键值对的顺序与每个键的插入顺序一致，也就是说重复插入键，也会更新顺序</span><br><span class="line">//简单来说，为false时，就是上面所指的1、2、3、4的情况；为true时，就是1、3、4、2的情况</span><br><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>在HashMap的源码中，我们可以发现，HashMap中有如下三个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Callbacks to allow LinkedHashMap post-actions</span><br><span class="line"></span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>这三个方法表示的是在访问、插入、删除某个节点之后，进行一些处理，它们在LinkedHashMap都有各自的实现。LinkedHashMap正是通过重写这三个方法来保证<strong>链表</strong>的插入、删除的有序性。</p><h2 id="afterNodeAccess方法"><a href="#afterNodeAccess方法" class="headerlink" title="afterNodeAccess方法"></a>afterNodeAccess方法</h2><p>改方法就是把当前节点e移至链表的尾部。因为使用的是双向链表，所以在尾部插入可以以O（1）的时间复杂度来完成。并且只有当accessOrder设置为true时，才会执行这个操作。在HashMap的putVal方法中，就调用了这个方法。</p><h2 id="afterNodeInsertion方法"><a href="#afterNodeInsertion方法" class="headerlink" title="afterNodeInsertion方法"></a>afterNodeInsertion方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>afterNodeInsertion方法是在哈希表中插入了一个新节点时调用的，它会把链表的头节点删除掉，删除的方式是通过调用HashMap的removeNode方法。通过afterNodeInsertion方法和afterNodeAccess方法，就可以简单的实现一个基于最近最少使用（LRU）的淘汰策略。当然，我们还要重写removeEldestEntry方法，因为它默认返回的是false。</p><h2 id="afterNodeRemoval方法"><a href="#afterNodeRemoval方法" class="headerlink" title="afterNodeRemoval方法"></a>afterNodeRemoval方法</h2><p>这个方法是当HashMap删除一个键值对时调用的，它会把在HashMap中删除的那个键值对一并从链表中删除，保证了哈希表和链表的一致性。</p><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>LinkedHashMap的get方法调用的是HashMap的getNode方法来获取结果的。并且，如果你把accessOrder设置为true，那么在获取到值之后，还会调用afterNodeAccess方法。这样就能保证一个<strong>LRU</strong>的算法。</p><h2 id="put和remove方法"><a href="#put和remove方法" class="headerlink" title="put和remove方法"></a>put和remove方法</h2><p>LinkedHashMap的源码中没有找到put方法，这就说明了它并没有重写put方法，所以我们调用的put方法其实是HashMap的put方法。因为HashMap的put方法中调用了afterNodeAccess方法和afterNodeInsertion方法，已经足够保证链表的有序性了，所以它也就没有重写put方法了。remove方法也是如此。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>LinkedHashMap是继承于HashMap，是基于HashMap和双向链表来实现的。</li><li>HashMap无序；LinkedHashMap有序，可分为插入顺序和访问顺序两种。如果是访问顺序（accessOrder=true），那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。</li><li>LinkedHashMap存取数据，还是跟HashMap一样使用的Entry[]的方式，双向链表只是为了保证顺序。</li><li>LinkedHashMap是线程不安全的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8的集合3：HashMap的实现原理</title>
      <link href="/2019/05/05/Java8%E7%9A%84%E9%9B%86%E5%90%883%EF%BC%9AHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2019/05/05/Java8%E7%9A%84%E9%9B%86%E5%90%883%EF%BC%9AHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一上来，先来看看源码中的这一段注释，我们可以从中提取到一些关键信息：<br>Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.<br>翻译一下大概就是在说，这个哈希表是基于Map接口的实现的，它允许null值和null键，它不是线程同步的，同时也不保证有序。<br>This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the “capacity” of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it’s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.<br>再来看看这一段，讲的是Map的这种实现方式为get（取）和put（存）带来了比较好的性能。但是如果涉及到大量的<strong>遍历操作</strong>的话，就尽量不要把capacity设置得太高（或load factor设置得太低），否则会严重降低遍历的效率。<br>影响HashMap性能的两个重要参数：“<strong>initial capacity</strong>”（初始化容量）和”<strong>load factor</strong>“（负载因子）。简单来说，容量就是哈希表桶的个数，负载因子就是键值对个数与哈希表长度的一个比值，当比值超过负载因子之后，HashMap就会进行rehash操作来进行扩容。<br>HashMap 的大致结构如下，其中哈希表是一个<strong>数组</strong>，我们经常把数组中的每一个节点称为一个桶，哈希表中的每个节点都用来存储一个键值对。在插入元素时，如果发生冲突（即多个键值对映射到同一个桶上）的话，就会通过<strong>链表</strong>的形式来解决冲突。因为一个桶上可能存在多个键值对，所以在查找的时候，会先通过key的哈希值先定位到桶，再遍历桶上的所有键值对，找出key相等的键值对，从而来获取value。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//默认的初始容量为16</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</span><br><span class="line">//最大的容量上限为2^30</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">//默认的负载因子为0.75</span><br><span class="line">static final <span class="built_in">float</span> DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">//变成树型结构的临界值为8</span><br><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">//恢复链式结构的临界值为6</span><br><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">//哈希表</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line">//哈希表中键值对的个数</span><br><span class="line">transient int size;</span><br><span class="line">//哈希表被修改的次数</span><br><span class="line">transient int modCount;</span><br><span class="line">//它是通过capacity*load factor计算出来的，当size到达这个值时，就会进行扩容操作</span><br><span class="line">int threshold;</span><br><span class="line">//负载因子</span><br><span class="line">final <span class="built_in">float</span> loadFactor;</span><br><span class="line">//当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采取扩容来尝试减少冲突</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure><p>下面是 Node 类的定义，它是 HashMap 中的一个静态内部类，哈希表中的每一个节点都是 Node 类型。我们可以看到，Node 类中有 4 个属性，其中除了 key 和 value 之外，还有 hash 和 next 两个属性。hash 是用来存储 key 的哈希值的，next 是在构建链表时用来指向后继节点的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int <span class="built_in">hash</span>;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>实现步骤大致如下： </p><ol><li>通过hash值获取该key映射到的桶。</li><li>桶上的key就是要查找的key，则直接命中。 </li><li>桶上的key不是要查找的key，则查看后续节点：<br> （1）如果后续节点是树节点，通过调用树的方法查找该key。<br> （2）如果后续节点是链式节点，则通过循环遍历链查找该key。<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2>put方法比较复杂，实现步骤大致如下： </li><li>先通过hash值计算出key映射到哪个桶。</li><li>如果桶上没有碰撞冲突，则直接插入。 </li><li>如果出现碰撞冲突了，则需要处理冲突：<br> （1）如果该桶使用红黑树处理冲突，则调用红黑树的方法插入。<br> （2）否则采用传统的链式方法插入。如果链的长度到达临界值，则把链转变为红黑树。. .</li><li>如果桶中存在重复的键，则为该键替换新值。 </li><li>如果size大于阈值，则进行扩容。<h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2>理解了put方法之后，remove已经没什么难度了，所以重复的内容就不再做详细介绍了。<h2 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h2>在get方法和put方法中都需要先计算key映射到哪个桶上，然后才进行之后的操作，计算的主要代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - 1) &amp; hash</span><br></pre></td></tr></table></figure></li></ol><p>上面代码中的n指的是哈希表的大小，hash指的是key的哈希值，hash是通过下面这个方法计算出来的，采用了二次哈希的方式，其中key的hashCode方法是一个native方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int <span class="built_in">hash</span>(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    <span class="built_in">return</span> (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个hash方法先通过key的hashCode方法获取一个哈希值，再拿这个哈希值与它的<strong>高16位</strong>的哈希值做一个异或操作来得到最后的哈希值。</p><p>为啥要这样做呢？注释中是这样解释的：如果当n很小，假设为64的话，那么n-1即为63（0x111111），这样的值跟hashCode()直接做与操作，实际上只使用了哈希值的后6位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p><p>正是因为与的这个操作，决定了HashMap的大小只能是2的幂次方，想一想，如果不是2的幂次方，会发生什么事情？即使你在创建HashMap的时候指定了初始大小，HashMap在构建的时候也会调用下面这个方法来调整大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的作用看起来可能不是很直观，它的实际作用就是把cap变成第一个大于等于2的幂次方的数。例如，16还是16，13就会调整为16，17就会调整为32。</p><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算（n-1）&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。</p><p>例如，原来的容量为32，那么应该拿hash跟31（0x11111）做与操作；在扩容扩到了64的容量之后，应该拿hash跟63（0x111111）做与操作。新容量跟原来相比只是多了一个bit位，假设原来的位置在23，那么当新增的那个bit位的计算结果为0时，那么该节点还是在23；相反，计算结果为1时，则该节点会被分配到23+31的桶上。</p><p>正是因为这样巧妙的rehash方式，保证了rehash之后每个桶上的节点数必定小于等于原来桶上的节点数，即保证了rehash之后不会出现更严重的冲突。</p><p>在这里有一个需要注意的地方，有些文章指出当哈希表的<strong>桶占用</strong>超过阈值时就进行扩容，这是不对的；实际上是当哈希表中的<strong>键值对个数</strong>超过阈值时，才进行扩容的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>通过红黑树的方式来处理哈希冲突是我第一次看见！学过哈希，学过红黑树，就是从来没想到两个可以结合到一起这么用！</p></li><li><p>按照原来的拉链法来解决冲突，如果一个桶上的冲突很严重的话，是会导致哈希表的效率降低至O（n），而通过红黑树的方式，可以把效率改进至O（logn）。相比链式结构的节点，树型结构的节点会占用比较多的空间，所以这是一种以空间换时间的改进方式。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8的集合2：HashSet的实现原理</title>
      <link href="/2019/05/05/Java8%E7%9A%84%E9%9B%86%E5%90%882%EF%BC%9AHashSet%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2019/05/05/Java8%E7%9A%84%E9%9B%86%E5%90%882%EF%BC%9AHashSet%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HashSet是Set接口的典型实现，HashSet按照Hash算法来存储集合中的元素。存在以下特点：</p><ul><li>不能保证元素的顺序，元素是无序的</li><li>HashSet不是同步的，需要外部保持线程之间的同步问题</li><li>集合元素值允许为null<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">    java.util.AbstractCollection&lt;E&gt; </span><br><span class="line">        java.util.AbstractSet&lt;E&gt; </span><br><span class="line">            java.util.HashSet&lt;E&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="继承关系，实现接口"><a href="#继承关系，实现接口" class="headerlink" title="继承关系，实现接口"></a>继承关系，实现接口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serializable, Cloneable, Iterable&lt;E&gt;, Collection&lt;E&gt;, Set&lt;E&gt;</span><br></pre></td></tr></table></figure><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private transient HashMap&lt;E,Object&gt; map;  //map集合，HashSet存放元素的容器</span><br><span class="line">private static final Object PRESENT = new Object(); //map，中键对应的value值</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//无参构造方法，完成map的创建</span><br><span class="line">public <span class="function"><span class="title">HashSet</span></span>() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">//指定集合转化为HashSet, 完成map的创建</span><br><span class="line">public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">   map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line">//指定初始化大小，和负载因子</span><br><span class="line">public HashSet(int initialCapacity, <span class="built_in">float</span> loadFactor) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line">//指定初始化大小</span><br><span class="line">public HashSet(int initialCapacity) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">//指定初始化大小和负载因子，dummy 无实际意义</span><br><span class="line">HashSet(int initialCapacity, <span class="built_in">float</span> loadFactor, boolean dummy) &#123;</span><br><span class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造函数，不难发现，<strong>HashSet的底层是采用HashMap实现的。</strong></p><h2 id="add-方法"><a href="#add-方法" class="headerlink" title="add()方法"></a>add()方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    <span class="built_in">return</span> map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PRESENT为HashSet类中定义的一个常量，并无实际的意义，HashSet的add()方法调用HashMap的put()方法实现，如果键已经存在，HashMap.put()放回的是旧值，添加失败；如果添加成功，map.put()方法返回的值为null ，HashSet.add()方法返回true。</li><li><p>要添加的元素为map中的key 。</p><h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    <span class="built_in">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除方法，调用map.remove()方法实现，若map.remove()能找到指定的key,则返回key对应的value。</p></li><li>对于Hashset而言，它所有的key对应的值都是PRESENT。<h1 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">    extends AbstractSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    static final long serialVersionUID = -5024744406713321676L; //序列化版本号</span><br><span class="line"></span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;  //HashMap变量，用于存放HashSet的值</span><br><span class="line"></span><br><span class="line">    private static final Object PRESENT = new Object(); //map中的值</span><br><span class="line"></span><br><span class="line">    //构造方法</span><br><span class="line">    public <span class="function"><span class="title">HashSet</span></span>() &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造方法，将指定的集合转化为HashSet</span><br><span class="line">    public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造方法，指定初始化的大小和负载因子</span><br><span class="line">    public HashSet(int initialCapacity, <span class="built_in">float</span> loadFactor) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    //指定初始化大小</span><br><span class="line">    public HashSet(int initialCapacity) &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造方法，采用default修饰，只能是同一个包下的成员访问。包不相同无法访问</span><br><span class="line">    HashSet(int initialCapacity, <span class="built_in">float</span> loadFactor, boolean dummy) &#123;</span><br><span class="line">        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //HashSet的遍历操作</span><br><span class="line">    //通过这个方法可以发现，HashSet调用了HashMap存放，因为HashSet并不是键值对存储，所以它只是把它的值做了Map中的键，在遍历HashSet的集合元素时，实际上是遍历的Map中Key的集合。</span><br><span class="line">    public Iterator&lt;E&gt; <span class="function"><span class="title">iterator</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回集合中元素的容量</span><br><span class="line">    public int <span class="function"><span class="title">size</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是否为空</span><br><span class="line">    public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否包含指定的元素</span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        <span class="built_in">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加元素，添加的元素作为了Map中的key,value使用了一个常量表示</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        <span class="built_in">return</span> map.put(e, PRESENT)==null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除元素</span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        <span class="built_in">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清空集合</span><br><span class="line">    public void <span class="function"><span class="title">clear</span></span>() &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //克隆方法</span><br><span class="line">    public Object <span class="function"><span class="title">clone</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();</span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">            <span class="built_in">return</span> newSet;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //写入输出流操作。</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws java.io.IOException &#123;</span><br><span class="line">        // Write out any hidden serialization magic</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        // Write out HashMap capacity and load factor</span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        // Write out size</span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        // Write out all elements <span class="keyword">in</span> the proper order.</span><br><span class="line">        <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //从输入流中读取对象</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        // Read <span class="keyword">in</span> any hidden serialization magic</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        // Read <span class="keyword">in</span> HashMap capacity and load factor and create backing HashMap</span><br><span class="line">        int capacity = s.readInt();</span><br><span class="line">        <span class="built_in">float</span> loadFactor = s.readFloat();</span><br><span class="line">        map = (((HashSet)this) instanceof LinkedHashSet ?</span><br><span class="line">               new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               new HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">        // Read <span class="keyword">in</span> size</span><br><span class="line">        int size = s.readInt();</span><br><span class="line"></span><br><span class="line">        // Read <span class="keyword">in</span> all elements <span class="keyword">in</span> the proper order.</span><br><span class="line">        <span class="keyword">for</span> (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            E e = (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>静下心来仔细研究了一下，发现hashset是通过将相应的内容存储在了一个hashmap里的key中，然后再去读取的。<br>为了保证hashset里面的数据唯一性，这里将hashset存放的元素作为了hashmap里面唯一的key变量，value部分用一个PRESENT对象来存储，也就是源码里面的这一句内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Object PRESENT = new Object();</span><br></pre></td></tr></table></figure></li><li><p>HashSet的底层通过HashMap实现的，而HashMap在1.7之前使用的是数组+链表实现，在1.8+使用的数组+链表+红黑树实现。其实也可以这样理解，HashSet的底层实现和HashMap使用的是相同的方式，因为Map是无序的，因此HashSet也无法保证顺序。HashSet的方法也是借助HashMap的方法来实现的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashSet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8的集合1：ArrayList的实现原理</title>
      <link href="/2019/04/28/Java8%E7%9A%84%E9%9B%86%E5%90%881%EF%BC%9AArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2019/04/28/Java8%E7%9A%84%E9%9B%86%E5%90%881%EF%BC%9AArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p>一上来，先来看看源码中的这一段注释，我们可以从中提取到一些关键信息：<br>Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)<br>从这段注释中，我们可以得知ArrayList是一个动态数组，实现了List接口以及list相关的所有方法，它允许所有元素的插入，包括null。另外，ArrayList和Vector除了线程不同步之外，大致相等。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//默认容量的大小</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">//空数组常量</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//默认的空数组常量</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//存放元素的数组，从这可以发现ArrayList的底层实现就是一个Object数组</span><br><span class="line">transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">//数组中包含的元素个数</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">//数组的最大上限</span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br></pre></td></tr></table></figure><p>ArrayList的属性非常少，就只有这些。其中最重要的莫过于<strong>elementData</strong>了，ArrayList所有的方法都是建立在elementData之上。接下来，我们就来看一下一些主要的方法。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        throw new IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="function"><span class="title">ArrayList</span></span>() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中我们可以看见，<strong>默认情况下，elementData是一个大小为0的空数组</strong>，当我们指定了初始大小的时候，elementData的初始大小就变成了我们所指定的初始大小了。</p><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="built_in">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line">private void rangeCheck(int index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    <span class="built_in">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为ArrayList是采用<strong>数组结构</strong>来存储的，所以它的get方法非常简单，先是<strong>判断一下有没有越界</strong>，之后就可以直接通过数组下标来获取元素了，所以get的时间复杂度是<strong>O(1)</strong></p><h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1); // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + 1); // Increments modCount!!</span><br><span class="line">    //调用一个native的复制方法，把index位置开始的元素都往后挪一位</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; 0)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList的add方法也很好理解，在插入元素之前，它会先检查是否需要扩容，然后再把元素添加到数组中最后一个元素的后面。在ensureCapacityInternal方法中，我们可以看见，如果当elementData为空数组时，它会使用默认的大小去扩容。所以说，通过无参构造方法来创建ArrayList时，它的大小其实是为0的，只有在使用到的时候，才会通过<strong>grow方法去创建一个大小为10的数组</strong>。</p><p><strong>第一个add方法的复杂度为O(1)</strong>，虽然有时候会涉及到扩容的操作，但是扩容的次数是非常少的，所以这一部分的时间可以忽略不计。如果<strong>使用的是带指定下标的add方法，则复杂度为O(n)</strong>，因为涉及到对数组中元素的移动，这一操作是非常耗时的。</p><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E <span class="built_in">set</span>(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="built_in">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set方法的作用是把下标为index的元素替换成element，跟get非常类似，所以就不在赘述了，时间复杂度度为O(1)。</p><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; 0)</span><br><span class="line">    System.arraycopy(elementData, index+1, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to <span class="built_in">let</span> GC <span class="keyword">do</span> its work</span><br><span class="line">    <span class="built_in">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove方法与add带指定下标的方法非常类似，也是调用系统的arraycopy方法来移动元素，时间复杂度为O(n)。</p><h2 id="grow方法"><a href="#grow方法" class="headerlink" title="grow方法"></a>grow方法</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; 0)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grow方法是在数组进行扩容的时候用到的，从中我们可以看见，<strong>ArrayList每次扩容都是扩1.5倍</strong>，然后<strong>调用Arrays类的copyOf方法，把元素重新拷贝到一个新的数组中去</strong>。</p><h2 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int <span class="function"><span class="title">size</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size方法非常简单，它是直接返回size的值，也就是返回数组中元素的个数，时间复杂度为O(1)。这里要注意一下，返回的并不是数组的实际大小。</p><h2 id="indexOf方法和lastIndexOf"><a href="#indexOf方法和lastIndexOf" class="headerlink" title="indexOf方法和lastIndexOf"></a>indexOf方法和lastIndexOf</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == null) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; size; i++)</span><br><span class="line">        <span class="keyword">if</span> (elementData[i]==null)</span><br><span class="line">        <span class="built_in">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="built_in">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == null) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==null)</span><br><span class="line">                <span class="built_in">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                        <span class="built_in">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">return</span> -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexOf方法的作用是返回第一个等于给定元素的值的下标。它是通过遍历比较数组中每个元素的值来查找的，所以它的时间复杂度是O(n)。 lastIndexOf的原理跟indexOf一样，而它仅仅是从后往前找起罢了。</p><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>Vector的很多方法都跟ArrayList一样，只是多加了个synchronized来保证线程安全。所以只把Vector与ArrayList的不同点提一下就可以了。</p><ol><li>Vector比ArrayList多了一个属性：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected int capacityIncrement;</span><br></pre></td></tr></table></figure></li></ol><p>这个属性是在扩容的时候用到的，它表示每次扩容只扩capacityIncrement个空间就足够了。该属性可以通过构造方法给它赋值。先来看一下构造方法：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Vector(int initialCapacity, int capacityIncrement) &#123;</span><br><span class="line">    super();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+initialCapacity);</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">        this.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line">public Vector(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, 0);</span><br><span class="line">&#125;</span><br><span class="line">public <span class="function"><span class="title">Vector</span></span>() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从构造方法中，我们可以看出Vector的默认大小也是10，而且它在初始化的时候就已经创建了数组了，这点跟ArrayList不一样。</p><ol start="2"><li>再来看一下grow方法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从grow方法中我们可以发现，newCapacity默认情况下是两倍的oldCapacity，而当指定了capacityIncrement的值之后，newCapacity变成了oldCapacity+capacityIncrement。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>ArrayList创建时的大小为0；当加入第一个元素时，进行第一次扩容时，默认容量大小为10。</li><li><strong>ArrayList每次扩容都以当前数组大小的1.5倍去扩容。</strong></li><li>Vector创建时的默认大小为10。</li><li><strong>Vector每次扩容都以当前数组大小的2倍去扩容。当指定了capacityIncrement之后，每次扩容仅在原先基础上增加capacityIncrement个单位空间。</strong></li><li>ArrayList和Vector的add、get、size方法的复杂度都为O(1)，remove方法的复杂度为O(n)。</li><li><font color="#DC143C"><strong>ArrayList是非线程安全的，Vector是线程安全的。</strong></font> </li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
            <tag> Vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java：CAS</title>
      <link href="/2019/04/26/Java%EF%BC%9ACAS/"/>
      <url>/2019/04/26/Java%EF%BC%9ACAS/</url>
      
        <content type="html"><![CDATA[<h1 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h1><hr><p>什么是悲观锁、乐观锁？在java语言里，总有一些名词看语义跟本不明白是啥玩意儿，也就总有部分面试官拿着这样的词来忽悠面试者，以此来找优越感，其实理解清楚了，这些词也就唬不住人了。</p><ul><li>synchronized 是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。</li><li>CAS 操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</li><li>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1></li></ul><hr><ul><li>在进入正题之前，我们先理解下下面的代码:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static int count = 0;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       <span class="keyword">for</span> (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">           new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       Thread.sleep(10);</span><br><span class="line">                   &#125; catch (Exception e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">                   //每个线程让count自增100次</span><br><span class="line">                   <span class="keyword">for</span> (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                       count++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">       try&#123;</span><br><span class="line">           Thread.sleep(2000);</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>请问cout的输出值是否为200？答案是否定的，因为这个程序是线程不安全的，所以造成的结果count值可能小于200。</p><p>那么如何改造成线程安全的呢，其实我们可以使用上Synchronized同步锁,我们只需要在count++的位置添加同步锁，代码如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static int count = 0;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //每个线程让count自增100次</span><br><span class="line">                    <span class="keyword">for</span> (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                        synchronized (ThreadCas.class)&#123;</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>加了同步锁之后，count自增的操作变成了原子性操作，所以最终的输出一定是count=200，代码实现了线程安全。</p><p>但是Synchronized虽然确保了线程的安全，但是在性能上却不是最优的，Synchronized关键字会让没有得到锁资源的线程进入<font color="#DC143C">BLOCKED</font>状态，而后在争夺到锁资源后恢复为<font color="#DC143C">RUNNABLE</font>状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。</p><p>因此，在JAVA中改用原子类操作加以改进。所谓原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如AtomicBoolean，AtomicInteger，AtomicLong。它们分别用于Boolean，Integer，Long类型的原子性操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">        new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(10);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                //每个线程让count自增100次</span><br><span class="line">                <span class="keyword">for</span> (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                    count.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用AtomicInteger之后，最终的输出结果同样可以保证是200。并且在某些情况下，代码的性能会比Synchronized更好。而Atomic操作的底层实现正是利用的CAS机制。</p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><hr><ul><li>想要理解CAS，首先先要了解下JMM。</li><li>JMM：Java内存模型，是一种抽象的概念，可以理解为一组规范。</li><li>JMM的特性：可见性，原子性，有序性。</li><li>JMM关于同步的规定：</li></ul><ol><li>线程解锁前必须将共享变量的值刷新回主内存。</li><li>线程加锁前必须读主内存的最新值到自己的工作内存中。</li><li>加锁解锁是同一把锁。</li><li>线程间的通信（传值）必须通过主内存。</li></ol><h1 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h1><hr><ul><li>在计算机科学中，<strong>比较并交换</strong>（Conmpare And Swap）是用于实现多线程同步的<strong>原子指令</strong>。 它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果该值在同一时间被另一个线程更新，则写入将失败。 操作结果必须说明是否进行替换; 这可以通过一个简单的布尔响应（这个变体通常称为比较和设置），或通过返回从内存位置读取的值来完成（摘自维基本科）。</li><li>CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</li></ul><p>使用 compareAndSet方法将内存中的值<strong>5</strong>进行修改，第一次修改成功，内存中的值被改为<strong>2019</strong>，第二次进行比较时，由于内存中的值已经被修改，所以操作失败。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(5);</span><br><span class="line">        //main <span class="keyword">do</span> something</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(5,2019)+<span class="string">"\t current data: "</span>+atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(5,1024)+<span class="string">"\t current data: "</span>+atomicInteger.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h1><hr><ol><li>CPU开销较大：<br>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li><li>不能保证代码块的原子性<br>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。<ol start="3"><li>可能会出现ABA问题。</li></ol></li></ol><h1 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h1><hr><ul><li>什么是ABA问题？<br>简单来说一句话：狸猫换太子。<br>举个例子：如线程1从内存X中取出A，这时候另一个线程2也从内存X中取出A，并且线程2进行了一些操作将内存X中的值变成了B，然后线程2又将内存X中的数据变成A，这时候线程1进行CAS操作发现内存X中仍然是A，然后线程1操作成功。虽然线程1的CAS操作成功，但是整个过程就是有问题的。比如链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。</li><li>如何解决：<br>JAVA中提供了<strong>AtomicStampedReference</strong>来处理会发生ABA问题的场景，主要是在对象中额外再增加一个标记来标识对象是否有过变更（类似于GitHub的版本号）。</li></ul><p>测试代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static AtomicReference&lt;Integer&gt; atomicReference = new AtomicReference&lt;&gt;(100);</span><br><span class="line">static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(100,1);</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(<span class="string">"=============以下是ABA问题的产生============="</span>);</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        atomicReference.compareAndSet(100,101);</span><br><span class="line">        atomicReference.compareAndSet(101,100);</span><br><span class="line">    &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //暂停1S线程2，保证线程1完成ABA操作</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(100,2019)+<span class="string">"\t"</span>+atomicReference.get());</span><br><span class="line">    &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"=============以下是ABA问题的解决============="</span>);</span><br><span class="line"></span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        int stamp = atomicStampedReference.getStamp();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t第一次版本号： "</span>+stamp);</span><br><span class="line">        try &#123;</span><br><span class="line">            //暂停1S线程3</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicStampedReference.compareAndSet(100,101,</span><br><span class="line">                atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1));</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t第二次版本号： "</span>+atomicStampedReference.getStamp());</span><br><span class="line">        System.out.println(atomicStampedReference.compareAndSet(101,100,</span><br><span class="line">                atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1));</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t第三次版本号： "</span>+atomicStampedReference.getStamp());</span><br><span class="line">    &#125;,<span class="string">"t3"</span>).start();</span><br><span class="line"></span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        int stamp = atomicStampedReference.getStamp();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t第一次版本号： "</span>+stamp);</span><br><span class="line">        try &#123;</span><br><span class="line">            //暂停3S线程4，保证线程3完成ABA操作</span><br><span class="line">            TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        boolean result =  atomicStampedReference.compareAndSet(100,2019,stamp,stamp+1);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t修改成功否： "</span>+result+<span class="string">"\t 当前最新实际版本号： "</span>+atomicStampedReference.getStamp());</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t当前实际最新值： "</span>+atomicStampedReference.getReference());</span><br><span class="line">    &#125;,<span class="string">"t4"</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">=============以下是ABA问题的产生=============</span><br><span class="line">true    2019</span><br><span class="line">=============以下是ABA问题的解决=============</span><br><span class="line">t3  第一次版本号： 1</span><br><span class="line">t4  第一次版本号： 1</span><br><span class="line">true</span><br><span class="line">t3  第二次版本号： 2</span><br><span class="line">true</span><br><span class="line">t3  第三次版本号： 3</span><br><span class="line">t4  修改成功否： false     当前最新实际版本号： 3</span><br><span class="line">t4  当前实际最新值： 100</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JAVA_CAS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA_CAS </tag>
            
            <tag> ABA问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+Hexo搭建个人博客</title>
      <link href="/2019/04/25/Github-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/04/25/Github-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><ol><li>安装 Node</li><li>安装 Git</li><li>注册 GitHub</li><li>安装 Hexo</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h1 id="搭建本地个人博客"><a href="#搭建本地个人博客" class="headerlink" title="搭建本地个人博客"></a>搭建本地个人博客</h1><hr><h2 id="初始化-hexo"><a href="#初始化-hexo" class="headerlink" title="初始化 hexo"></a>初始化 hexo</h2><ul><li><p>新建一个空白文件夹（下文提到的“项目根目录”是指你新建的文件夹的位置）用于存放 hexo 资源。在空白文件夹里面打开 Git Bash ，输入下列命令行进行初始化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo init</span><br></pre></td></tr></table></figure><h2 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo g</span><br></pre></td></tr></table></figure><h2 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo s</span><br></pre></td></tr></table></figure></li><li><p>关闭本地服务器在 Git Bash 界面按 Ctrl+C， 在浏览器输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 查看<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2f6zotc21j30m80fhqa3.jpg"></p><h1 id="美化个人博客"><a href="#美化个人博客" class="headerlink" title="美化个人博客"></a>美化个人博客</h1></li></ul><hr><h2 id="博客主题设置"><a href="#博客主题设置" class="headerlink" title="博客主题设置"></a>博客主题设置</h2><h3 id="克隆主题"><a href="#克隆主题" class="headerlink" title="克隆主题"></a>克隆主题</h3><ul><li>在项目根目录下的 <strong>themes</strong> 文件中，打开 <strong>Git Bash</strong> ，用命令行克隆下新的主题。我这里用的 <strong>Next</strong> 主题，需要其他主题的自己百度找。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next.git</span><br></pre></td></tr></table></figure><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><ul><li>用文本的方式打开项目根目录下的 <font color="#DC143C">_config.yml</font> 配置文件，找到 <strong>theme</strong> 把原来默认的 <strong><del>landscape</del> </strong> 主题名字，改成刚刚克隆的主题名字。</li></ul><h3 id="测试主题"><a href="#测试主题" class="headerlink" title="测试主题"></a>测试主题</h3><ul><li><p>重新回到项目根目录下，打开 Git Bath ，用命令行启动服务器。在浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2f72ii44vj30m80cg41j.jpg" alt=""></p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3></li><li><p><strong>方法一：</strong>在项目根目录下，打开 <strong>Git Bash</strong> ，执行新建命令，然后 hexo 会自动在指定目录下生成对应文件，如下图所示。然后找到新建好的文件，打开即可进行编辑。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo new <span class="string">"此处输入文章名字"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法二：</strong>可以直接把已经准备的 md 格式的文章复制到 项目名称  <font color="#DC143C">/source/_posts</font> 目录下，然后打开文件，在文件头加入 front-matter 部分，title 表示文章标题，date 表示发布时间。如图所示，图片上用到的其他参数，后面会介绍到。</p></li><li><font color="#DC143C"><strong>重要的事情说三遍！！！</strong></font></li><li>front-matte 书写的时候要注意，冒号后面要跟一个空格号</li><li>front-matte 书写的时候要注意，冒号后面要跟一个空格号</li><li><p>front-matte 书写的时候要注意，冒号后面要跟一个空格号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 ---</span><br><span class="line">2 title: a</span><br><span class="line">3 date: 2019-04-25 21:27:13</span><br><span class="line">4 ---</span><br></pre></td></tr></table></figure></li><li><p>准备好 md 格式文件后，使用下面命令生成网站静态文件到默认设置的 public 文件夹，然后再启动本地服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo g</span><br></pre></td></tr></table></figure></li></ul><h2 id="主题风格设置"><a href="#主题风格设置" class="headerlink" title="主题风格设置"></a>主题风格设置</h2><ul><li>打开主题文件夹下的  <font color="#DC143C">_config.yml</font> 配置文件（注意：这里要区别，不是項目根目录，主题文件夹的路径为：<font color="#DC143C">新建空白文件夹名称/themes/主题文件夹名称</font>）。通过查找功能找到 Schemes 模块，修改为 Gemini 风格。如果喜欢其他风格可以自己修改。</li><li>刷新页面可以看到新风格的界面如下图所示:<br><img src="http://ww1.sinaimg.cn/large/006pqaYvgy1g2f7f8og8pj30m80avtc0.jpg" alt=""><h2 id="博客左侧栏设置"><a href="#博客左侧栏设置" class="headerlink" title="博客左侧栏设置"></a>博客左侧栏设置</h2></li><li>在上面的网站界面，可以发现网站的文字是英文，只要修改一下语言模式即可。打开根目录文件夹下的  <font color="#DC143C">_config.yml</font>配置文件。找到 language，设置为 <strong>zh-CN</strong>。标题等其他参数的设置如下。可以对照效果图的具体位置，根据自己的实际需求进行修改。（注意：修改了项目根目录下的  <font color="#DC143C">_config.yml</font>配置文件，需要重启部署项目后才能生效）<h2 id="分类设置"><a href="#分类设置" class="headerlink" title="分类设置"></a>分类设置</h2><h3 id="添加分类列表"><a href="#添加分类列表" class="headerlink" title="添加分类列表"></a>添加分类列表</h3></li><li><p>在项目根目录下，执行下面的命令行，新建分类页面，然后会在项目根目录下的 <strong>source</strong> 文件夹中新建一个 <strong>categories</strong> 文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 hexo new page categories</span><br></pre></td></tr></table></figure></li><li><p>打开 <strong>categories</strong> 文件夹中的 <strong>index.md</strong> 文件，添加 type 字段，设置为 “<strong>categories</strong>”。如下图所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 ---</span><br><span class="line">2 title: categories</span><br><span class="line">3 date: 2019-04-25 22:17:14</span><br><span class="line">4 <span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">5 ---</span><br></pre></td></tr></table></figure></li><li><p>接着到主题文件夹下的<font color="#DC143C">_config.yml</font> 配置文件下，找到 <strong>menu</strong> 模块，把 <strong>categories</strong> 的注释给去掉。</p></li><li>刷新页面（如果刷新没效果，可以重启服务），可以在页面左侧栏上看到多了一个“分类”列表。<h3 id="如何将文章添加到对应分类？"><a href="#如何将文章添加到对应分类？" class="headerlink" title="如何将文章添加到对应分类？"></a>如何将文章添加到对应分类？</h3></li><li>文章发布前，在<font color="#DC143C"> front-matter</font> 部分，多写一个 <strong>categories</strong> 字段，然后参数写上类别的名称，保存后重启服务，在网页上点击“分类”，可以看到分类下已经生成了刚刚设置的类别，并把刚刚发布的文章归类在此类别下。如下图所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 ---</span><br><span class="line">2 title: <span class="string">"文章的标题"</span></span><br><span class="line">3 date: 2019-04-25 22:17:14</span><br><span class="line">4 categories: <span class="string">"文章的分类"</span></span><br><span class="line">5 ---</span><br></pre></td></tr></table></figure></li></ul><h2 id="标签设置"><a href="#标签设置" class="headerlink" title="标签设置"></a>标签设置</h2><ul><li>方法跟分类设置一样，所以不再赘述介绍</li><li>但是需要补充一点， <font color="#DC143C"> front-matter</font> 中字段有多个参数的时候，可以使用如下图的写法。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 ---</span><br><span class="line">2 title: <span class="string">"文章的标题"</span></span><br><span class="line">3 date: 2019-04-25 22:17:14</span><br><span class="line">4 categories: <span class="string">"文章的分类"</span></span><br><span class="line">5 tags: </span><br><span class="line">6   -<span class="string">"标签1"</span></span><br><span class="line">7   -<span class="string">"标签2"</span></span><br><span class="line">8   -<span class="string">"标签3"</span></span><br><span class="line">9 description: <span class="string">"描述"</span></span><br><span class="line">10 photos: </span><br><span class="line">11   -<span class="string">"链接"</span></span><br><span class="line">12 ---</span><br></pre></td></tr></table></figure></li></ul><h2 id="博客添加站内搜索"><a href="#博客添加站内搜索" class="headerlink" title="博客添加站内搜索"></a>博客添加站内搜索</h2><ul><li>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。下面介绍 <strong>Local Search</strong> 的安装吧。注意：安装的时候要是项目根目录下安装。</li><li><p>安装 hexo-generator-search</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></li><li><p>安装 hexo-generator-searchdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录下的 <font color="#DC143C">_config.yml </font>配置文件的文末添加下面这段代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 search:</span><br><span class="line">2   path: search.xml</span><br><span class="line">3   field: post</span><br><span class="line">4   format: html</span><br><span class="line">5   <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure></li><li><p>编辑主题文件夹的 <font color="#DC143C">_config.yml </font> 配置文件，设置<font color="#DC143C"> Local searchenable </font>为 <strong>ture</strong>。</p></li><li>重启服务<h2 id="博客头像设置"><a href="#博客头像设置" class="headerlink" title="博客头像设置"></a>博客头像设置</h2><h3 id="添加博客头像"><a href="#添加博客头像" class="headerlink" title="添加博客头像"></a>添加博客头像</h3></li><li>打开主题文件夹下的 <font color="#DC143C">_config.yml </font> 配置文件，通过查找功能找到 <strong>avatar</strong>，然后把一个在线的头像图片地址（百度图片中直接复制链接即可），作为 <strong>url</strong> 的参数。</li><li>然后刷新页面，可以看到网站上已经显示了相应的头像了。<h2 id="右上角-fork-me-设置"><a href="#右上角-fork-me-设置" class="headerlink" title="右上角 fork me 设置"></a>右上角 fork me 设置</h2></li><li>在 <a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners</a> 上选择你喜欢的挂饰，复制方框内的代码。</li><li>打开主题文件夹下的 <strong>layout</strong> 文件夹，用记事本的方式打开 <strong>_layout.swig</strong>，把刚刚复制的代码放到下面，并把 href 的参数，修改为自己的 github 链接（放自己要跳转的网址即可）。</li><li>重启服务器，查看效果<h2 id="网页背景设置"><a href="#网页背景设置" class="headerlink" title="网页背景设置"></a>网页背景设置</h2><h3 id="动态背景设置"><a href="#动态背景设置" class="headerlink" title="动态背景设置"></a>动态背景设置</h3></li><li>打开主题文件夹下的 <strong>layout</strong> 文件夹，用文本的方式打开 <strong>_layout.swig</strong> 文件，在文末加上如下的代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;!-- 动态背景 --&gt;</span><br><span class="line">2 &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="背景图片设置"><a href="#背景图片设置" class="headerlink" title="背景图片设置"></a>背景图片设置</h3><ul><li>打开主题文件夹下的 <strong>source</strong> 文件夹，进入 <strong>css/_custom</strong> 文件下，用文本形式打开 <strong>custom.styl</strong> 文件，然后添加下面这段代码。代码中 <strong>url</strong> 的地址是指到： <font color="#DC143C">主题文件夹/source/images/</font> 。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 body&#123;</span><br><span class="line">2    background:url(/images/bg.jpg);</span><br><span class="line">3    background-size:cover;</span><br><span class="line">4    background-repeat:no-repeat;</span><br><span class="line">5    background-attachment:fixed;</span><br><span class="line">6    background-position:center;</span><br><span class="line">7    // 设置主题部分的透明度，具体看图</span><br><span class="line">8    opacity: 0.8;</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="首页文章预览设置"><a href="#首页文章预览设置" class="headerlink" title="首页文章预览设置"></a>首页文章预览设置</h2><ul><li>默认情况下，文章在首页是全文显示的，这样肯定是不方便读者浏览。所以需要实现预览模式。</li><li><strong>方法一：</strong>使用 <strong>&lt; !–more–&gt;</strong> 手动切断<br>这种方法可以根据文章的内容，自己在合适的位置添加 &lt; !–more–&gt; 标签，使用灵活，也是Hexo推荐的方法。</li><li><strong>方法二：</strong>添加 <strong>description</strong><br>在文章的<font color="#DC143C"> front-matter </font>中添加 <strong>description</strong> 和 <strong>photos</strong> 字段，如3.5图所示。如果不需要显示图片的话，可以把 photos 去掉。<br>ps：不知道 <font color="#DC143C"> front-matter </font> 是什么的话，跳转到第二章的第4点的发布文章看下。</li><li><strong>方法三</strong>：自动形成摘要<br>在主题文件下的<font color="#DC143C">_config.yml </font> 配置文件中添加默认截取的长度为 150 字符，可以根据需要自行设定。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 auto_excerpt:</span><br><span class="line">2   <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">3   length: 150</span><br></pre></td></tr></table></figure></li></ul><h2 id="RSS-设置"><a href="#RSS-设置" class="headerlink" title="RSS 设置"></a>RSS 设置</h2><ul><li><p>安装 hexo 插件，需要在 hexo 项目根目录下进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure></li><li><p>安装完成后在项目根目录下的 <font color="#DC143C">_config.yml </font> 配置文件的文末添加下面这段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 <span class="comment"># Extentions</span></span><br><span class="line">2 <span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line">3 plugins: hexo-generator-feed</span><br></pre></td></tr></table></figure></li><li><p>在主题文件夹下的 <font color="#DC143C">_config.yml </font>  配置文件中，找到 <strong>rss</strong> ，在后面加上 <strong>/atom.xml</strong>。</p></li><li>重启服务，刷新页面<h2 id="社交小图标设置"><a href="#社交小图标设置" class="headerlink" title="社交小图标设置"></a>社交小图标设置</h2></li><li>在主题文件夹下的<font color="#DC143C">_config.yml </font>配置文件中，搜索 <strong>Social</strong>，然后提示自己增加自己需要的小图标并设置对应连接。</li><li>图标可以到 <a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">Font Awesome Icon</a> 网站查找。<h2 id="友情链接设置"><a href="#友情链接设置" class="headerlink" title="友情链接设置"></a>友情链接设置</h2></li><li>在主题文件夹下的 <font color="#DC143C">_config.yml </font>配置文件中，搜索 links_title，然后根据自己的需求自己吸修改。<h2 id="博客置顶设置"><a href="#博客置顶设置" class="headerlink" title="博客置顶设置"></a>博客置顶设置</h2></li><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 npm uninstall hexo-generator-index --save</span><br><span class="line">2 npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure></li><li><p>然后在需要置顶的文章的 <strong>Front-matter</strong> 中加上 <strong>top</strong> 即可，数值越大表示等级越高，越靠前显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 ---</span><br><span class="line">2 title: <span class="string">"文章的标题"</span></span><br><span class="line">3 date: 2019-04-25 22:17:14</span><br><span class="line">4 top: 100</span><br><span class="line">5 ---</span><br></pre></td></tr></table></figure></li><li><p>在主题文件夹中打开<font color="#DC143C"> layout/_macro/post.swig</font> 文件，定位到 <strong>post-header</strong> ，把下面的代码添加进去即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &#123;% <span class="keyword">if</span> post.top %&#125;</span><br><span class="line">2  &lt;i class=<span class="string">"fa fa-thumb-tack"</span>&gt;&lt;/i&gt;</span><br><span class="line">3   &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">4 &#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="对接Github的远程仓库"><a href="#对接Github的远程仓库" class="headerlink" title="对接Github的远程仓库"></a>对接Github的远程仓库</h1><hr><ul><li>在Github创建一个公有仓库，并把公有仓库的链接保存下来。<br>注意：仓库名字必须是：username.github.io，其中username是你的用户名。</li><li>打开项目根目录下的 <font color="#DC143C">_config.yml </font> 配置文件，修改 <strong>deploy</strong> 的值。<strong>tpye</strong> 设置为 <strong>git</strong>，<strong>repo</strong> 则设置为刚刚新建的远程仓库链接。</li><li><font color="#DC143C">注意：冒号后面需要再加一个空格，不然会出现格式错误。</font> </li><li><p>安装hexo-deployer-gi</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>一键部署到远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 hexo g</span><br><span class="line">2 hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>回到刚刚新建的远程仓库，刷新页面，可以发现本地博客的相关文件已经全部部署到远程仓库上了。</p><h1 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h1></li></ul><hr><ul><li><p>常见命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure></li><li><p>缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>组合命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g <span class="comment">#生成并本地预览</span></span><br><span class="line">hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="本文参考链接"><a href="#本文参考链接" class="headerlink" title="本文参考链接"></a>本文参考链接</h1><hr><p><a href="https://www.jianshu.com/p/13f5e4d7099d" target="_blank" rel="noopener">https://www.jianshu.com/p/13f5e4d7099d</a></p><p><a href="http://theme-next.iissnan.com/theme-settings.html#rss" target="_blank" rel="noopener">http://theme-next.iissnan.com/theme-settings.html#rss</a></p><p><a href="https://www.jianshu.com/p/9f0e90cc32c2" target="_blank" rel="noopener">https://www.jianshu.com/p/9f0e90cc32c2</a></p><p><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">https://www.simon96.online/2018/10/12/hexo-tutorial/</a></p><p><a href="http://zwd596257180.gitee.io/blog/2019/04/15/hexo_manong_bog/" target="_blank" rel="noopener">http://zwd596257180.gitee.io/blog/2019/04/15/hexo_manong_bog/</a></p><p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/10/10/hello-world/"/>
      <url>/2018/10/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
